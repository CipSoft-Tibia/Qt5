\l QQmlEngineExtensionPlugin is a plugin interface that lets you
create QML extensions that can be loaded dynamically into QML applications.
These extensions allow custom QML types to be made available to the
QML engine.

To write a QML extension plugin:
\list 1
\li Subclass \l QQmlEngineExtensionPlugin and use the Q_PLUGIN_METADATA() macro
    to register the plugin with the Qt meta object system.
\li Use the \l QML_ELEMENT and \l QML_NAMED_ELEMENT() macros to declare
    QML types.
\li Configure your build file.

    CMake:
    \badcode
        qt_add_qml_module(<target>
            URI <my.import.name>
            VERSION 1.0
            QML_FILES <app.qml>
            NO_RESOURCE_TARGET_PATH
        )
    \endcode

    qmake:
    \badcode
        CONFIG += qmltypes
        QML_IMPORT_NAME = <my.import.name>
        QML_IMPORT_MAJOR_VERSION = <version>
    \endcode
\li If you're using qmake, create a
    \l {Module Definition qmldir Files} {qmldir file} to describe the plugin.
    Note that CMake will, by default, automatically generate the
    \l {Module Definition qmldir Files} {qmldir file}.
\endlist

QML extension plugins are for either application-specific or library-like
plugins. Library plugins should limit themselves to registering types, as
any manipulation of the engine's root context may cause conflicts or other
issues in the library user's code.

\note When using the CMake \l qt_add_qml_module API, a plugin will be generated
automatically for you. It will take care of type registration.
You only need to write a custom plugin if you have special
requirements, such as registering custom image
providers. In that case, pass
\l{NO_GENERATE_PLUGIN_SOURCE} to the \c qt_add_qml_module
call to disable the generation of the default plugin.

The linker might erroneously remove the generated type registration
function as an optimization. You can prevent that by declaring a synthetic
volatile pointer to the function somewhere in your code. If your module is
called "my.module", you would add the forward declaration in global scope:

\code
void qml_register_types_my_module();
\endcode

Then add the following snippet of code in the implementation of any function
that's part of the same binary as the registration:

\code
volatile auto registration = &qml_register_types_my_module;
Q_UNUSED(registration);
\endcode
