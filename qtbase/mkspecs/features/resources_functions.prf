# http://www.w3.org/TR/xml/#syntax
defineReplace(xml_escape) {
    1 ~= s,&,&amp;,
    1 ~= s,\',&apos;,
    1 ~= s,\",&quot;,
    1 ~= s,<,&lt;,
    1 ~= s,>,&gt;,
    return($$1)
}

defineTest(qtFlattenResources) {
    isEmpty(RCC_DIR):RCC_DIR = .
    immediate = qmake_immediate$$QMAKE_RESOURCES_IMMEDIATE_NR
    defined(QMAKE_RESOURCES_IMMEDIATE_NR, var): \
        QMAKE_RESOURCES_IMMEDIATE_NR = $$num_add($$QMAKE_RESOURCES_IMMEDIATE_NR, 1)
    else: \
        QMAKE_RESOURCES_IMMEDIATE_NR = 1

    RESOURCES += $$immediate
    for(resource, RESOURCES) {
        # Regular case of user qrc file
        contains(resource, ".*\\.qrc$"): \
            next()

        # Fallback for stand-alone files/directories
        !defined($${resource}.files, var) {
            !equals(resource, $$immediate) {
                !exists($$absolute_path($$resource, $$_PRO_FILE_PWD_)): \
                    warning("Failure to find: $$resource")
                $${immediate}.files += $$resource
                OTHER_FILES *= $$resource
            }
            RESOURCES -= $$resource
            next()
        }

        RESOURCES -= $$resource
        isEmpty(BUILDS)|build_pass {
            resource_file = $$absolute_path($$RCC_DIR/qmake_$${resource}.qrc, $$OUT_PWD)
            RESOURCES += $$resource_file
        } else: android {
            # Android will need a resource file for each architecture make sure it is placed
            # correctly for other functions that need the right paths for these files
            for (arch, ANDROID_ABIS) {
                resource_file = $$absolute_path($$RCC_DIR/$$arch/qmake_$${resource}.qrc, $$OUT_PWD)
                RESOURCES += $$resource_file
            }
        }

        isEmpty(BUILDS)|build_pass {
            # Collection of files, generate qrc file
            prefix = $$eval($${resource}.prefix)
            isEmpty(prefix): \
                prefix = "/"

            resource_file_content = \
                "<!DOCTYPE RCC><RCC version=\"1.0\">" \
                "<qresource prefix=\"$$xml_escape($$prefix)\">"

            abs_base = $$absolute_path($$eval($${resource}.base), $$_PRO_FILE_PWD_)

            for(file, $${resource}.files) {
                abs_path = $$absolute_path($$file, $$_PRO_FILE_PWD_)
                files = $$files($$abs_path/*, true)
                isEmpty(files): \
                    files = $$abs_path
                for (file, files) {
                    exists($$file/*): next()  # exclude directories
                    alias = $$relative_path($$file, $$abs_base)

                    # If a resource is added by the build system from outside of $$_PRO_FILE_PWD_
                    # everything except the filename needs to be discarded.
                    subdir = $$find(alias, ^../)
                    if (!isEmpty(subdir)): alias = $$basename(file)

                    resource_file_content += \
                        "<file alias=\"$$xml_escape($$alias)\">$$xml_escape($$file)</file>"
                    OTHER_FILES *= $$file
                }
            }

            resource_file_content += \
                "</qresource>" \
                "</RCC>"

            !write_file($$resource_file, resource_file_content): \
                error()
        }
    }
    export(RCC_DIR)
    export(QMAKE_RESOURCES_IMMEDIATE_NR)
    export(RESOURCES)
    export(OTHER_FILES)
    export($${immediate}.files)
    return(true)
}

defineTest(qtEnsurePluginResourcesCpp) {
    contains(DEFINES, QT_PLUGIN_RESOURCE_INIT_FUNCTION=.*): \
        return(true)

    !isEmpty(RESOURCES):contains(TEMPLATE, .*lib):plugin:static {
        pluginBaseName = $$basename(TARGET)
        pluginName = $$lower($$replace(pluginBaseName, [-], _))
        resource_init_function = $${pluginName}_plugin_resource_init
        DEFINES += "QT_PLUGIN_RESOURCE_INIT_FUNCTION=$$resource_init_function"
        RESOURCE_INIT_CPP = $$OUT_PWD/$${pluginName}_plugin_resources.cpp

        GENERATED_SOURCES += $$RESOURCE_INIT_CPP
        QMAKE_DISTCLEAN += $$RESOURCE_INIT_CPP

        isEmpty(BUILDS)|build_pass {
            RESOURCE_INIT_CONT = \
                "// This file is autogenerated by qmake. It contains a function that" \
                "// references all resources the plugin includes and the function is" \
                "// referenced by QT_(MOC_)EXPORT_PLUGIN to ensure the inclusion in" \
                "// the statically linked plugin." \
                "$${LITERAL_HASH}include <QtCore/qglobal.h>" \
                "void $${resource_init_function}() " \
                "{" \

            for (resource, RESOURCES) {
                resource_name = $$replace($$list($$basename(resource)),\.qrc$, )
                resource_name = $$replace(resource_name, [^a-zA-Z0-9_], _)
                RESOURCE_INIT_CONT += "    Q_INIT_RESOURCE($$resource_name);"
            }

            RESOURCE_INIT_CONT += \
                "}"

            write_file($$RESOURCE_INIT_CPP, RESOURCE_INIT_CONT)|error()
        }

        export(DEFINES)
        export(GENERATED_SOURCES)
        export(QMAKE_DISTCLEAN)
    }
    return(true)
}
