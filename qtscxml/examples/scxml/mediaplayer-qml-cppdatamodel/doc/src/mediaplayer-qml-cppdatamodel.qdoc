/****************************************************************************
**
** Copyright (C) 2016 The Qt Company Ltd.
** Contact: https://www.qt.io/licensing/
**
** This file is part of the documentation of the Qt Toolkit.
**
** $QT_BEGIN_LICENSE:FDL$
** Commercial License Usage
** Licensees holding valid commercial Qt licenses may use this file in
** accordance with the commercial license agreement provided with the
** Software or, alternatively, in accordance with the terms contained in
** a written agreement between you and The Qt Company. For licensing terms
** and conditions see https://www.qt.io/terms-conditions. For further
** information use the contact form at https://www.qt.io/contact-us.
**
** GNU Free Documentation License Usage
** Alternatively, this file may be used under the terms of the GNU Free
** Documentation License version 1.3 as published by the Free Software
** Foundation and appearing in the file included in the packaging of
** this file. Please review the following information to ensure
** the GNU Free Documentation License version 1.3 requirements
** will be met: https://www.gnu.org/licenses/fdl-1.3.html.
** $QT_END_LICENSE$
**
****************************************************************************/

/*!
    \example mediaplayer-qml-cppdatamodel
    \title Qt SCXML Media Player QML Example (C++ Data Model)
    \ingroup examples-qtscxml

    \image mediaplayer.png

    \brief Sends data to and receives it from a C++ data model.

    \e {Media Player QML Example (C++ Data Model)} demonstrates how to access
    data from a C++ data model. The data model enables writing C++ code for
    \e expr attributes and \c <script> elements. The \e {data part} of the data
    model is backed by a subclass of QScxmlCppDataModel, for which the Qt SCXML
    compiler (\c qscxmlc) generates the dispatch methods.

    The UI is created using Qt Quick.

    \include examples-run.qdocinc

    \section1 Using the C++ Data Model

    We specify the data model as a value of the \e datamodel attribute of the
    \c <scxml> element in the SCXML file:

    \quotefromfile mediaplayer-qml-cppdatamodel/mediaplayer-cppdatamodel.scxml
    \skipto scxml
    \printuntil datamodel

    The format of the \e datamodel attribute is:
    \c {cplusplus:<class-name>:<classdef-header>}. Therefore, we need a file
    called \e thedatamodel.h that contains a subclass of QScxmlCppDataModel:

    \quotefromfile mediaplayer-qml-cppdatamodel/thedatamodel.h
    \skipto qscxmlcppdatamodel.h
    \printuntil Q_SCXML_DATAMODEL

    QScxmlCppDataModel derives from QObject, so we add the \c Q_OBJECT macro in
    the private section of the definition, right after the opening bracket. We
    then place the \c Q_SCXML_DATAMODEL macro after \c Q_OBJECT. The macro
    expands to the declaration of virtual methods, the implementation of which
    is generated by the Qt SCXML compiler.

    In the SCXML file, we specify C++ statements in the \c <script> element and
    use the \e expr attribute to access the data model:

    \quotefromfile mediaplayer-qml-cppdatamodel/mediaplayer-cppdatamodel.scxml
    \skipto state
    \printuntil </state>
    \printuntil </state>

    The Qt SCXML compiler generates the various \c evaluateTo methods and
    converts the expressions and scripts into lambdas inside those methods in
    \e mediaplayer-cppdatamodel.cpp:

    \code
    bool TheDataModel::evaluateToBool(QScxmlExecutableContent::EvaluatorId id, bool *ok) {
    ....
        return [this]()->bool{ return isValidMedia(); }();
    ....
    }

    QVariant TheDataModel::evaluateToVariant(QScxmlExecutableContent::EvaluatorId id, bool *ok) {
    ....
            return [this]()->QVariant{ return media; }();
    ....
    }

    void TheDataModel::evaluateToVoid(QScxmlExecutableContent::EvaluatorId id, bool *ok) {
    ....
            [this]()->void{ media = eventData().value(QStringLiteral("media")).toString(); }();
    ....
    }
    \endcode
*/
