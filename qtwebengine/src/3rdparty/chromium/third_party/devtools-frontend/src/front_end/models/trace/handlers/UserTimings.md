# Parsing UserTimings

UserTimings have the `cat` of `blink.user_timing`, however this category is overloaded and in actual fact there are three distinct types of events that have this category:

### 1. Injected timings
Chrome will inject some timings that have this category. These align with the Performance Navigation Timing API [https://www.w3.org/TR/navigation-timing-2/#sec-PerformanceNavigationTiming] and the Resource Timing API [https://www.w3.org/TR/resource-timing-2/#sec-performanceresourcetiming].

You can see how the legacy data layer filters these out in `TimelineFlameChartDataProvider.ts` [https://source.chromium.org/chromium/chromium/src/+/main:third_party/devtools-frontend/src/front_end/panels/timeline/TimelineFlameChartDataProvider.ts;l=851?q=timelineflamechartdataprov&ss=chromium].

When working with user timings we have to be careful to filter out any events that aren't actually user timings generated by calls to `performance.mark` or `performance.measure`.

### 2. Performance mark calls
If the user has code such as `const foo = performance.mark('foo')`, that will generate a single event in the trace file. We can use this to give us a list of all marks that were created, but **currently we do not use this information**.

### 3. Pairs of begin/end events for `performance.measure` calls

Events that represent a `performance.measure` call will come in pairs: a begin event, and an end event. These are always asynchronous events, and have the `phase` of `b` or `e`. We can pair these events by using their `id` field, which is the same for the begin and end event. It is impossible for a trace to have a begin event without an end event, or vice-versa.


## Parsing out user timings

Currently in the handler we only deal with (3) from the above list, and do not parse out performance marks. The handler looks for begin or end events in the trace. Once we have these, we then pair them up, and create a list of synthetic user timing events. These are events that do not actually exist in the trace, but we create because we need one event to map to each block. The event is made up of information from the begin and/or end event and includes most crucially:

* The string `id` of the block (shared with the begin and end events)
* The `name` of the block - which will be the text the user passed to `performance.measure`. For example, `performance.measure('foo', someMark)` will cause the `name` to be `'foo'`.
* The timestamp (`ts`) which is set to the timestamp of the `begin` event.
* The duration (`dur`) which is set to the `end` event timestamp minus the `begin` event timestamp.
* The source `begin` & `end` events under `args.data`

