// [The "BSD 3-clause license"]
// Copyright (c) 2005-2007 Terence Parr
// Copyright (c) 2012-2015 Terence Parr
// Copyright (c) 2012-2015 Sam Harwell
// Copyright (c) 2014-2015 Gerald Rosenberg
// Copyright (c) 2023 Google LLC
// All rights reserved.

// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:

//  1. Redistributions of source code must retain the above copyright
//     notice, this list of conditions and the following disclaimer.
//  2. Redistributions in binary form must reproduce the above copyright
//     notice, this list of conditions and the following disclaimer in the
//     documentation and/or other materials provided with the distribution.
//  3. Neither the name of the copyright holder nor the names of its
//     contributors may be used to endorse or promote products derived from this
//     software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// Generated from ANTLRv4Parser.g4 by ANTLR 4.11.2

#include "ANTLRv4Parser.h"

#include "ANTLRv4ParserListener.h"

using namespace antlrcpp;
using namespace antlr4_grammar;

using namespace antlr4;

namespace {

struct ANTLRv4ParserStaticData final {
  ANTLRv4ParserStaticData(std::vector<std::string> ruleNames,
                          std::vector<std::string> literalNames,
                          std::vector<std::string> symbolicNames)
      : ruleNames(std::move(ruleNames)),
        literalNames(std::move(literalNames)),
        symbolicNames(std::move(symbolicNames)),
        vocabulary(this->literalNames, this->symbolicNames) {}

  ANTLRv4ParserStaticData(const ANTLRv4ParserStaticData &) = delete;
  ANTLRv4ParserStaticData(ANTLRv4ParserStaticData &&) = delete;
  ANTLRv4ParserStaticData &operator=(const ANTLRv4ParserStaticData &) = delete;
  ANTLRv4ParserStaticData &operator=(ANTLRv4ParserStaticData &&) = delete;

  std::vector<antlr4::dfa::DFA> decisionToDFA;
  antlr4::atn::PredictionContextCache sharedContextCache;
  const std::vector<std::string> ruleNames;
  const std::vector<std::string> literalNames;
  const std::vector<std::string> symbolicNames;
  const antlr4::dfa::Vocabulary vocabulary;
  antlr4::atn::SerializedATNView serializedATN;
  std::unique_ptr<antlr4::atn::ATN> atn;
};

::antlr4::internal::OnceFlag antlrv4parserParserOnceFlag;
ANTLRv4ParserStaticData *antlrv4parserParserStaticData = nullptr;

void antlrv4parserParserInitialize() {
  assert(antlrv4parserParserStaticData == nullptr);
  auto staticData = std::make_unique<ANTLRv4ParserStaticData>(
      std::vector<std::string>{"grammarSpec",      "grammarDecl",
                               "grammarType",      "prequelConstruct",
                               "optionsSpec",      "option",
                               "optionValue",      "delegateGrammars",
                               "delegateGrammar",  "tokensSpec",
                               "channelsSpec",     "idList",
                               "action_",          "actionScopeName",
                               "actionBlock",      "argActionBlock",
                               "modeSpec",         "rules",
                               "ruleSpec",         "parserRuleSpec",
                               "exceptionGroup",   "exceptionHandler",
                               "finallyClause",    "rulePrequel",
                               "ruleReturns",      "throwsSpec",
                               "localsSpec",       "ruleAction",
                               "ruleModifiers",    "ruleModifier",
                               "ruleBlock",        "ruleAltList",
                               "labeledAlt",       "lexerRuleSpec",
                               "lexerRuleBlock",   "lexerAltList",
                               "lexerAlt",         "lexerElements",
                               "lexerElement",     "labeledLexerElement",
                               "lexerBlock",       "lexerCommands",
                               "lexerCommand",     "lexerCommandName",
                               "lexerCommandExpr", "altList",
                               "alternative",      "element",
                               "labeledElement",   "ebnf",
                               "blockSuffix",      "ebnfSuffix",
                               "lexerAtom",        "atom",
                               "notSet",           "blockSet",
                               "setElement",       "block",
                               "ruleref",          "characterRange",
                               "terminal",         "elementOptions",
                               "elementOption",    "identifier"},
      std::vector<std::string>{"",          "",           "",
                               "",          "",           "",
                               "",          "",           "",
                               "",          "",           "",
                               "",          "",           "",
                               "'import'",  "'fragment'", "'lexer'",
                               "'parser'",  "'grammar'",  "'protected'",
                               "'public'",  "'private'",  "'returns'",
                               "'locals'",  "'throws'",   "'catch'",
                               "'finally'", "'mode'"},
      std::vector<std::string>{"",
                               "TOKEN_REF",
                               "RULE_REF",
                               "LEXER_CHAR_SET",
                               "DOC_COMMENT",
                               "BLOCK_COMMENT",
                               "LINE_COMMENT",
                               "INT",
                               "STRING_LITERAL",
                               "UNTERMINATED_STRING_LITERAL",
                               "BEGIN_ARGUMENT",
                               "BEGIN_ACTION",
                               "OPTIONS",
                               "TOKENS",
                               "CHANNELS",
                               "IMPORT",
                               "FRAGMENT",
                               "LEXER",
                               "PARSER",
                               "GRAMMAR",
                               "PROTECTED",
                               "PUBLIC",
                               "PRIVATE",
                               "RETURNS",
                               "LOCALS",
                               "THROWS",
                               "CATCH",
                               "FINALLY",
                               "MODE",
                               "COLON",
                               "COLONCOLON",
                               "COMMA",
                               "SEMI",
                               "LPAREN",
                               "RPAREN",
                               "LBRACE",
                               "RBRACE",
                               "RARROW",
                               "LT",
                               "GT",
                               "ASSIGN",
                               "QUESTION",
                               "STAR",
                               "PLUS_ASSIGN",
                               "PLUS",
                               "OR",
                               "DOLLAR",
                               "RANGE",
                               "DOT",
                               "AT",
                               "POUND",
                               "NOT",
                               "ID",
                               "WS",
                               "ERRCHAR",
                               "END_ARGUMENT",
                               "UNTERMINATED_ARGUMENT",
                               "ARGUMENT_CONTENT",
                               "END_ACTION",
                               "UNTERMINATED_ACTION",
                               "ACTION_CONTENT",
                               "UNTERMINATED_CHAR_SET"});
  static const int32_t serializedATNSegment[] = {
      4,   1,   61,  626, 2,   0,   7,   0,   2,   1,   7,   1,   2,   2,   7,
      2,   2,   3,   7,   3,   2,   4,   7,   4,   2,   5,   7,   5,   2,   6,
      7,   6,   2,   7,   7,   7,   2,   8,   7,   8,   2,   9,   7,   9,   2,
      10,  7,   10,  2,   11,  7,   11,  2,   12,  7,   12,  2,   13,  7,   13,
      2,   14,  7,   14,  2,   15,  7,   15,  2,   16,  7,   16,  2,   17,  7,
      17,  2,   18,  7,   18,  2,   19,  7,   19,  2,   20,  7,   20,  2,   21,
      7,   21,  2,   22,  7,   22,  2,   23,  7,   23,  2,   24,  7,   24,  2,
      25,  7,   25,  2,   26,  7,   26,  2,   27,  7,   27,  2,   28,  7,   28,
      2,   29,  7,   29,  2,   30,  7,   30,  2,   31,  7,   31,  2,   32,  7,
      32,  2,   33,  7,   33,  2,   34,  7,   34,  2,   35,  7,   35,  2,   36,
      7,   36,  2,   37,  7,   37,  2,   38,  7,   38,  2,   39,  7,   39,  2,
      40,  7,   40,  2,   41,  7,   41,  2,   42,  7,   42,  2,   43,  7,   43,
      2,   44,  7,   44,  2,   45,  7,   45,  2,   46,  7,   46,  2,   47,  7,
      47,  2,   48,  7,   48,  2,   49,  7,   49,  2,   50,  7,   50,  2,   51,
      7,   51,  2,   52,  7,   52,  2,   53,  7,   53,  2,   54,  7,   54,  2,
      55,  7,   55,  2,   56,  7,   56,  2,   57,  7,   57,  2,   58,  7,   58,
      2,   59,  7,   59,  2,   60,  7,   60,  2,   61,  7,   61,  2,   62,  7,
      62,  2,   63,  7,   63,  1,   0,   1,   0,   5,   0,   131, 8,   0,   10,
      0,   12,  0,   134, 9,   0,   1,   0,   1,   0,   5,   0,   138, 8,   0,
      10,  0,   12,  0,   141, 9,   0,   1,   0,   1,   0,   1,   1,   1,   1,
      1,   1,   1,   1,   1,   2,   1,   2,   1,   2,   1,   2,   1,   2,   3,
      2,   154, 8,   2,   1,   3,   1,   3,   1,   3,   1,   3,   1,   3,   3,
      3,   161, 8,   3,   1,   4,   1,   4,   1,   4,   1,   4,   5,   4,   167,
      8,   4,   10,  4,   12,  4,   170, 9,   4,   1,   4,   1,   4,   1,   5,
      1,   5,   1,   5,   1,   5,   1,   6,   1,   6,   1,   6,   5,   6,   181,
      8,   6,   10,  6,   12,  6,   184, 9,   6,   1,   6,   1,   6,   1,   6,
      3,   6,   189, 8,   6,   1,   7,   1,   7,   1,   7,   1,   7,   5,   7,
      195, 8,   7,   10,  7,   12,  7,   198, 9,   7,   1,   7,   1,   7,   1,
      8,   1,   8,   1,   8,   1,   8,   1,   8,   3,   8,   207, 8,   8,   1,
      9,   1,   9,   3,   9,   211, 8,   9,   1,   9,   1,   9,   1,   10,  1,
      10,  3,   10,  217, 8,   10,  1,   10,  1,   10,  1,   11,  1,   11,  1,
      11,  5,   11,  224, 8,   11,  10,  11,  12,  11,  227, 9,   11,  1,   11,
      3,   11,  230, 8,   11,  1,   12,  1,   12,  1,   12,  1,   12,  3,   12,
      236, 8,   12,  1,   12,  1,   12,  1,   12,  1,   13,  1,   13,  1,   13,
      3,   13,  244, 8,   13,  1,   14,  1,   14,  5,   14,  248, 8,   14,  10,
      14,  12,  14,  251, 9,   14,  1,   14,  1,   14,  1,   15,  1,   15,  5,
      15,  257, 8,   15,  10,  15,  12,  15,  260, 9,   15,  1,   15,  1,   15,
      1,   16,  1,   16,  1,   16,  1,   16,  5,   16,  268, 8,   16,  10,  16,
      12,  16,  271, 9,   16,  1,   17,  5,   17,  274, 8,   17,  10,  17,  12,
      17,  277, 9,   17,  1,   18,  1,   18,  3,   18,  281, 8,   18,  1,   19,
      3,   19,  284, 8,   19,  1,   19,  1,   19,  3,   19,  288, 8,   19,  1,
      19,  3,   19,  291, 8,   19,  1,   19,  3,   19,  294, 8,   19,  1,   19,
      3,   19,  297, 8,   19,  1,   19,  5,   19,  300, 8,   19,  10,  19,  12,
      19,  303, 9,   19,  1,   19,  1,   19,  1,   19,  1,   19,  1,   19,  1,
      20,  5,   20,  311, 8,   20,  10,  20,  12,  20,  314, 9,   20,  1,   20,
      3,   20,  317, 8,   20,  1,   21,  1,   21,  1,   21,  1,   21,  1,   22,
      1,   22,  1,   22,  1,   23,  1,   23,  3,   23,  328, 8,   23,  1,   24,
      1,   24,  1,   24,  1,   25,  1,   25,  1,   25,  1,   25,  5,   25,  337,
      8,   25,  10,  25,  12,  25,  340, 9,   25,  1,   26,  1,   26,  1,   26,
      1,   27,  1,   27,  1,   27,  1,   27,  1,   28,  4,   28,  350, 8,   28,
      11,  28,  12,  28,  351, 1,   29,  1,   29,  1,   30,  1,   30,  1,   31,
      1,   31,  1,   31,  5,   31,  361, 8,   31,  10,  31,  12,  31,  364, 9,
      31,  1,   32,  1,   32,  1,   32,  3,   32,  369, 8,   32,  1,   33,  3,
      33,  372, 8,   33,  1,   33,  1,   33,  1,   33,  1,   33,  1,   33,  1,
      34,  1,   34,  1,   35,  1,   35,  1,   35,  5,   35,  384, 8,   35,  10,
      35,  12,  35,  387, 9,   35,  1,   36,  1,   36,  3,   36,  391, 8,   36,
      1,   36,  3,   36,  394, 8,   36,  1,   37,  4,   37,  397, 8,   37,  11,
      37,  12,  37,  398, 1,   37,  3,   37,  402, 8,   37,  1,   38,  1,   38,
      3,   38,  406, 8,   38,  1,   38,  1,   38,  3,   38,  410, 8,   38,  1,
      38,  1,   38,  3,   38,  414, 8,   38,  1,   38,  1,   38,  3,   38,  418,
      8,   38,  3,   38,  420, 8,   38,  1,   39,  1,   39,  1,   39,  1,   39,
      3,   39,  426, 8,   39,  1,   40,  1,   40,  1,   40,  1,   40,  1,   41,
      1,   41,  1,   41,  1,   41,  5,   41,  436, 8,   41,  10,  41,  12,  41,
      439, 9,   41,  1,   42,  1,   42,  1,   42,  1,   42,  1,   42,  1,   42,
      3,   42,  447, 8,   42,  1,   43,  1,   43,  3,   43,  451, 8,   43,  1,
      44,  1,   44,  3,   44,  455, 8,   44,  1,   45,  1,   45,  1,   45,  5,
      45,  460, 8,   45,  10,  45,  12,  45,  463, 9,   45,  1,   46,  3,   46,
      466, 8,   46,  1,   46,  4,   46,  469, 8,   46,  11,  46,  12,  46,  470,
      1,   46,  3,   46,  474, 8,   46,  1,   47,  1,   47,  1,   47,  3,   47,
      479, 8,   47,  1,   47,  1,   47,  1,   47,  3,   47,  484, 8,   47,  1,
      47,  1,   47,  1,   47,  3,   47,  489, 8,   47,  3,   47,  491, 8,   47,
      1,   48,  1,   48,  1,   48,  1,   48,  3,   48,  497, 8,   48,  1,   49,
      1,   49,  3,   49,  501, 8,   49,  1,   50,  1,   50,  1,   51,  1,   51,
      3,   51,  507, 8,   51,  1,   51,  1,   51,  3,   51,  511, 8,   51,  1,
      51,  1,   51,  3,   51,  515, 8,   51,  3,   51,  517, 8,   51,  1,   52,
      1,   52,  1,   52,  1,   52,  1,   52,  1,   52,  3,   52,  525, 8,   52,
      3,   52,  527, 8,   52,  1,   53,  1,   53,  1,   53,  1,   53,  1,   53,
      3,   53,  534, 8,   53,  3,   53,  536, 8,   53,  1,   54,  1,   54,  1,
      54,  1,   54,  3,   54,  542, 8,   54,  1,   55,  1,   55,  1,   55,  1,
      55,  5,   55,  548, 8,   55,  10,  55,  12,  55,  551, 9,   55,  1,   55,
      1,   55,  1,   56,  1,   56,  3,   56,  557, 8,   56,  1,   56,  1,   56,
      3,   56,  561, 8,   56,  1,   56,  1,   56,  3,   56,  565, 8,   56,  1,
      57,  1,   57,  3,   57,  569, 8,   57,  1,   57,  5,   57,  572, 8,   57,
      10,  57,  12,  57,  575, 9,   57,  1,   57,  3,   57,  578, 8,   57,  1,
      57,  1,   57,  1,   57,  1,   58,  1,   58,  3,   58,  585, 8,   58,  1,
      58,  3,   58,  588, 8,   58,  1,   59,  1,   59,  1,   59,  1,   59,  1,
      60,  1,   60,  3,   60,  596, 8,   60,  1,   60,  1,   60,  3,   60,  600,
      8,   60,  3,   60,  602, 8,   60,  1,   61,  1,   61,  1,   61,  1,   61,
      5,   61,  608, 8,   61,  10,  61,  12,  61,  611, 9,   61,  1,   61,  1,
      61,  1,   62,  1,   62,  1,   62,  1,   62,  1,   62,  3,   62,  620, 8,
      62,  3,   62,  622, 8,   62,  1,   63,  1,   63,  1,   63,  0,   0,   64,
      0,   2,   4,   6,   8,   10,  12,  14,  16,  18,  20,  22,  24,  26,  28,
      30,  32,  34,  36,  38,  40,  42,  44,  46,  48,  50,  52,  54,  56,  58,
      60,  62,  64,  66,  68,  70,  72,  74,  76,  78,  80,  82,  84,  86,  88,
      90,  92,  94,  96,  98,  100, 102, 104, 106, 108, 110, 112, 114, 116, 118,
      120, 122, 124, 126, 0,   3,   2,   0,   16,  16,  20,  22,  2,   0,   40,
      40,  43,  43,  1,   0,   1,   2,   663, 0,   128, 1,   0,   0,   0,   2,
      144, 1,   0,   0,   0,   4,   153, 1,   0,   0,   0,   6,   160, 1,   0,
      0,   0,   8,   162, 1,   0,   0,   0,   10,  173, 1,   0,   0,   0,   12,
      188, 1,   0,   0,   0,   14,  190, 1,   0,   0,   0,   16,  206, 1,   0,
      0,   0,   18,  208, 1,   0,   0,   0,   20,  214, 1,   0,   0,   0,   22,
      220, 1,   0,   0,   0,   24,  231, 1,   0,   0,   0,   26,  243, 1,   0,
      0,   0,   28,  245, 1,   0,   0,   0,   30,  254, 1,   0,   0,   0,   32,
      263, 1,   0,   0,   0,   34,  275, 1,   0,   0,   0,   36,  280, 1,   0,
      0,   0,   38,  283, 1,   0,   0,   0,   40,  312, 1,   0,   0,   0,   42,
      318, 1,   0,   0,   0,   44,  322, 1,   0,   0,   0,   46,  327, 1,   0,
      0,   0,   48,  329, 1,   0,   0,   0,   50,  332, 1,   0,   0,   0,   52,
      341, 1,   0,   0,   0,   54,  344, 1,   0,   0,   0,   56,  349, 1,   0,
      0,   0,   58,  353, 1,   0,   0,   0,   60,  355, 1,   0,   0,   0,   62,
      357, 1,   0,   0,   0,   64,  365, 1,   0,   0,   0,   66,  371, 1,   0,
      0,   0,   68,  378, 1,   0,   0,   0,   70,  380, 1,   0,   0,   0,   72,
      393, 1,   0,   0,   0,   74,  401, 1,   0,   0,   0,   76,  419, 1,   0,
      0,   0,   78,  421, 1,   0,   0,   0,   80,  427, 1,   0,   0,   0,   82,
      431, 1,   0,   0,   0,   84,  446, 1,   0,   0,   0,   86,  450, 1,   0,
      0,   0,   88,  454, 1,   0,   0,   0,   90,  456, 1,   0,   0,   0,   92,
      473, 1,   0,   0,   0,   94,  490, 1,   0,   0,   0,   96,  492, 1,   0,
      0,   0,   98,  498, 1,   0,   0,   0,   100, 502, 1,   0,   0,   0,   102,
      516, 1,   0,   0,   0,   104, 526, 1,   0,   0,   0,   106, 535, 1,   0,
      0,   0,   108, 541, 1,   0,   0,   0,   110, 543, 1,   0,   0,   0,   112,
      564, 1,   0,   0,   0,   114, 566, 1,   0,   0,   0,   116, 582, 1,   0,
      0,   0,   118, 589, 1,   0,   0,   0,   120, 601, 1,   0,   0,   0,   122,
      603, 1,   0,   0,   0,   124, 621, 1,   0,   0,   0,   126, 623, 1,   0,
      0,   0,   128, 132, 3,   2,   1,   0,   129, 131, 3,   6,   3,   0,   130,
      129, 1,   0,   0,   0,   131, 134, 1,   0,   0,   0,   132, 130, 1,   0,
      0,   0,   132, 133, 1,   0,   0,   0,   133, 135, 1,   0,   0,   0,   134,
      132, 1,   0,   0,   0,   135, 139, 3,   34,  17,  0,   136, 138, 3,   32,
      16,  0,   137, 136, 1,   0,   0,   0,   138, 141, 1,   0,   0,   0,   139,
      137, 1,   0,   0,   0,   139, 140, 1,   0,   0,   0,   140, 142, 1,   0,
      0,   0,   141, 139, 1,   0,   0,   0,   142, 143, 5,   0,   0,   1,   143,
      1,   1,   0,   0,   0,   144, 145, 3,   4,   2,   0,   145, 146, 3,   126,
      63,  0,   146, 147, 5,   32,  0,   0,   147, 3,   1,   0,   0,   0,   148,
      149, 5,   17,  0,   0,   149, 154, 5,   19,  0,   0,   150, 151, 5,   18,
      0,   0,   151, 154, 5,   19,  0,   0,   152, 154, 5,   19,  0,   0,   153,
      148, 1,   0,   0,   0,   153, 150, 1,   0,   0,   0,   153, 152, 1,   0,
      0,   0,   154, 5,   1,   0,   0,   0,   155, 161, 3,   8,   4,   0,   156,
      161, 3,   14,  7,   0,   157, 161, 3,   18,  9,   0,   158, 161, 3,   20,
      10,  0,   159, 161, 3,   24,  12,  0,   160, 155, 1,   0,   0,   0,   160,
      156, 1,   0,   0,   0,   160, 157, 1,   0,   0,   0,   160, 158, 1,   0,
      0,   0,   160, 159, 1,   0,   0,   0,   161, 7,   1,   0,   0,   0,   162,
      168, 5,   12,  0,   0,   163, 164, 3,   10,  5,   0,   164, 165, 5,   32,
      0,   0,   165, 167, 1,   0,   0,   0,   166, 163, 1,   0,   0,   0,   167,
      170, 1,   0,   0,   0,   168, 166, 1,   0,   0,   0,   168, 169, 1,   0,
      0,   0,   169, 171, 1,   0,   0,   0,   170, 168, 1,   0,   0,   0,   171,
      172, 5,   36,  0,   0,   172, 9,   1,   0,   0,   0,   173, 174, 3,   126,
      63,  0,   174, 175, 5,   40,  0,   0,   175, 176, 3,   12,  6,   0,   176,
      11,  1,   0,   0,   0,   177, 182, 3,   126, 63,  0,   178, 179, 5,   48,
      0,   0,   179, 181, 3,   126, 63,  0,   180, 178, 1,   0,   0,   0,   181,
      184, 1,   0,   0,   0,   182, 180, 1,   0,   0,   0,   182, 183, 1,   0,
      0,   0,   183, 189, 1,   0,   0,   0,   184, 182, 1,   0,   0,   0,   185,
      189, 5,   8,   0,   0,   186, 189, 3,   28,  14,  0,   187, 189, 5,   7,
      0,   0,   188, 177, 1,   0,   0,   0,   188, 185, 1,   0,   0,   0,   188,
      186, 1,   0,   0,   0,   188, 187, 1,   0,   0,   0,   189, 13,  1,   0,
      0,   0,   190, 191, 5,   15,  0,   0,   191, 196, 3,   16,  8,   0,   192,
      193, 5,   31,  0,   0,   193, 195, 3,   16,  8,   0,   194, 192, 1,   0,
      0,   0,   195, 198, 1,   0,   0,   0,   196, 194, 1,   0,   0,   0,   196,
      197, 1,   0,   0,   0,   197, 199, 1,   0,   0,   0,   198, 196, 1,   0,
      0,   0,   199, 200, 5,   32,  0,   0,   200, 15,  1,   0,   0,   0,   201,
      202, 3,   126, 63,  0,   202, 203, 5,   40,  0,   0,   203, 204, 3,   126,
      63,  0,   204, 207, 1,   0,   0,   0,   205, 207, 3,   126, 63,  0,   206,
      201, 1,   0,   0,   0,   206, 205, 1,   0,   0,   0,   207, 17,  1,   0,
      0,   0,   208, 210, 5,   13,  0,   0,   209, 211, 3,   22,  11,  0,   210,
      209, 1,   0,   0,   0,   210, 211, 1,   0,   0,   0,   211, 212, 1,   0,
      0,   0,   212, 213, 5,   36,  0,   0,   213, 19,  1,   0,   0,   0,   214,
      216, 5,   14,  0,   0,   215, 217, 3,   22,  11,  0,   216, 215, 1,   0,
      0,   0,   216, 217, 1,   0,   0,   0,   217, 218, 1,   0,   0,   0,   218,
      219, 5,   36,  0,   0,   219, 21,  1,   0,   0,   0,   220, 225, 3,   126,
      63,  0,   221, 222, 5,   31,  0,   0,   222, 224, 3,   126, 63,  0,   223,
      221, 1,   0,   0,   0,   224, 227, 1,   0,   0,   0,   225, 223, 1,   0,
      0,   0,   225, 226, 1,   0,   0,   0,   226, 229, 1,   0,   0,   0,   227,
      225, 1,   0,   0,   0,   228, 230, 5,   31,  0,   0,   229, 228, 1,   0,
      0,   0,   229, 230, 1,   0,   0,   0,   230, 23,  1,   0,   0,   0,   231,
      235, 5,   49,  0,   0,   232, 233, 3,   26,  13,  0,   233, 234, 5,   30,
      0,   0,   234, 236, 1,   0,   0,   0,   235, 232, 1,   0,   0,   0,   235,
      236, 1,   0,   0,   0,   236, 237, 1,   0,   0,   0,   237, 238, 3,   126,
      63,  0,   238, 239, 3,   28,  14,  0,   239, 25,  1,   0,   0,   0,   240,
      244, 3,   126, 63,  0,   241, 244, 5,   17,  0,   0,   242, 244, 5,   18,
      0,   0,   243, 240, 1,   0,   0,   0,   243, 241, 1,   0,   0,   0,   243,
      242, 1,   0,   0,   0,   244, 27,  1,   0,   0,   0,   245, 249, 5,   11,
      0,   0,   246, 248, 5,   60,  0,   0,   247, 246, 1,   0,   0,   0,   248,
      251, 1,   0,   0,   0,   249, 247, 1,   0,   0,   0,   249, 250, 1,   0,
      0,   0,   250, 252, 1,   0,   0,   0,   251, 249, 1,   0,   0,   0,   252,
      253, 5,   58,  0,   0,   253, 29,  1,   0,   0,   0,   254, 258, 5,   10,
      0,   0,   255, 257, 5,   57,  0,   0,   256, 255, 1,   0,   0,   0,   257,
      260, 1,   0,   0,   0,   258, 256, 1,   0,   0,   0,   258, 259, 1,   0,
      0,   0,   259, 261, 1,   0,   0,   0,   260, 258, 1,   0,   0,   0,   261,
      262, 5,   55,  0,   0,   262, 31,  1,   0,   0,   0,   263, 264, 5,   28,
      0,   0,   264, 265, 3,   126, 63,  0,   265, 269, 5,   32,  0,   0,   266,
      268, 3,   66,  33,  0,   267, 266, 1,   0,   0,   0,   268, 271, 1,   0,
      0,   0,   269, 267, 1,   0,   0,   0,   269, 270, 1,   0,   0,   0,   270,
      33,  1,   0,   0,   0,   271, 269, 1,   0,   0,   0,   272, 274, 3,   36,
      18,  0,   273, 272, 1,   0,   0,   0,   274, 277, 1,   0,   0,   0,   275,
      273, 1,   0,   0,   0,   275, 276, 1,   0,   0,   0,   276, 35,  1,   0,
      0,   0,   277, 275, 1,   0,   0,   0,   278, 281, 3,   38,  19,  0,   279,
      281, 3,   66,  33,  0,   280, 278, 1,   0,   0,   0,   280, 279, 1,   0,
      0,   0,   281, 37,  1,   0,   0,   0,   282, 284, 3,   56,  28,  0,   283,
      282, 1,   0,   0,   0,   283, 284, 1,   0,   0,   0,   284, 285, 1,   0,
      0,   0,   285, 287, 5,   2,   0,   0,   286, 288, 3,   30,  15,  0,   287,
      286, 1,   0,   0,   0,   287, 288, 1,   0,   0,   0,   288, 290, 1,   0,
      0,   0,   289, 291, 3,   48,  24,  0,   290, 289, 1,   0,   0,   0,   290,
      291, 1,   0,   0,   0,   291, 293, 1,   0,   0,   0,   292, 294, 3,   50,
      25,  0,   293, 292, 1,   0,   0,   0,   293, 294, 1,   0,   0,   0,   294,
      296, 1,   0,   0,   0,   295, 297, 3,   52,  26,  0,   296, 295, 1,   0,
      0,   0,   296, 297, 1,   0,   0,   0,   297, 301, 1,   0,   0,   0,   298,
      300, 3,   46,  23,  0,   299, 298, 1,   0,   0,   0,   300, 303, 1,   0,
      0,   0,   301, 299, 1,   0,   0,   0,   301, 302, 1,   0,   0,   0,   302,
      304, 1,   0,   0,   0,   303, 301, 1,   0,   0,   0,   304, 305, 5,   29,
      0,   0,   305, 306, 3,   60,  30,  0,   306, 307, 5,   32,  0,   0,   307,
      308, 3,   40,  20,  0,   308, 39,  1,   0,   0,   0,   309, 311, 3,   42,
      21,  0,   310, 309, 1,   0,   0,   0,   311, 314, 1,   0,   0,   0,   312,
      310, 1,   0,   0,   0,   312, 313, 1,   0,   0,   0,   313, 316, 1,   0,
      0,   0,   314, 312, 1,   0,   0,   0,   315, 317, 3,   44,  22,  0,   316,
      315, 1,   0,   0,   0,   316, 317, 1,   0,   0,   0,   317, 41,  1,   0,
      0,   0,   318, 319, 5,   26,  0,   0,   319, 320, 3,   30,  15,  0,   320,
      321, 3,   28,  14,  0,   321, 43,  1,   0,   0,   0,   322, 323, 5,   27,
      0,   0,   323, 324, 3,   28,  14,  0,   324, 45,  1,   0,   0,   0,   325,
      328, 3,   8,   4,   0,   326, 328, 3,   54,  27,  0,   327, 325, 1,   0,
      0,   0,   327, 326, 1,   0,   0,   0,   328, 47,  1,   0,   0,   0,   329,
      330, 5,   23,  0,   0,   330, 331, 3,   30,  15,  0,   331, 49,  1,   0,
      0,   0,   332, 333, 5,   25,  0,   0,   333, 338, 3,   126, 63,  0,   334,
      335, 5,   31,  0,   0,   335, 337, 3,   126, 63,  0,   336, 334, 1,   0,
      0,   0,   337, 340, 1,   0,   0,   0,   338, 336, 1,   0,   0,   0,   338,
      339, 1,   0,   0,   0,   339, 51,  1,   0,   0,   0,   340, 338, 1,   0,
      0,   0,   341, 342, 5,   24,  0,   0,   342, 343, 3,   30,  15,  0,   343,
      53,  1,   0,   0,   0,   344, 345, 5,   49,  0,   0,   345, 346, 3,   126,
      63,  0,   346, 347, 3,   28,  14,  0,   347, 55,  1,   0,   0,   0,   348,
      350, 3,   58,  29,  0,   349, 348, 1,   0,   0,   0,   350, 351, 1,   0,
      0,   0,   351, 349, 1,   0,   0,   0,   351, 352, 1,   0,   0,   0,   352,
      57,  1,   0,   0,   0,   353, 354, 7,   0,   0,   0,   354, 59,  1,   0,
      0,   0,   355, 356, 3,   62,  31,  0,   356, 61,  1,   0,   0,   0,   357,
      362, 3,   64,  32,  0,   358, 359, 5,   45,  0,   0,   359, 361, 3,   64,
      32,  0,   360, 358, 1,   0,   0,   0,   361, 364, 1,   0,   0,   0,   362,
      360, 1,   0,   0,   0,   362, 363, 1,   0,   0,   0,   363, 63,  1,   0,
      0,   0,   364, 362, 1,   0,   0,   0,   365, 368, 3,   92,  46,  0,   366,
      367, 5,   50,  0,   0,   367, 369, 3,   126, 63,  0,   368, 366, 1,   0,
      0,   0,   368, 369, 1,   0,   0,   0,   369, 65,  1,   0,   0,   0,   370,
      372, 5,   16,  0,   0,   371, 370, 1,   0,   0,   0,   371, 372, 1,   0,
      0,   0,   372, 373, 1,   0,   0,   0,   373, 374, 5,   1,   0,   0,   374,
      375, 5,   29,  0,   0,   375, 376, 3,   68,  34,  0,   376, 377, 5,   32,
      0,   0,   377, 67,  1,   0,   0,   0,   378, 379, 3,   70,  35,  0,   379,
      69,  1,   0,   0,   0,   380, 385, 3,   72,  36,  0,   381, 382, 5,   45,
      0,   0,   382, 384, 3,   72,  36,  0,   383, 381, 1,   0,   0,   0,   384,
      387, 1,   0,   0,   0,   385, 383, 1,   0,   0,   0,   385, 386, 1,   0,
      0,   0,   386, 71,  1,   0,   0,   0,   387, 385, 1,   0,   0,   0,   388,
      390, 3,   74,  37,  0,   389, 391, 3,   82,  41,  0,   390, 389, 1,   0,
      0,   0,   390, 391, 1,   0,   0,   0,   391, 394, 1,   0,   0,   0,   392,
      394, 1,   0,   0,   0,   393, 388, 1,   0,   0,   0,   393, 392, 1,   0,
      0,   0,   394, 73,  1,   0,   0,   0,   395, 397, 3,   76,  38,  0,   396,
      395, 1,   0,   0,   0,   397, 398, 1,   0,   0,   0,   398, 396, 1,   0,
      0,   0,   398, 399, 1,   0,   0,   0,   399, 402, 1,   0,   0,   0,   400,
      402, 1,   0,   0,   0,   401, 396, 1,   0,   0,   0,   401, 400, 1,   0,
      0,   0,   402, 75,  1,   0,   0,   0,   403, 405, 3,   78,  39,  0,   404,
      406, 3,   102, 51,  0,   405, 404, 1,   0,   0,   0,   405, 406, 1,   0,
      0,   0,   406, 420, 1,   0,   0,   0,   407, 409, 3,   104, 52,  0,   408,
      410, 3,   102, 51,  0,   409, 408, 1,   0,   0,   0,   409, 410, 1,   0,
      0,   0,   410, 420, 1,   0,   0,   0,   411, 413, 3,   80,  40,  0,   412,
      414, 3,   102, 51,  0,   413, 412, 1,   0,   0,   0,   413, 414, 1,   0,
      0,   0,   414, 420, 1,   0,   0,   0,   415, 417, 3,   28,  14,  0,   416,
      418, 5,   41,  0,   0,   417, 416, 1,   0,   0,   0,   417, 418, 1,   0,
      0,   0,   418, 420, 1,   0,   0,   0,   419, 403, 1,   0,   0,   0,   419,
      407, 1,   0,   0,   0,   419, 411, 1,   0,   0,   0,   419, 415, 1,   0,
      0,   0,   420, 77,  1,   0,   0,   0,   421, 422, 3,   126, 63,  0,   422,
      425, 7,   1,   0,   0,   423, 426, 3,   104, 52,  0,   424, 426, 3,   80,
      40,  0,   425, 423, 1,   0,   0,   0,   425, 424, 1,   0,   0,   0,   426,
      79,  1,   0,   0,   0,   427, 428, 5,   33,  0,   0,   428, 429, 3,   70,
      35,  0,   429, 430, 5,   34,  0,   0,   430, 81,  1,   0,   0,   0,   431,
      432, 5,   37,  0,   0,   432, 437, 3,   84,  42,  0,   433, 434, 5,   31,
      0,   0,   434, 436, 3,   84,  42,  0,   435, 433, 1,   0,   0,   0,   436,
      439, 1,   0,   0,   0,   437, 435, 1,   0,   0,   0,   437, 438, 1,   0,
      0,   0,   438, 83,  1,   0,   0,   0,   439, 437, 1,   0,   0,   0,   440,
      441, 3,   86,  43,  0,   441, 442, 5,   33,  0,   0,   442, 443, 3,   88,
      44,  0,   443, 444, 5,   34,  0,   0,   444, 447, 1,   0,   0,   0,   445,
      447, 3,   86,  43,  0,   446, 440, 1,   0,   0,   0,   446, 445, 1,   0,
      0,   0,   447, 85,  1,   0,   0,   0,   448, 451, 3,   126, 63,  0,   449,
      451, 5,   28,  0,   0,   450, 448, 1,   0,   0,   0,   450, 449, 1,   0,
      0,   0,   451, 87,  1,   0,   0,   0,   452, 455, 3,   126, 63,  0,   453,
      455, 5,   7,   0,   0,   454, 452, 1,   0,   0,   0,   454, 453, 1,   0,
      0,   0,   455, 89,  1,   0,   0,   0,   456, 461, 3,   92,  46,  0,   457,
      458, 5,   45,  0,   0,   458, 460, 3,   92,  46,  0,   459, 457, 1,   0,
      0,   0,   460, 463, 1,   0,   0,   0,   461, 459, 1,   0,   0,   0,   461,
      462, 1,   0,   0,   0,   462, 91,  1,   0,   0,   0,   463, 461, 1,   0,
      0,   0,   464, 466, 3,   122, 61,  0,   465, 464, 1,   0,   0,   0,   465,
      466, 1,   0,   0,   0,   466, 468, 1,   0,   0,   0,   467, 469, 3,   94,
      47,  0,   468, 467, 1,   0,   0,   0,   469, 470, 1,   0,   0,   0,   470,
      468, 1,   0,   0,   0,   470, 471, 1,   0,   0,   0,   471, 474, 1,   0,
      0,   0,   472, 474, 1,   0,   0,   0,   473, 465, 1,   0,   0,   0,   473,
      472, 1,   0,   0,   0,   474, 93,  1,   0,   0,   0,   475, 478, 3,   96,
      48,  0,   476, 479, 3,   102, 51,  0,   477, 479, 1,   0,   0,   0,   478,
      476, 1,   0,   0,   0,   478, 477, 1,   0,   0,   0,   479, 491, 1,   0,
      0,   0,   480, 483, 3,   106, 53,  0,   481, 484, 3,   102, 51,  0,   482,
      484, 1,   0,   0,   0,   483, 481, 1,   0,   0,   0,   483, 482, 1,   0,
      0,   0,   484, 491, 1,   0,   0,   0,   485, 491, 3,   98,  49,  0,   486,
      488, 3,   28,  14,  0,   487, 489, 5,   41,  0,   0,   488, 487, 1,   0,
      0,   0,   488, 489, 1,   0,   0,   0,   489, 491, 1,   0,   0,   0,   490,
      475, 1,   0,   0,   0,   490, 480, 1,   0,   0,   0,   490, 485, 1,   0,
      0,   0,   490, 486, 1,   0,   0,   0,   491, 95,  1,   0,   0,   0,   492,
      493, 3,   126, 63,  0,   493, 496, 7,   1,   0,   0,   494, 497, 3,   106,
      53,  0,   495, 497, 3,   114, 57,  0,   496, 494, 1,   0,   0,   0,   496,
      495, 1,   0,   0,   0,   497, 97,  1,   0,   0,   0,   498, 500, 3,   114,
      57,  0,   499, 501, 3,   100, 50,  0,   500, 499, 1,   0,   0,   0,   500,
      501, 1,   0,   0,   0,   501, 99,  1,   0,   0,   0,   502, 503, 3,   102,
      51,  0,   503, 101, 1,   0,   0,   0,   504, 506, 5,   41,  0,   0,   505,
      507, 5,   41,  0,   0,   506, 505, 1,   0,   0,   0,   506, 507, 1,   0,
      0,   0,   507, 517, 1,   0,   0,   0,   508, 510, 5,   42,  0,   0,   509,
      511, 5,   41,  0,   0,   510, 509, 1,   0,   0,   0,   510, 511, 1,   0,
      0,   0,   511, 517, 1,   0,   0,   0,   512, 514, 5,   44,  0,   0,   513,
      515, 5,   41,  0,   0,   514, 513, 1,   0,   0,   0,   514, 515, 1,   0,
      0,   0,   515, 517, 1,   0,   0,   0,   516, 504, 1,   0,   0,   0,   516,
      508, 1,   0,   0,   0,   516, 512, 1,   0,   0,   0,   517, 103, 1,   0,
      0,   0,   518, 527, 3,   118, 59,  0,   519, 527, 3,   120, 60,  0,   520,
      527, 3,   108, 54,  0,   521, 527, 5,   3,   0,   0,   522, 524, 5,   48,
      0,   0,   523, 525, 3,   122, 61,  0,   524, 523, 1,   0,   0,   0,   524,
      525, 1,   0,   0,   0,   525, 527, 1,   0,   0,   0,   526, 518, 1,   0,
      0,   0,   526, 519, 1,   0,   0,   0,   526, 520, 1,   0,   0,   0,   526,
      521, 1,   0,   0,   0,   526, 522, 1,   0,   0,   0,   527, 105, 1,   0,
      0,   0,   528, 536, 3,   120, 60,  0,   529, 536, 3,   116, 58,  0,   530,
      536, 3,   108, 54,  0,   531, 533, 5,   48,  0,   0,   532, 534, 3,   122,
      61,  0,   533, 532, 1,   0,   0,   0,   533, 534, 1,   0,   0,   0,   534,
      536, 1,   0,   0,   0,   535, 528, 1,   0,   0,   0,   535, 529, 1,   0,
      0,   0,   535, 530, 1,   0,   0,   0,   535, 531, 1,   0,   0,   0,   536,
      107, 1,   0,   0,   0,   537, 538, 5,   51,  0,   0,   538, 542, 3,   112,
      56,  0,   539, 540, 5,   51,  0,   0,   540, 542, 3,   110, 55,  0,   541,
      537, 1,   0,   0,   0,   541, 539, 1,   0,   0,   0,   542, 109, 1,   0,
      0,   0,   543, 544, 5,   33,  0,   0,   544, 549, 3,   112, 56,  0,   545,
      546, 5,   45,  0,   0,   546, 548, 3,   112, 56,  0,   547, 545, 1,   0,
      0,   0,   548, 551, 1,   0,   0,   0,   549, 547, 1,   0,   0,   0,   549,
      550, 1,   0,   0,   0,   550, 552, 1,   0,   0,   0,   551, 549, 1,   0,
      0,   0,   552, 553, 5,   34,  0,   0,   553, 111, 1,   0,   0,   0,   554,
      556, 5,   1,   0,   0,   555, 557, 3,   122, 61,  0,   556, 555, 1,   0,
      0,   0,   556, 557, 1,   0,   0,   0,   557, 565, 1,   0,   0,   0,   558,
      560, 5,   8,   0,   0,   559, 561, 3,   122, 61,  0,   560, 559, 1,   0,
      0,   0,   560, 561, 1,   0,   0,   0,   561, 565, 1,   0,   0,   0,   562,
      565, 3,   118, 59,  0,   563, 565, 5,   3,   0,   0,   564, 554, 1,   0,
      0,   0,   564, 558, 1,   0,   0,   0,   564, 562, 1,   0,   0,   0,   564,
      563, 1,   0,   0,   0,   565, 113, 1,   0,   0,   0,   566, 577, 5,   33,
      0,   0,   567, 569, 3,   8,   4,   0,   568, 567, 1,   0,   0,   0,   568,
      569, 1,   0,   0,   0,   569, 573, 1,   0,   0,   0,   570, 572, 3,   54,
      27,  0,   571, 570, 1,   0,   0,   0,   572, 575, 1,   0,   0,   0,   573,
      571, 1,   0,   0,   0,   573, 574, 1,   0,   0,   0,   574, 576, 1,   0,
      0,   0,   575, 573, 1,   0,   0,   0,   576, 578, 5,   29,  0,   0,   577,
      568, 1,   0,   0,   0,   577, 578, 1,   0,   0,   0,   578, 579, 1,   0,
      0,   0,   579, 580, 3,   90,  45,  0,   580, 581, 5,   34,  0,   0,   581,
      115, 1,   0,   0,   0,   582, 584, 5,   2,   0,   0,   583, 585, 3,   30,
      15,  0,   584, 583, 1,   0,   0,   0,   584, 585, 1,   0,   0,   0,   585,
      587, 1,   0,   0,   0,   586, 588, 3,   122, 61,  0,   587, 586, 1,   0,
      0,   0,   587, 588, 1,   0,   0,   0,   588, 117, 1,   0,   0,   0,   589,
      590, 5,   8,   0,   0,   590, 591, 5,   47,  0,   0,   591, 592, 5,   8,
      0,   0,   592, 119, 1,   0,   0,   0,   593, 595, 5,   1,   0,   0,   594,
      596, 3,   122, 61,  0,   595, 594, 1,   0,   0,   0,   595, 596, 1,   0,
      0,   0,   596, 602, 1,   0,   0,   0,   597, 599, 5,   8,   0,   0,   598,
      600, 3,   122, 61,  0,   599, 598, 1,   0,   0,   0,   599, 600, 1,   0,
      0,   0,   600, 602, 1,   0,   0,   0,   601, 593, 1,   0,   0,   0,   601,
      597, 1,   0,   0,   0,   602, 121, 1,   0,   0,   0,   603, 604, 5,   38,
      0,   0,   604, 609, 3,   124, 62,  0,   605, 606, 5,   31,  0,   0,   606,
      608, 3,   124, 62,  0,   607, 605, 1,   0,   0,   0,   608, 611, 1,   0,
      0,   0,   609, 607, 1,   0,   0,   0,   609, 610, 1,   0,   0,   0,   610,
      612, 1,   0,   0,   0,   611, 609, 1,   0,   0,   0,   612, 613, 5,   39,
      0,   0,   613, 123, 1,   0,   0,   0,   614, 622, 3,   126, 63,  0,   615,
      616, 3,   126, 63,  0,   616, 619, 5,   40,  0,   0,   617, 620, 3,   126,
      63,  0,   618, 620, 5,   8,   0,   0,   619, 617, 1,   0,   0,   0,   619,
      618, 1,   0,   0,   0,   620, 622, 1,   0,   0,   0,   621, 614, 1,   0,
      0,   0,   621, 615, 1,   0,   0,   0,   622, 125, 1,   0,   0,   0,   623,
      624, 7,   2,   0,   0,   624, 127, 1,   0,   0,   0,   83,  132, 139, 153,
      160, 168, 182, 188, 196, 206, 210, 216, 225, 229, 235, 243, 249, 258, 269,
      275, 280, 283, 287, 290, 293, 296, 301, 312, 316, 327, 338, 351, 362, 368,
      371, 385, 390, 393, 398, 401, 405, 409, 413, 417, 419, 425, 437, 446, 450,
      454, 461, 465, 470, 473, 478, 483, 488, 490, 496, 500, 506, 510, 514, 516,
      524, 526, 533, 535, 541, 549, 556, 560, 564, 568, 573, 577, 584, 587, 595,
      599, 601, 609, 619, 621};
  staticData->serializedATN = antlr4::atn::SerializedATNView(
      serializedATNSegment,
      sizeof(serializedATNSegment) / sizeof(serializedATNSegment[0]));

  antlr4::atn::ATNDeserializer deserializer;
  staticData->atn = deserializer.deserialize(staticData->serializedATN);

  const size_t count = staticData->atn->getNumberOfDecisions();
  staticData->decisionToDFA.reserve(count);
  for (size_t i = 0; i < count; i++) {
    staticData->decisionToDFA.emplace_back(staticData->atn->getDecisionState(i),
                                           i);
  }
  antlrv4parserParserStaticData = staticData.release();
}

}  // namespace

ANTLRv4Parser::ANTLRv4Parser(TokenStream *input)
    : ANTLRv4Parser(input, antlr4::atn::ParserATNSimulatorOptions()) {}

ANTLRv4Parser::ANTLRv4Parser(
    TokenStream *input, const antlr4::atn::ParserATNSimulatorOptions &options)
    : Parser(input) {
  ANTLRv4Parser::initialize();
  _interpreter = new atn::ParserATNSimulator(
      this, *antlrv4parserParserStaticData->atn,
      antlrv4parserParserStaticData->decisionToDFA,
      antlrv4parserParserStaticData->sharedContextCache, options);
}

ANTLRv4Parser::~ANTLRv4Parser() { delete _interpreter; }

const atn::ATN &ANTLRv4Parser::getATN() const {
  return *antlrv4parserParserStaticData->atn;
}

std::string ANTLRv4Parser::getGrammarFileName() const {
  return "ANTLRv4Parser.g4";
}

const std::vector<std::string> &ANTLRv4Parser::getRuleNames() const {
  return antlrv4parserParserStaticData->ruleNames;
}

const dfa::Vocabulary &ANTLRv4Parser::getVocabulary() const {
  return antlrv4parserParserStaticData->vocabulary;
}

antlr4::atn::SerializedATNView ANTLRv4Parser::getSerializedATN() const {
  return antlrv4parserParserStaticData->serializedATN;
}

//----------------- GrammarSpecContext
//------------------------------------------------------------------

ANTLRv4Parser::GrammarSpecContext::GrammarSpecContext(ParserRuleContext *parent,
                                                      size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

ANTLRv4Parser::GrammarDeclContext *
ANTLRv4Parser::GrammarSpecContext::grammarDecl() {
  return getRuleContext<ANTLRv4Parser::GrammarDeclContext>(0);
}

ANTLRv4Parser::RulesContext *ANTLRv4Parser::GrammarSpecContext::rules() {
  return getRuleContext<ANTLRv4Parser::RulesContext>(0);
}

tree::TerminalNode *ANTLRv4Parser::GrammarSpecContext::EOF() {
  return getToken(ANTLRv4Parser::EOF, 0);
}

std::vector<ANTLRv4Parser::PrequelConstructContext *>
ANTLRv4Parser::GrammarSpecContext::prequelConstruct() {
  return getRuleContexts<ANTLRv4Parser::PrequelConstructContext>();
}

ANTLRv4Parser::PrequelConstructContext *
ANTLRv4Parser::GrammarSpecContext::prequelConstruct(size_t i) {
  return getRuleContext<ANTLRv4Parser::PrequelConstructContext>(i);
}

std::vector<ANTLRv4Parser::ModeSpecContext *>
ANTLRv4Parser::GrammarSpecContext::modeSpec() {
  return getRuleContexts<ANTLRv4Parser::ModeSpecContext>();
}

ANTLRv4Parser::ModeSpecContext *ANTLRv4Parser::GrammarSpecContext::modeSpec(
    size_t i) {
  return getRuleContext<ANTLRv4Parser::ModeSpecContext>(i);
}

size_t ANTLRv4Parser::GrammarSpecContext::getRuleIndex() const {
  return ANTLRv4Parser::RuleGrammarSpec;
}

void ANTLRv4Parser::GrammarSpecContext::enterRule(
    tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ANTLRv4ParserListener *>(listener);
  if (parserListener != nullptr) parserListener->enterGrammarSpec(this);
}

void ANTLRv4Parser::GrammarSpecContext::exitRule(
    tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ANTLRv4ParserListener *>(listener);
  if (parserListener != nullptr) parserListener->exitGrammarSpec(this);
}

ANTLRv4Parser::GrammarSpecContext *ANTLRv4Parser::grammarSpec() {
  GrammarSpecContext *_localctx =
      _tracker.createInstance<GrammarSpecContext>(_ctx, getState());
  enterRule(_localctx, 0, ANTLRv4Parser::RuleGrammarSpec);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(128);
    grammarDecl();
    setState(132);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (
        (((_la & ~0x3fULL) == 0) && ((1ULL << _la) & 562949953482752) != 0)) {
      setState(129);
      prequelConstruct();
      setState(134);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(135);
    rules();
    setState(139);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == ANTLRv4Parser::MODE) {
      setState(136);
      modeSpec();
      setState(141);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(142);
    match(ANTLRv4Parser::EOF);

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GrammarDeclContext
//------------------------------------------------------------------

ANTLRv4Parser::GrammarDeclContext::GrammarDeclContext(ParserRuleContext *parent,
                                                      size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

ANTLRv4Parser::GrammarTypeContext *
ANTLRv4Parser::GrammarDeclContext::grammarType() {
  return getRuleContext<ANTLRv4Parser::GrammarTypeContext>(0);
}

ANTLRv4Parser::IdentifierContext *
ANTLRv4Parser::GrammarDeclContext::identifier() {
  return getRuleContext<ANTLRv4Parser::IdentifierContext>(0);
}

tree::TerminalNode *ANTLRv4Parser::GrammarDeclContext::SEMI() {
  return getToken(ANTLRv4Parser::SEMI, 0);
}

size_t ANTLRv4Parser::GrammarDeclContext::getRuleIndex() const {
  return ANTLRv4Parser::RuleGrammarDecl;
}

void ANTLRv4Parser::GrammarDeclContext::enterRule(
    tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ANTLRv4ParserListener *>(listener);
  if (parserListener != nullptr) parserListener->enterGrammarDecl(this);
}

void ANTLRv4Parser::GrammarDeclContext::exitRule(
    tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ANTLRv4ParserListener *>(listener);
  if (parserListener != nullptr) parserListener->exitGrammarDecl(this);
}

ANTLRv4Parser::GrammarDeclContext *ANTLRv4Parser::grammarDecl() {
  GrammarDeclContext *_localctx =
      _tracker.createInstance<GrammarDeclContext>(_ctx, getState());
  enterRule(_localctx, 2, ANTLRv4Parser::RuleGrammarDecl);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(144);
    grammarType();
    setState(145);
    identifier();
    setState(146);
    match(ANTLRv4Parser::SEMI);

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GrammarTypeContext
//------------------------------------------------------------------

ANTLRv4Parser::GrammarTypeContext::GrammarTypeContext(ParserRuleContext *parent,
                                                      size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

tree::TerminalNode *ANTLRv4Parser::GrammarTypeContext::LEXER() {
  return getToken(ANTLRv4Parser::LEXER, 0);
}

tree::TerminalNode *ANTLRv4Parser::GrammarTypeContext::GRAMMAR() {
  return getToken(ANTLRv4Parser::GRAMMAR, 0);
}

tree::TerminalNode *ANTLRv4Parser::GrammarTypeContext::PARSER() {
  return getToken(ANTLRv4Parser::PARSER, 0);
}

size_t ANTLRv4Parser::GrammarTypeContext::getRuleIndex() const {
  return ANTLRv4Parser::RuleGrammarType;
}

void ANTLRv4Parser::GrammarTypeContext::enterRule(
    tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ANTLRv4ParserListener *>(listener);
  if (parserListener != nullptr) parserListener->enterGrammarType(this);
}

void ANTLRv4Parser::GrammarTypeContext::exitRule(
    tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ANTLRv4ParserListener *>(listener);
  if (parserListener != nullptr) parserListener->exitGrammarType(this);
}

ANTLRv4Parser::GrammarTypeContext *ANTLRv4Parser::grammarType() {
  GrammarTypeContext *_localctx =
      _tracker.createInstance<GrammarTypeContext>(_ctx, getState());
  enterRule(_localctx, 4, ANTLRv4Parser::RuleGrammarType);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(153);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case ANTLRv4Parser::LEXER: {
        setState(148);
        match(ANTLRv4Parser::LEXER);
        setState(149);
        match(ANTLRv4Parser::GRAMMAR);
        break;
      }

      case ANTLRv4Parser::PARSER: {
        setState(150);
        match(ANTLRv4Parser::PARSER);
        setState(151);
        match(ANTLRv4Parser::GRAMMAR);
        break;
      }

      case ANTLRv4Parser::GRAMMAR: {
        setState(152);
        match(ANTLRv4Parser::GRAMMAR);
        break;
      }

      default:
        throw NoViableAltException(this);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PrequelConstructContext
//------------------------------------------------------------------

ANTLRv4Parser::PrequelConstructContext::PrequelConstructContext(
    ParserRuleContext *parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

ANTLRv4Parser::OptionsSpecContext *
ANTLRv4Parser::PrequelConstructContext::optionsSpec() {
  return getRuleContext<ANTLRv4Parser::OptionsSpecContext>(0);
}

ANTLRv4Parser::DelegateGrammarsContext *
ANTLRv4Parser::PrequelConstructContext::delegateGrammars() {
  return getRuleContext<ANTLRv4Parser::DelegateGrammarsContext>(0);
}

ANTLRv4Parser::TokensSpecContext *
ANTLRv4Parser::PrequelConstructContext::tokensSpec() {
  return getRuleContext<ANTLRv4Parser::TokensSpecContext>(0);
}

ANTLRv4Parser::ChannelsSpecContext *
ANTLRv4Parser::PrequelConstructContext::channelsSpec() {
  return getRuleContext<ANTLRv4Parser::ChannelsSpecContext>(0);
}

ANTLRv4Parser::Action_Context *
ANTLRv4Parser::PrequelConstructContext::action_() {
  return getRuleContext<ANTLRv4Parser::Action_Context>(0);
}

size_t ANTLRv4Parser::PrequelConstructContext::getRuleIndex() const {
  return ANTLRv4Parser::RulePrequelConstruct;
}

void ANTLRv4Parser::PrequelConstructContext::enterRule(
    tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ANTLRv4ParserListener *>(listener);
  if (parserListener != nullptr) parserListener->enterPrequelConstruct(this);
}

void ANTLRv4Parser::PrequelConstructContext::exitRule(
    tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ANTLRv4ParserListener *>(listener);
  if (parserListener != nullptr) parserListener->exitPrequelConstruct(this);
}

ANTLRv4Parser::PrequelConstructContext *ANTLRv4Parser::prequelConstruct() {
  PrequelConstructContext *_localctx =
      _tracker.createInstance<PrequelConstructContext>(_ctx, getState());
  enterRule(_localctx, 6, ANTLRv4Parser::RulePrequelConstruct);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(160);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case ANTLRv4Parser::OPTIONS: {
        enterOuterAlt(_localctx, 1);
        setState(155);
        optionsSpec();
        break;
      }

      case ANTLRv4Parser::IMPORT: {
        enterOuterAlt(_localctx, 2);
        setState(156);
        delegateGrammars();
        break;
      }

      case ANTLRv4Parser::TOKENS: {
        enterOuterAlt(_localctx, 3);
        setState(157);
        tokensSpec();
        break;
      }

      case ANTLRv4Parser::CHANNELS: {
        enterOuterAlt(_localctx, 4);
        setState(158);
        channelsSpec();
        break;
      }

      case ANTLRv4Parser::AT: {
        enterOuterAlt(_localctx, 5);
        setState(159);
        action_();
        break;
      }

      default:
        throw NoViableAltException(this);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OptionsSpecContext
//------------------------------------------------------------------

ANTLRv4Parser::OptionsSpecContext::OptionsSpecContext(ParserRuleContext *parent,
                                                      size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

tree::TerminalNode *ANTLRv4Parser::OptionsSpecContext::OPTIONS() {
  return getToken(ANTLRv4Parser::OPTIONS, 0);
}

tree::TerminalNode *ANTLRv4Parser::OptionsSpecContext::RBRACE() {
  return getToken(ANTLRv4Parser::RBRACE, 0);
}

std::vector<ANTLRv4Parser::OptionContext *>
ANTLRv4Parser::OptionsSpecContext::option() {
  return getRuleContexts<ANTLRv4Parser::OptionContext>();
}

ANTLRv4Parser::OptionContext *ANTLRv4Parser::OptionsSpecContext::option(
    size_t i) {
  return getRuleContext<ANTLRv4Parser::OptionContext>(i);
}

std::vector<tree::TerminalNode *> ANTLRv4Parser::OptionsSpecContext::SEMI() {
  return getTokens(ANTLRv4Parser::SEMI);
}

tree::TerminalNode *ANTLRv4Parser::OptionsSpecContext::SEMI(size_t i) {
  return getToken(ANTLRv4Parser::SEMI, i);
}

size_t ANTLRv4Parser::OptionsSpecContext::getRuleIndex() const {
  return ANTLRv4Parser::RuleOptionsSpec;
}

void ANTLRv4Parser::OptionsSpecContext::enterRule(
    tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ANTLRv4ParserListener *>(listener);
  if (parserListener != nullptr) parserListener->enterOptionsSpec(this);
}

void ANTLRv4Parser::OptionsSpecContext::exitRule(
    tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ANTLRv4ParserListener *>(listener);
  if (parserListener != nullptr) parserListener->exitOptionsSpec(this);
}

ANTLRv4Parser::OptionsSpecContext *ANTLRv4Parser::optionsSpec() {
  OptionsSpecContext *_localctx =
      _tracker.createInstance<OptionsSpecContext>(_ctx, getState());
  enterRule(_localctx, 8, ANTLRv4Parser::RuleOptionsSpec);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(162);
    match(ANTLRv4Parser::OPTIONS);
    setState(168);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == ANTLRv4Parser::TOKEN_REF

           || _la == ANTLRv4Parser::RULE_REF) {
      setState(163);
      option();
      setState(164);
      match(ANTLRv4Parser::SEMI);
      setState(170);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(171);
    match(ANTLRv4Parser::RBRACE);

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OptionContext
//------------------------------------------------------------------

ANTLRv4Parser::OptionContext::OptionContext(ParserRuleContext *parent,
                                            size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

ANTLRv4Parser::IdentifierContext *ANTLRv4Parser::OptionContext::identifier() {
  return getRuleContext<ANTLRv4Parser::IdentifierContext>(0);
}

tree::TerminalNode *ANTLRv4Parser::OptionContext::ASSIGN() {
  return getToken(ANTLRv4Parser::ASSIGN, 0);
}

ANTLRv4Parser::OptionValueContext *ANTLRv4Parser::OptionContext::optionValue() {
  return getRuleContext<ANTLRv4Parser::OptionValueContext>(0);
}

size_t ANTLRv4Parser::OptionContext::getRuleIndex() const {
  return ANTLRv4Parser::RuleOption;
}

void ANTLRv4Parser::OptionContext::enterRule(
    tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ANTLRv4ParserListener *>(listener);
  if (parserListener != nullptr) parserListener->enterOption(this);
}

void ANTLRv4Parser::OptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ANTLRv4ParserListener *>(listener);
  if (parserListener != nullptr) parserListener->exitOption(this);
}

ANTLRv4Parser::OptionContext *ANTLRv4Parser::option() {
  OptionContext *_localctx =
      _tracker.createInstance<OptionContext>(_ctx, getState());
  enterRule(_localctx, 10, ANTLRv4Parser::RuleOption);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(173);
    identifier();
    setState(174);
    match(ANTLRv4Parser::ASSIGN);
    setState(175);
    optionValue();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OptionValueContext
//------------------------------------------------------------------

ANTLRv4Parser::OptionValueContext::OptionValueContext(ParserRuleContext *parent,
                                                      size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

std::vector<ANTLRv4Parser::IdentifierContext *>
ANTLRv4Parser::OptionValueContext::identifier() {
  return getRuleContexts<ANTLRv4Parser::IdentifierContext>();
}

ANTLRv4Parser::IdentifierContext *ANTLRv4Parser::OptionValueContext::identifier(
    size_t i) {
  return getRuleContext<ANTLRv4Parser::IdentifierContext>(i);
}

std::vector<tree::TerminalNode *> ANTLRv4Parser::OptionValueContext::DOT() {
  return getTokens(ANTLRv4Parser::DOT);
}

tree::TerminalNode *ANTLRv4Parser::OptionValueContext::DOT(size_t i) {
  return getToken(ANTLRv4Parser::DOT, i);
}

tree::TerminalNode *ANTLRv4Parser::OptionValueContext::STRING_LITERAL() {
  return getToken(ANTLRv4Parser::STRING_LITERAL, 0);
}

ANTLRv4Parser::ActionBlockContext *
ANTLRv4Parser::OptionValueContext::actionBlock() {
  return getRuleContext<ANTLRv4Parser::ActionBlockContext>(0);
}

tree::TerminalNode *ANTLRv4Parser::OptionValueContext::INT() {
  return getToken(ANTLRv4Parser::INT, 0);
}

size_t ANTLRv4Parser::OptionValueContext::getRuleIndex() const {
  return ANTLRv4Parser::RuleOptionValue;
}

void ANTLRv4Parser::OptionValueContext::enterRule(
    tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ANTLRv4ParserListener *>(listener);
  if (parserListener != nullptr) parserListener->enterOptionValue(this);
}

void ANTLRv4Parser::OptionValueContext::exitRule(
    tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ANTLRv4ParserListener *>(listener);
  if (parserListener != nullptr) parserListener->exitOptionValue(this);
}

ANTLRv4Parser::OptionValueContext *ANTLRv4Parser::optionValue() {
  OptionValueContext *_localctx =
      _tracker.createInstance<OptionValueContext>(_ctx, getState());
  enterRule(_localctx, 12, ANTLRv4Parser::RuleOptionValue);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(188);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case ANTLRv4Parser::TOKEN_REF:
      case ANTLRv4Parser::RULE_REF: {
        enterOuterAlt(_localctx, 1);
        setState(177);
        identifier();
        setState(182);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == ANTLRv4Parser::DOT) {
          setState(178);
          match(ANTLRv4Parser::DOT);
          setState(179);
          identifier();
          setState(184);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        break;
      }

      case ANTLRv4Parser::STRING_LITERAL: {
        enterOuterAlt(_localctx, 2);
        setState(185);
        match(ANTLRv4Parser::STRING_LITERAL);
        break;
      }

      case ANTLRv4Parser::BEGIN_ACTION: {
        enterOuterAlt(_localctx, 3);
        setState(186);
        actionBlock();
        break;
      }

      case ANTLRv4Parser::INT: {
        enterOuterAlt(_localctx, 4);
        setState(187);
        match(ANTLRv4Parser::INT);
        break;
      }

      default:
        throw NoViableAltException(this);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DelegateGrammarsContext
//------------------------------------------------------------------

ANTLRv4Parser::DelegateGrammarsContext::DelegateGrammarsContext(
    ParserRuleContext *parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

tree::TerminalNode *ANTLRv4Parser::DelegateGrammarsContext::IMPORT() {
  return getToken(ANTLRv4Parser::IMPORT, 0);
}

std::vector<ANTLRv4Parser::DelegateGrammarContext *>
ANTLRv4Parser::DelegateGrammarsContext::delegateGrammar() {
  return getRuleContexts<ANTLRv4Parser::DelegateGrammarContext>();
}

ANTLRv4Parser::DelegateGrammarContext *
ANTLRv4Parser::DelegateGrammarsContext::delegateGrammar(size_t i) {
  return getRuleContext<ANTLRv4Parser::DelegateGrammarContext>(i);
}

tree::TerminalNode *ANTLRv4Parser::DelegateGrammarsContext::SEMI() {
  return getToken(ANTLRv4Parser::SEMI, 0);
}

std::vector<tree::TerminalNode *>
ANTLRv4Parser::DelegateGrammarsContext::COMMA() {
  return getTokens(ANTLRv4Parser::COMMA);
}

tree::TerminalNode *ANTLRv4Parser::DelegateGrammarsContext::COMMA(size_t i) {
  return getToken(ANTLRv4Parser::COMMA, i);
}

size_t ANTLRv4Parser::DelegateGrammarsContext::getRuleIndex() const {
  return ANTLRv4Parser::RuleDelegateGrammars;
}

void ANTLRv4Parser::DelegateGrammarsContext::enterRule(
    tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ANTLRv4ParserListener *>(listener);
  if (parserListener != nullptr) parserListener->enterDelegateGrammars(this);
}

void ANTLRv4Parser::DelegateGrammarsContext::exitRule(
    tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ANTLRv4ParserListener *>(listener);
  if (parserListener != nullptr) parserListener->exitDelegateGrammars(this);
}

ANTLRv4Parser::DelegateGrammarsContext *ANTLRv4Parser::delegateGrammars() {
  DelegateGrammarsContext *_localctx =
      _tracker.createInstance<DelegateGrammarsContext>(_ctx, getState());
  enterRule(_localctx, 14, ANTLRv4Parser::RuleDelegateGrammars);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(190);
    match(ANTLRv4Parser::IMPORT);
    setState(191);
    delegateGrammar();
    setState(196);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == ANTLRv4Parser::COMMA) {
      setState(192);
      match(ANTLRv4Parser::COMMA);
      setState(193);
      delegateGrammar();
      setState(198);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(199);
    match(ANTLRv4Parser::SEMI);

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DelegateGrammarContext
//------------------------------------------------------------------

ANTLRv4Parser::DelegateGrammarContext::DelegateGrammarContext(
    ParserRuleContext *parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

std::vector<ANTLRv4Parser::IdentifierContext *>
ANTLRv4Parser::DelegateGrammarContext::identifier() {
  return getRuleContexts<ANTLRv4Parser::IdentifierContext>();
}

ANTLRv4Parser::IdentifierContext *
ANTLRv4Parser::DelegateGrammarContext::identifier(size_t i) {
  return getRuleContext<ANTLRv4Parser::IdentifierContext>(i);
}

tree::TerminalNode *ANTLRv4Parser::DelegateGrammarContext::ASSIGN() {
  return getToken(ANTLRv4Parser::ASSIGN, 0);
}

size_t ANTLRv4Parser::DelegateGrammarContext::getRuleIndex() const {
  return ANTLRv4Parser::RuleDelegateGrammar;
}

void ANTLRv4Parser::DelegateGrammarContext::enterRule(
    tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ANTLRv4ParserListener *>(listener);
  if (parserListener != nullptr) parserListener->enterDelegateGrammar(this);
}

void ANTLRv4Parser::DelegateGrammarContext::exitRule(
    tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ANTLRv4ParserListener *>(listener);
  if (parserListener != nullptr) parserListener->exitDelegateGrammar(this);
}

ANTLRv4Parser::DelegateGrammarContext *ANTLRv4Parser::delegateGrammar() {
  DelegateGrammarContext *_localctx =
      _tracker.createInstance<DelegateGrammarContext>(_ctx, getState());
  enterRule(_localctx, 16, ANTLRv4Parser::RuleDelegateGrammar);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(206);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(
        _input, 8, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(201);
        identifier();
        setState(202);
        match(ANTLRv4Parser::ASSIGN);
        setState(203);
        identifier();
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(205);
        identifier();
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TokensSpecContext
//------------------------------------------------------------------

ANTLRv4Parser::TokensSpecContext::TokensSpecContext(ParserRuleContext *parent,
                                                    size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

tree::TerminalNode *ANTLRv4Parser::TokensSpecContext::TOKENS() {
  return getToken(ANTLRv4Parser::TOKENS, 0);
}

tree::TerminalNode *ANTLRv4Parser::TokensSpecContext::RBRACE() {
  return getToken(ANTLRv4Parser::RBRACE, 0);
}

ANTLRv4Parser::IdListContext *ANTLRv4Parser::TokensSpecContext::idList() {
  return getRuleContext<ANTLRv4Parser::IdListContext>(0);
}

size_t ANTLRv4Parser::TokensSpecContext::getRuleIndex() const {
  return ANTLRv4Parser::RuleTokensSpec;
}

void ANTLRv4Parser::TokensSpecContext::enterRule(
    tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ANTLRv4ParserListener *>(listener);
  if (parserListener != nullptr) parserListener->enterTokensSpec(this);
}

void ANTLRv4Parser::TokensSpecContext::exitRule(
    tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ANTLRv4ParserListener *>(listener);
  if (parserListener != nullptr) parserListener->exitTokensSpec(this);
}

ANTLRv4Parser::TokensSpecContext *ANTLRv4Parser::tokensSpec() {
  TokensSpecContext *_localctx =
      _tracker.createInstance<TokensSpecContext>(_ctx, getState());
  enterRule(_localctx, 18, ANTLRv4Parser::RuleTokensSpec);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(208);
    match(ANTLRv4Parser::TOKENS);
    setState(210);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ANTLRv4Parser::TOKEN_REF

        || _la == ANTLRv4Parser::RULE_REF) {
      setState(209);
      idList();
    }
    setState(212);
    match(ANTLRv4Parser::RBRACE);

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ChannelsSpecContext
//------------------------------------------------------------------

ANTLRv4Parser::ChannelsSpecContext::ChannelsSpecContext(
    ParserRuleContext *parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

tree::TerminalNode *ANTLRv4Parser::ChannelsSpecContext::CHANNELS() {
  return getToken(ANTLRv4Parser::CHANNELS, 0);
}

tree::TerminalNode *ANTLRv4Parser::ChannelsSpecContext::RBRACE() {
  return getToken(ANTLRv4Parser::RBRACE, 0);
}

ANTLRv4Parser::IdListContext *ANTLRv4Parser::ChannelsSpecContext::idList() {
  return getRuleContext<ANTLRv4Parser::IdListContext>(0);
}

size_t ANTLRv4Parser::ChannelsSpecContext::getRuleIndex() const {
  return ANTLRv4Parser::RuleChannelsSpec;
}

void ANTLRv4Parser::ChannelsSpecContext::enterRule(
    tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ANTLRv4ParserListener *>(listener);
  if (parserListener != nullptr) parserListener->enterChannelsSpec(this);
}

void ANTLRv4Parser::ChannelsSpecContext::exitRule(
    tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ANTLRv4ParserListener *>(listener);
  if (parserListener != nullptr) parserListener->exitChannelsSpec(this);
}

ANTLRv4Parser::ChannelsSpecContext *ANTLRv4Parser::channelsSpec() {
  ChannelsSpecContext *_localctx =
      _tracker.createInstance<ChannelsSpecContext>(_ctx, getState());
  enterRule(_localctx, 20, ANTLRv4Parser::RuleChannelsSpec);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(214);
    match(ANTLRv4Parser::CHANNELS);
    setState(216);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ANTLRv4Parser::TOKEN_REF

        || _la == ANTLRv4Parser::RULE_REF) {
      setState(215);
      idList();
    }
    setState(218);
    match(ANTLRv4Parser::RBRACE);

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IdListContext
//------------------------------------------------------------------

ANTLRv4Parser::IdListContext::IdListContext(ParserRuleContext *parent,
                                            size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

std::vector<ANTLRv4Parser::IdentifierContext *>
ANTLRv4Parser::IdListContext::identifier() {
  return getRuleContexts<ANTLRv4Parser::IdentifierContext>();
}

ANTLRv4Parser::IdentifierContext *ANTLRv4Parser::IdListContext::identifier(
    size_t i) {
  return getRuleContext<ANTLRv4Parser::IdentifierContext>(i);
}

std::vector<tree::TerminalNode *> ANTLRv4Parser::IdListContext::COMMA() {
  return getTokens(ANTLRv4Parser::COMMA);
}

tree::TerminalNode *ANTLRv4Parser::IdListContext::COMMA(size_t i) {
  return getToken(ANTLRv4Parser::COMMA, i);
}

size_t ANTLRv4Parser::IdListContext::getRuleIndex() const {
  return ANTLRv4Parser::RuleIdList;
}

void ANTLRv4Parser::IdListContext::enterRule(
    tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ANTLRv4ParserListener *>(listener);
  if (parserListener != nullptr) parserListener->enterIdList(this);
}

void ANTLRv4Parser::IdListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ANTLRv4ParserListener *>(listener);
  if (parserListener != nullptr) parserListener->exitIdList(this);
}

ANTLRv4Parser::IdListContext *ANTLRv4Parser::idList() {
  IdListContext *_localctx =
      _tracker.createInstance<IdListContext>(_ctx, getState());
  enterRule(_localctx, 22, ANTLRv4Parser::RuleIdList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(220);
    identifier();
    setState(225);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 11,
                                                                     _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(221);
        match(ANTLRv4Parser::COMMA);
        setState(222);
        identifier();
      }
      setState(227);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(
          _input, 11, _ctx);
    }
    setState(229);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ANTLRv4Parser::COMMA) {
      setState(228);
      match(ANTLRv4Parser::COMMA);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Action_Context
//------------------------------------------------------------------

ANTLRv4Parser::Action_Context::Action_Context(ParserRuleContext *parent,
                                              size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

tree::TerminalNode *ANTLRv4Parser::Action_Context::AT() {
  return getToken(ANTLRv4Parser::AT, 0);
}

ANTLRv4Parser::IdentifierContext *ANTLRv4Parser::Action_Context::identifier() {
  return getRuleContext<ANTLRv4Parser::IdentifierContext>(0);
}

ANTLRv4Parser::ActionBlockContext *
ANTLRv4Parser::Action_Context::actionBlock() {
  return getRuleContext<ANTLRv4Parser::ActionBlockContext>(0);
}

ANTLRv4Parser::ActionScopeNameContext *
ANTLRv4Parser::Action_Context::actionScopeName() {
  return getRuleContext<ANTLRv4Parser::ActionScopeNameContext>(0);
}

tree::TerminalNode *ANTLRv4Parser::Action_Context::COLONCOLON() {
  return getToken(ANTLRv4Parser::COLONCOLON, 0);
}

size_t ANTLRv4Parser::Action_Context::getRuleIndex() const {
  return ANTLRv4Parser::RuleAction_;
}

void ANTLRv4Parser::Action_Context::enterRule(
    tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ANTLRv4ParserListener *>(listener);
  if (parserListener != nullptr) parserListener->enterAction_(this);
}

void ANTLRv4Parser::Action_Context::exitRule(
    tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ANTLRv4ParserListener *>(listener);
  if (parserListener != nullptr) parserListener->exitAction_(this);
}

ANTLRv4Parser::Action_Context *ANTLRv4Parser::action_() {
  Action_Context *_localctx =
      _tracker.createInstance<Action_Context>(_ctx, getState());
  enterRule(_localctx, 24, ANTLRv4Parser::RuleAction_);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(231);
    match(ANTLRv4Parser::AT);
    setState(235);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(
        _input, 13, _ctx)) {
      case 1: {
        setState(232);
        actionScopeName();
        setState(233);
        match(ANTLRv4Parser::COLONCOLON);
        break;
      }

      default:
        break;
    }
    setState(237);
    identifier();
    setState(238);
    actionBlock();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ActionScopeNameContext
//------------------------------------------------------------------

ANTLRv4Parser::ActionScopeNameContext::ActionScopeNameContext(
    ParserRuleContext *parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

ANTLRv4Parser::IdentifierContext *
ANTLRv4Parser::ActionScopeNameContext::identifier() {
  return getRuleContext<ANTLRv4Parser::IdentifierContext>(0);
}

tree::TerminalNode *ANTLRv4Parser::ActionScopeNameContext::LEXER() {
  return getToken(ANTLRv4Parser::LEXER, 0);
}

tree::TerminalNode *ANTLRv4Parser::ActionScopeNameContext::PARSER() {
  return getToken(ANTLRv4Parser::PARSER, 0);
}

size_t ANTLRv4Parser::ActionScopeNameContext::getRuleIndex() const {
  return ANTLRv4Parser::RuleActionScopeName;
}

void ANTLRv4Parser::ActionScopeNameContext::enterRule(
    tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ANTLRv4ParserListener *>(listener);
  if (parserListener != nullptr) parserListener->enterActionScopeName(this);
}

void ANTLRv4Parser::ActionScopeNameContext::exitRule(
    tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ANTLRv4ParserListener *>(listener);
  if (parserListener != nullptr) parserListener->exitActionScopeName(this);
}

ANTLRv4Parser::ActionScopeNameContext *ANTLRv4Parser::actionScopeName() {
  ActionScopeNameContext *_localctx =
      _tracker.createInstance<ActionScopeNameContext>(_ctx, getState());
  enterRule(_localctx, 26, ANTLRv4Parser::RuleActionScopeName);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(243);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case ANTLRv4Parser::TOKEN_REF:
      case ANTLRv4Parser::RULE_REF: {
        enterOuterAlt(_localctx, 1);
        setState(240);
        identifier();
        break;
      }

      case ANTLRv4Parser::LEXER: {
        enterOuterAlt(_localctx, 2);
        setState(241);
        match(ANTLRv4Parser::LEXER);
        break;
      }

      case ANTLRv4Parser::PARSER: {
        enterOuterAlt(_localctx, 3);
        setState(242);
        match(ANTLRv4Parser::PARSER);
        break;
      }

      default:
        throw NoViableAltException(this);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ActionBlockContext
//------------------------------------------------------------------

ANTLRv4Parser::ActionBlockContext::ActionBlockContext(ParserRuleContext *parent,
                                                      size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

tree::TerminalNode *ANTLRv4Parser::ActionBlockContext::BEGIN_ACTION() {
  return getToken(ANTLRv4Parser::BEGIN_ACTION, 0);
}

tree::TerminalNode *ANTLRv4Parser::ActionBlockContext::END_ACTION() {
  return getToken(ANTLRv4Parser::END_ACTION, 0);
}

std::vector<tree::TerminalNode *>
ANTLRv4Parser::ActionBlockContext::ACTION_CONTENT() {
  return getTokens(ANTLRv4Parser::ACTION_CONTENT);
}

tree::TerminalNode *ANTLRv4Parser::ActionBlockContext::ACTION_CONTENT(
    size_t i) {
  return getToken(ANTLRv4Parser::ACTION_CONTENT, i);
}

size_t ANTLRv4Parser::ActionBlockContext::getRuleIndex() const {
  return ANTLRv4Parser::RuleActionBlock;
}

void ANTLRv4Parser::ActionBlockContext::enterRule(
    tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ANTLRv4ParserListener *>(listener);
  if (parserListener != nullptr) parserListener->enterActionBlock(this);
}

void ANTLRv4Parser::ActionBlockContext::exitRule(
    tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ANTLRv4ParserListener *>(listener);
  if (parserListener != nullptr) parserListener->exitActionBlock(this);
}

ANTLRv4Parser::ActionBlockContext *ANTLRv4Parser::actionBlock() {
  ActionBlockContext *_localctx =
      _tracker.createInstance<ActionBlockContext>(_ctx, getState());
  enterRule(_localctx, 28, ANTLRv4Parser::RuleActionBlock);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(245);
    match(ANTLRv4Parser::BEGIN_ACTION);
    setState(249);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == ANTLRv4Parser::ACTION_CONTENT) {
      setState(246);
      match(ANTLRv4Parser::ACTION_CONTENT);
      setState(251);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(252);
    match(ANTLRv4Parser::END_ACTION);

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ArgActionBlockContext
//------------------------------------------------------------------

ANTLRv4Parser::ArgActionBlockContext::ArgActionBlockContext(
    ParserRuleContext *parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

tree::TerminalNode *ANTLRv4Parser::ArgActionBlockContext::BEGIN_ARGUMENT() {
  return getToken(ANTLRv4Parser::BEGIN_ARGUMENT, 0);
}

tree::TerminalNode *ANTLRv4Parser::ArgActionBlockContext::END_ARGUMENT() {
  return getToken(ANTLRv4Parser::END_ARGUMENT, 0);
}

std::vector<tree::TerminalNode *>
ANTLRv4Parser::ArgActionBlockContext::ARGUMENT_CONTENT() {
  return getTokens(ANTLRv4Parser::ARGUMENT_CONTENT);
}

tree::TerminalNode *ANTLRv4Parser::ArgActionBlockContext::ARGUMENT_CONTENT(
    size_t i) {
  return getToken(ANTLRv4Parser::ARGUMENT_CONTENT, i);
}

size_t ANTLRv4Parser::ArgActionBlockContext::getRuleIndex() const {
  return ANTLRv4Parser::RuleArgActionBlock;
}

void ANTLRv4Parser::ArgActionBlockContext::enterRule(
    tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ANTLRv4ParserListener *>(listener);
  if (parserListener != nullptr) parserListener->enterArgActionBlock(this);
}

void ANTLRv4Parser::ArgActionBlockContext::exitRule(
    tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ANTLRv4ParserListener *>(listener);
  if (parserListener != nullptr) parserListener->exitArgActionBlock(this);
}

ANTLRv4Parser::ArgActionBlockContext *ANTLRv4Parser::argActionBlock() {
  ArgActionBlockContext *_localctx =
      _tracker.createInstance<ArgActionBlockContext>(_ctx, getState());
  enterRule(_localctx, 30, ANTLRv4Parser::RuleArgActionBlock);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(254);
    match(ANTLRv4Parser::BEGIN_ARGUMENT);
    setState(258);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == ANTLRv4Parser::ARGUMENT_CONTENT) {
      setState(255);
      match(ANTLRv4Parser::ARGUMENT_CONTENT);
      setState(260);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(261);
    match(ANTLRv4Parser::END_ARGUMENT);

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ModeSpecContext
//------------------------------------------------------------------

ANTLRv4Parser::ModeSpecContext::ModeSpecContext(ParserRuleContext *parent,
                                                size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

tree::TerminalNode *ANTLRv4Parser::ModeSpecContext::MODE() {
  return getToken(ANTLRv4Parser::MODE, 0);
}

ANTLRv4Parser::IdentifierContext *ANTLRv4Parser::ModeSpecContext::identifier() {
  return getRuleContext<ANTLRv4Parser::IdentifierContext>(0);
}

tree::TerminalNode *ANTLRv4Parser::ModeSpecContext::SEMI() {
  return getToken(ANTLRv4Parser::SEMI, 0);
}

std::vector<ANTLRv4Parser::LexerRuleSpecContext *>
ANTLRv4Parser::ModeSpecContext::lexerRuleSpec() {
  return getRuleContexts<ANTLRv4Parser::LexerRuleSpecContext>();
}

ANTLRv4Parser::LexerRuleSpecContext *
ANTLRv4Parser::ModeSpecContext::lexerRuleSpec(size_t i) {
  return getRuleContext<ANTLRv4Parser::LexerRuleSpecContext>(i);
}

size_t ANTLRv4Parser::ModeSpecContext::getRuleIndex() const {
  return ANTLRv4Parser::RuleModeSpec;
}

void ANTLRv4Parser::ModeSpecContext::enterRule(
    tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ANTLRv4ParserListener *>(listener);
  if (parserListener != nullptr) parserListener->enterModeSpec(this);
}

void ANTLRv4Parser::ModeSpecContext::exitRule(
    tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ANTLRv4ParserListener *>(listener);
  if (parserListener != nullptr) parserListener->exitModeSpec(this);
}

ANTLRv4Parser::ModeSpecContext *ANTLRv4Parser::modeSpec() {
  ModeSpecContext *_localctx =
      _tracker.createInstance<ModeSpecContext>(_ctx, getState());
  enterRule(_localctx, 32, ANTLRv4Parser::RuleModeSpec);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(263);
    match(ANTLRv4Parser::MODE);
    setState(264);
    identifier();
    setState(265);
    match(ANTLRv4Parser::SEMI);
    setState(269);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == ANTLRv4Parser::TOKEN_REF

           || _la == ANTLRv4Parser::FRAGMENT) {
      setState(266);
      lexerRuleSpec();
      setState(271);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RulesContext
//------------------------------------------------------------------

ANTLRv4Parser::RulesContext::RulesContext(ParserRuleContext *parent,
                                          size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

std::vector<ANTLRv4Parser::RuleSpecContext *>
ANTLRv4Parser::RulesContext::ruleSpec() {
  return getRuleContexts<ANTLRv4Parser::RuleSpecContext>();
}

ANTLRv4Parser::RuleSpecContext *ANTLRv4Parser::RulesContext::ruleSpec(
    size_t i) {
  return getRuleContext<ANTLRv4Parser::RuleSpecContext>(i);
}

size_t ANTLRv4Parser::RulesContext::getRuleIndex() const {
  return ANTLRv4Parser::RuleRules;
}

void ANTLRv4Parser::RulesContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ANTLRv4ParserListener *>(listener);
  if (parserListener != nullptr) parserListener->enterRules(this);
}

void ANTLRv4Parser::RulesContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ANTLRv4ParserListener *>(listener);
  if (parserListener != nullptr) parserListener->exitRules(this);
}

ANTLRv4Parser::RulesContext *ANTLRv4Parser::rules() {
  RulesContext *_localctx =
      _tracker.createInstance<RulesContext>(_ctx, getState());
  enterRule(_localctx, 34, ANTLRv4Parser::RuleRules);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(275);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while ((((_la & ~0x3fULL) == 0) && ((1ULL << _la) & 7405574) != 0)) {
      setState(272);
      ruleSpec();
      setState(277);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RuleSpecContext
//------------------------------------------------------------------

ANTLRv4Parser::RuleSpecContext::RuleSpecContext(ParserRuleContext *parent,
                                                size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

ANTLRv4Parser::ParserRuleSpecContext *
ANTLRv4Parser::RuleSpecContext::parserRuleSpec() {
  return getRuleContext<ANTLRv4Parser::ParserRuleSpecContext>(0);
}

ANTLRv4Parser::LexerRuleSpecContext *
ANTLRv4Parser::RuleSpecContext::lexerRuleSpec() {
  return getRuleContext<ANTLRv4Parser::LexerRuleSpecContext>(0);
}

size_t ANTLRv4Parser::RuleSpecContext::getRuleIndex() const {
  return ANTLRv4Parser::RuleRuleSpec;
}

void ANTLRv4Parser::RuleSpecContext::enterRule(
    tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ANTLRv4ParserListener *>(listener);
  if (parserListener != nullptr) parserListener->enterRuleSpec(this);
}

void ANTLRv4Parser::RuleSpecContext::exitRule(
    tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ANTLRv4ParserListener *>(listener);
  if (parserListener != nullptr) parserListener->exitRuleSpec(this);
}

ANTLRv4Parser::RuleSpecContext *ANTLRv4Parser::ruleSpec() {
  RuleSpecContext *_localctx =
      _tracker.createInstance<RuleSpecContext>(_ctx, getState());
  enterRule(_localctx, 36, ANTLRv4Parser::RuleRuleSpec);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(280);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(
        _input, 19, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(278);
        parserRuleSpec();
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(279);
        lexerRuleSpec();
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ParserRuleSpecContext
//------------------------------------------------------------------

ANTLRv4Parser::ParserRuleSpecContext::ParserRuleSpecContext(
    ParserRuleContext *parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

tree::TerminalNode *ANTLRv4Parser::ParserRuleSpecContext::RULE_REF() {
  return getToken(ANTLRv4Parser::RULE_REF, 0);
}

tree::TerminalNode *ANTLRv4Parser::ParserRuleSpecContext::COLON() {
  return getToken(ANTLRv4Parser::COLON, 0);
}

ANTLRv4Parser::RuleBlockContext *
ANTLRv4Parser::ParserRuleSpecContext::ruleBlock() {
  return getRuleContext<ANTLRv4Parser::RuleBlockContext>(0);
}

tree::TerminalNode *ANTLRv4Parser::ParserRuleSpecContext::SEMI() {
  return getToken(ANTLRv4Parser::SEMI, 0);
}

ANTLRv4Parser::ExceptionGroupContext *
ANTLRv4Parser::ParserRuleSpecContext::exceptionGroup() {
  return getRuleContext<ANTLRv4Parser::ExceptionGroupContext>(0);
}

ANTLRv4Parser::RuleModifiersContext *
ANTLRv4Parser::ParserRuleSpecContext::ruleModifiers() {
  return getRuleContext<ANTLRv4Parser::RuleModifiersContext>(0);
}

ANTLRv4Parser::ArgActionBlockContext *
ANTLRv4Parser::ParserRuleSpecContext::argActionBlock() {
  return getRuleContext<ANTLRv4Parser::ArgActionBlockContext>(0);
}

ANTLRv4Parser::RuleReturnsContext *
ANTLRv4Parser::ParserRuleSpecContext::ruleReturns() {
  return getRuleContext<ANTLRv4Parser::RuleReturnsContext>(0);
}

ANTLRv4Parser::ThrowsSpecContext *
ANTLRv4Parser::ParserRuleSpecContext::throwsSpec() {
  return getRuleContext<ANTLRv4Parser::ThrowsSpecContext>(0);
}

ANTLRv4Parser::LocalsSpecContext *
ANTLRv4Parser::ParserRuleSpecContext::localsSpec() {
  return getRuleContext<ANTLRv4Parser::LocalsSpecContext>(0);
}

std::vector<ANTLRv4Parser::RulePrequelContext *>
ANTLRv4Parser::ParserRuleSpecContext::rulePrequel() {
  return getRuleContexts<ANTLRv4Parser::RulePrequelContext>();
}

ANTLRv4Parser::RulePrequelContext *
ANTLRv4Parser::ParserRuleSpecContext::rulePrequel(size_t i) {
  return getRuleContext<ANTLRv4Parser::RulePrequelContext>(i);
}

size_t ANTLRv4Parser::ParserRuleSpecContext::getRuleIndex() const {
  return ANTLRv4Parser::RuleParserRuleSpec;
}

void ANTLRv4Parser::ParserRuleSpecContext::enterRule(
    tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ANTLRv4ParserListener *>(listener);
  if (parserListener != nullptr) parserListener->enterParserRuleSpec(this);
}

void ANTLRv4Parser::ParserRuleSpecContext::exitRule(
    tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ANTLRv4ParserListener *>(listener);
  if (parserListener != nullptr) parserListener->exitParserRuleSpec(this);
}

ANTLRv4Parser::ParserRuleSpecContext *ANTLRv4Parser::parserRuleSpec() {
  ParserRuleSpecContext *_localctx =
      _tracker.createInstance<ParserRuleSpecContext>(_ctx, getState());
  enterRule(_localctx, 38, ANTLRv4Parser::RuleParserRuleSpec);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(283);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~0x3fULL) == 0) && ((1ULL << _la) & 7405568) != 0)) {
      setState(282);
      ruleModifiers();
    }
    setState(285);
    match(ANTLRv4Parser::RULE_REF);
    setState(287);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ANTLRv4Parser::BEGIN_ARGUMENT) {
      setState(286);
      argActionBlock();
    }
    setState(290);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ANTLRv4Parser::RETURNS) {
      setState(289);
      ruleReturns();
    }
    setState(293);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ANTLRv4Parser::THROWS) {
      setState(292);
      throwsSpec();
    }
    setState(296);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ANTLRv4Parser::LOCALS) {
      setState(295);
      localsSpec();
    }
    setState(301);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == ANTLRv4Parser::OPTIONS

           || _la == ANTLRv4Parser::AT) {
      setState(298);
      rulePrequel();
      setState(303);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(304);
    match(ANTLRv4Parser::COLON);
    setState(305);
    ruleBlock();
    setState(306);
    match(ANTLRv4Parser::SEMI);
    setState(307);
    exceptionGroup();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExceptionGroupContext
//------------------------------------------------------------------

ANTLRv4Parser::ExceptionGroupContext::ExceptionGroupContext(
    ParserRuleContext *parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

std::vector<ANTLRv4Parser::ExceptionHandlerContext *>
ANTLRv4Parser::ExceptionGroupContext::exceptionHandler() {
  return getRuleContexts<ANTLRv4Parser::ExceptionHandlerContext>();
}

ANTLRv4Parser::ExceptionHandlerContext *
ANTLRv4Parser::ExceptionGroupContext::exceptionHandler(size_t i) {
  return getRuleContext<ANTLRv4Parser::ExceptionHandlerContext>(i);
}

ANTLRv4Parser::FinallyClauseContext *
ANTLRv4Parser::ExceptionGroupContext::finallyClause() {
  return getRuleContext<ANTLRv4Parser::FinallyClauseContext>(0);
}

size_t ANTLRv4Parser::ExceptionGroupContext::getRuleIndex() const {
  return ANTLRv4Parser::RuleExceptionGroup;
}

void ANTLRv4Parser::ExceptionGroupContext::enterRule(
    tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ANTLRv4ParserListener *>(listener);
  if (parserListener != nullptr) parserListener->enterExceptionGroup(this);
}

void ANTLRv4Parser::ExceptionGroupContext::exitRule(
    tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ANTLRv4ParserListener *>(listener);
  if (parserListener != nullptr) parserListener->exitExceptionGroup(this);
}

ANTLRv4Parser::ExceptionGroupContext *ANTLRv4Parser::exceptionGroup() {
  ExceptionGroupContext *_localctx =
      _tracker.createInstance<ExceptionGroupContext>(_ctx, getState());
  enterRule(_localctx, 40, ANTLRv4Parser::RuleExceptionGroup);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(312);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == ANTLRv4Parser::CATCH) {
      setState(309);
      exceptionHandler();
      setState(314);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(316);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ANTLRv4Parser::FINALLY) {
      setState(315);
      finallyClause();
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExceptionHandlerContext
//------------------------------------------------------------------

ANTLRv4Parser::ExceptionHandlerContext::ExceptionHandlerContext(
    ParserRuleContext *parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

tree::TerminalNode *ANTLRv4Parser::ExceptionHandlerContext::CATCH() {
  return getToken(ANTLRv4Parser::CATCH, 0);
}

ANTLRv4Parser::ArgActionBlockContext *
ANTLRv4Parser::ExceptionHandlerContext::argActionBlock() {
  return getRuleContext<ANTLRv4Parser::ArgActionBlockContext>(0);
}

ANTLRv4Parser::ActionBlockContext *
ANTLRv4Parser::ExceptionHandlerContext::actionBlock() {
  return getRuleContext<ANTLRv4Parser::ActionBlockContext>(0);
}

size_t ANTLRv4Parser::ExceptionHandlerContext::getRuleIndex() const {
  return ANTLRv4Parser::RuleExceptionHandler;
}

void ANTLRv4Parser::ExceptionHandlerContext::enterRule(
    tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ANTLRv4ParserListener *>(listener);
  if (parserListener != nullptr) parserListener->enterExceptionHandler(this);
}

void ANTLRv4Parser::ExceptionHandlerContext::exitRule(
    tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ANTLRv4ParserListener *>(listener);
  if (parserListener != nullptr) parserListener->exitExceptionHandler(this);
}

ANTLRv4Parser::ExceptionHandlerContext *ANTLRv4Parser::exceptionHandler() {
  ExceptionHandlerContext *_localctx =
      _tracker.createInstance<ExceptionHandlerContext>(_ctx, getState());
  enterRule(_localctx, 42, ANTLRv4Parser::RuleExceptionHandler);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(318);
    match(ANTLRv4Parser::CATCH);
    setState(319);
    argActionBlock();
    setState(320);
    actionBlock();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FinallyClauseContext
//------------------------------------------------------------------

ANTLRv4Parser::FinallyClauseContext::FinallyClauseContext(
    ParserRuleContext *parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

tree::TerminalNode *ANTLRv4Parser::FinallyClauseContext::FINALLY() {
  return getToken(ANTLRv4Parser::FINALLY, 0);
}

ANTLRv4Parser::ActionBlockContext *
ANTLRv4Parser::FinallyClauseContext::actionBlock() {
  return getRuleContext<ANTLRv4Parser::ActionBlockContext>(0);
}

size_t ANTLRv4Parser::FinallyClauseContext::getRuleIndex() const {
  return ANTLRv4Parser::RuleFinallyClause;
}

void ANTLRv4Parser::FinallyClauseContext::enterRule(
    tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ANTLRv4ParserListener *>(listener);
  if (parserListener != nullptr) parserListener->enterFinallyClause(this);
}

void ANTLRv4Parser::FinallyClauseContext::exitRule(
    tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ANTLRv4ParserListener *>(listener);
  if (parserListener != nullptr) parserListener->exitFinallyClause(this);
}

ANTLRv4Parser::FinallyClauseContext *ANTLRv4Parser::finallyClause() {
  FinallyClauseContext *_localctx =
      _tracker.createInstance<FinallyClauseContext>(_ctx, getState());
  enterRule(_localctx, 44, ANTLRv4Parser::RuleFinallyClause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(322);
    match(ANTLRv4Parser::FINALLY);
    setState(323);
    actionBlock();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RulePrequelContext
//------------------------------------------------------------------

ANTLRv4Parser::RulePrequelContext::RulePrequelContext(ParserRuleContext *parent,
                                                      size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

ANTLRv4Parser::OptionsSpecContext *
ANTLRv4Parser::RulePrequelContext::optionsSpec() {
  return getRuleContext<ANTLRv4Parser::OptionsSpecContext>(0);
}

ANTLRv4Parser::RuleActionContext *
ANTLRv4Parser::RulePrequelContext::ruleAction() {
  return getRuleContext<ANTLRv4Parser::RuleActionContext>(0);
}

size_t ANTLRv4Parser::RulePrequelContext::getRuleIndex() const {
  return ANTLRv4Parser::RuleRulePrequel;
}

void ANTLRv4Parser::RulePrequelContext::enterRule(
    tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ANTLRv4ParserListener *>(listener);
  if (parserListener != nullptr) parserListener->enterRulePrequel(this);
}

void ANTLRv4Parser::RulePrequelContext::exitRule(
    tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ANTLRv4ParserListener *>(listener);
  if (parserListener != nullptr) parserListener->exitRulePrequel(this);
}

ANTLRv4Parser::RulePrequelContext *ANTLRv4Parser::rulePrequel() {
  RulePrequelContext *_localctx =
      _tracker.createInstance<RulePrequelContext>(_ctx, getState());
  enterRule(_localctx, 46, ANTLRv4Parser::RuleRulePrequel);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(327);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case ANTLRv4Parser::OPTIONS: {
        enterOuterAlt(_localctx, 1);
        setState(325);
        optionsSpec();
        break;
      }

      case ANTLRv4Parser::AT: {
        enterOuterAlt(_localctx, 2);
        setState(326);
        ruleAction();
        break;
      }

      default:
        throw NoViableAltException(this);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RuleReturnsContext
//------------------------------------------------------------------

ANTLRv4Parser::RuleReturnsContext::RuleReturnsContext(ParserRuleContext *parent,
                                                      size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

tree::TerminalNode *ANTLRv4Parser::RuleReturnsContext::RETURNS() {
  return getToken(ANTLRv4Parser::RETURNS, 0);
}

ANTLRv4Parser::ArgActionBlockContext *
ANTLRv4Parser::RuleReturnsContext::argActionBlock() {
  return getRuleContext<ANTLRv4Parser::ArgActionBlockContext>(0);
}

size_t ANTLRv4Parser::RuleReturnsContext::getRuleIndex() const {
  return ANTLRv4Parser::RuleRuleReturns;
}

void ANTLRv4Parser::RuleReturnsContext::enterRule(
    tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ANTLRv4ParserListener *>(listener);
  if (parserListener != nullptr) parserListener->enterRuleReturns(this);
}

void ANTLRv4Parser::RuleReturnsContext::exitRule(
    tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ANTLRv4ParserListener *>(listener);
  if (parserListener != nullptr) parserListener->exitRuleReturns(this);
}

ANTLRv4Parser::RuleReturnsContext *ANTLRv4Parser::ruleReturns() {
  RuleReturnsContext *_localctx =
      _tracker.createInstance<RuleReturnsContext>(_ctx, getState());
  enterRule(_localctx, 48, ANTLRv4Parser::RuleRuleReturns);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(329);
    match(ANTLRv4Parser::RETURNS);
    setState(330);
    argActionBlock();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ThrowsSpecContext
//------------------------------------------------------------------

ANTLRv4Parser::ThrowsSpecContext::ThrowsSpecContext(ParserRuleContext *parent,
                                                    size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

tree::TerminalNode *ANTLRv4Parser::ThrowsSpecContext::THROWS() {
  return getToken(ANTLRv4Parser::THROWS, 0);
}

std::vector<ANTLRv4Parser::IdentifierContext *>
ANTLRv4Parser::ThrowsSpecContext::identifier() {
  return getRuleContexts<ANTLRv4Parser::IdentifierContext>();
}

ANTLRv4Parser::IdentifierContext *ANTLRv4Parser::ThrowsSpecContext::identifier(
    size_t i) {
  return getRuleContext<ANTLRv4Parser::IdentifierContext>(i);
}

std::vector<tree::TerminalNode *> ANTLRv4Parser::ThrowsSpecContext::COMMA() {
  return getTokens(ANTLRv4Parser::COMMA);
}

tree::TerminalNode *ANTLRv4Parser::ThrowsSpecContext::COMMA(size_t i) {
  return getToken(ANTLRv4Parser::COMMA, i);
}

size_t ANTLRv4Parser::ThrowsSpecContext::getRuleIndex() const {
  return ANTLRv4Parser::RuleThrowsSpec;
}

void ANTLRv4Parser::ThrowsSpecContext::enterRule(
    tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ANTLRv4ParserListener *>(listener);
  if (parserListener != nullptr) parserListener->enterThrowsSpec(this);
}

void ANTLRv4Parser::ThrowsSpecContext::exitRule(
    tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ANTLRv4ParserListener *>(listener);
  if (parserListener != nullptr) parserListener->exitThrowsSpec(this);
}

ANTLRv4Parser::ThrowsSpecContext *ANTLRv4Parser::throwsSpec() {
  ThrowsSpecContext *_localctx =
      _tracker.createInstance<ThrowsSpecContext>(_ctx, getState());
  enterRule(_localctx, 50, ANTLRv4Parser::RuleThrowsSpec);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(332);
    match(ANTLRv4Parser::THROWS);
    setState(333);
    identifier();
    setState(338);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == ANTLRv4Parser::COMMA) {
      setState(334);
      match(ANTLRv4Parser::COMMA);
      setState(335);
      identifier();
      setState(340);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LocalsSpecContext
//------------------------------------------------------------------

ANTLRv4Parser::LocalsSpecContext::LocalsSpecContext(ParserRuleContext *parent,
                                                    size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

tree::TerminalNode *ANTLRv4Parser::LocalsSpecContext::LOCALS() {
  return getToken(ANTLRv4Parser::LOCALS, 0);
}

ANTLRv4Parser::ArgActionBlockContext *
ANTLRv4Parser::LocalsSpecContext::argActionBlock() {
  return getRuleContext<ANTLRv4Parser::ArgActionBlockContext>(0);
}

size_t ANTLRv4Parser::LocalsSpecContext::getRuleIndex() const {
  return ANTLRv4Parser::RuleLocalsSpec;
}

void ANTLRv4Parser::LocalsSpecContext::enterRule(
    tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ANTLRv4ParserListener *>(listener);
  if (parserListener != nullptr) parserListener->enterLocalsSpec(this);
}

void ANTLRv4Parser::LocalsSpecContext::exitRule(
    tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ANTLRv4ParserListener *>(listener);
  if (parserListener != nullptr) parserListener->exitLocalsSpec(this);
}

ANTLRv4Parser::LocalsSpecContext *ANTLRv4Parser::localsSpec() {
  LocalsSpecContext *_localctx =
      _tracker.createInstance<LocalsSpecContext>(_ctx, getState());
  enterRule(_localctx, 52, ANTLRv4Parser::RuleLocalsSpec);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(341);
    match(ANTLRv4Parser::LOCALS);
    setState(342);
    argActionBlock();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RuleActionContext
//------------------------------------------------------------------

ANTLRv4Parser::RuleActionContext::RuleActionContext(ParserRuleContext *parent,
                                                    size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

tree::TerminalNode *ANTLRv4Parser::RuleActionContext::AT() {
  return getToken(ANTLRv4Parser::AT, 0);
}

ANTLRv4Parser::IdentifierContext *
ANTLRv4Parser::RuleActionContext::identifier() {
  return getRuleContext<ANTLRv4Parser::IdentifierContext>(0);
}

ANTLRv4Parser::ActionBlockContext *
ANTLRv4Parser::RuleActionContext::actionBlock() {
  return getRuleContext<ANTLRv4Parser::ActionBlockContext>(0);
}

size_t ANTLRv4Parser::RuleActionContext::getRuleIndex() const {
  return ANTLRv4Parser::RuleRuleAction;
}

void ANTLRv4Parser::RuleActionContext::enterRule(
    tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ANTLRv4ParserListener *>(listener);
  if (parserListener != nullptr) parserListener->enterRuleAction(this);
}

void ANTLRv4Parser::RuleActionContext::exitRule(
    tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ANTLRv4ParserListener *>(listener);
  if (parserListener != nullptr) parserListener->exitRuleAction(this);
}

ANTLRv4Parser::RuleActionContext *ANTLRv4Parser::ruleAction() {
  RuleActionContext *_localctx =
      _tracker.createInstance<RuleActionContext>(_ctx, getState());
  enterRule(_localctx, 54, ANTLRv4Parser::RuleRuleAction);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(344);
    match(ANTLRv4Parser::AT);
    setState(345);
    identifier();
    setState(346);
    actionBlock();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RuleModifiersContext
//------------------------------------------------------------------

ANTLRv4Parser::RuleModifiersContext::RuleModifiersContext(
    ParserRuleContext *parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

std::vector<ANTLRv4Parser::RuleModifierContext *>
ANTLRv4Parser::RuleModifiersContext::ruleModifier() {
  return getRuleContexts<ANTLRv4Parser::RuleModifierContext>();
}

ANTLRv4Parser::RuleModifierContext *
ANTLRv4Parser::RuleModifiersContext::ruleModifier(size_t i) {
  return getRuleContext<ANTLRv4Parser::RuleModifierContext>(i);
}

size_t ANTLRv4Parser::RuleModifiersContext::getRuleIndex() const {
  return ANTLRv4Parser::RuleRuleModifiers;
}

void ANTLRv4Parser::RuleModifiersContext::enterRule(
    tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ANTLRv4ParserListener *>(listener);
  if (parserListener != nullptr) parserListener->enterRuleModifiers(this);
}

void ANTLRv4Parser::RuleModifiersContext::exitRule(
    tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ANTLRv4ParserListener *>(listener);
  if (parserListener != nullptr) parserListener->exitRuleModifiers(this);
}

ANTLRv4Parser::RuleModifiersContext *ANTLRv4Parser::ruleModifiers() {
  RuleModifiersContext *_localctx =
      _tracker.createInstance<RuleModifiersContext>(_ctx, getState());
  enterRule(_localctx, 56, ANTLRv4Parser::RuleRuleModifiers);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(349);
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(348);
      ruleModifier();
      setState(351);
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while ((((_la & ~0x3fULL) == 0) && ((1ULL << _la) & 7405568) != 0));

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RuleModifierContext
//------------------------------------------------------------------

ANTLRv4Parser::RuleModifierContext::RuleModifierContext(
    ParserRuleContext *parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

tree::TerminalNode *ANTLRv4Parser::RuleModifierContext::PUBLIC() {
  return getToken(ANTLRv4Parser::PUBLIC, 0);
}

tree::TerminalNode *ANTLRv4Parser::RuleModifierContext::PRIVATE() {
  return getToken(ANTLRv4Parser::PRIVATE, 0);
}

tree::TerminalNode *ANTLRv4Parser::RuleModifierContext::PROTECTED() {
  return getToken(ANTLRv4Parser::PROTECTED, 0);
}

tree::TerminalNode *ANTLRv4Parser::RuleModifierContext::FRAGMENT() {
  return getToken(ANTLRv4Parser::FRAGMENT, 0);
}

size_t ANTLRv4Parser::RuleModifierContext::getRuleIndex() const {
  return ANTLRv4Parser::RuleRuleModifier;
}

void ANTLRv4Parser::RuleModifierContext::enterRule(
    tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ANTLRv4ParserListener *>(listener);
  if (parserListener != nullptr) parserListener->enterRuleModifier(this);
}

void ANTLRv4Parser::RuleModifierContext::exitRule(
    tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ANTLRv4ParserListener *>(listener);
  if (parserListener != nullptr) parserListener->exitRuleModifier(this);
}

ANTLRv4Parser::RuleModifierContext *ANTLRv4Parser::ruleModifier() {
  RuleModifierContext *_localctx =
      _tracker.createInstance<RuleModifierContext>(_ctx, getState());
  enterRule(_localctx, 58, ANTLRv4Parser::RuleRuleModifier);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(353);
    _la = _input->LA(1);
    if (!((((_la & ~0x3fULL) == 0) && ((1ULL << _la) & 7405568) != 0))) {
      _errHandler->recoverInline(this);
    } else {
      _errHandler->reportMatch(this);
      consume();
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RuleBlockContext
//------------------------------------------------------------------

ANTLRv4Parser::RuleBlockContext::RuleBlockContext(ParserRuleContext *parent,
                                                  size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

ANTLRv4Parser::RuleAltListContext *
ANTLRv4Parser::RuleBlockContext::ruleAltList() {
  return getRuleContext<ANTLRv4Parser::RuleAltListContext>(0);
}

size_t ANTLRv4Parser::RuleBlockContext::getRuleIndex() const {
  return ANTLRv4Parser::RuleRuleBlock;
}

void ANTLRv4Parser::RuleBlockContext::enterRule(
    tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ANTLRv4ParserListener *>(listener);
  if (parserListener != nullptr) parserListener->enterRuleBlock(this);
}

void ANTLRv4Parser::RuleBlockContext::exitRule(
    tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ANTLRv4ParserListener *>(listener);
  if (parserListener != nullptr) parserListener->exitRuleBlock(this);
}

ANTLRv4Parser::RuleBlockContext *ANTLRv4Parser::ruleBlock() {
  RuleBlockContext *_localctx =
      _tracker.createInstance<RuleBlockContext>(_ctx, getState());
  enterRule(_localctx, 60, ANTLRv4Parser::RuleRuleBlock);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(355);
    ruleAltList();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RuleAltListContext
//------------------------------------------------------------------

ANTLRv4Parser::RuleAltListContext::RuleAltListContext(ParserRuleContext *parent,
                                                      size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

std::vector<ANTLRv4Parser::LabeledAltContext *>
ANTLRv4Parser::RuleAltListContext::labeledAlt() {
  return getRuleContexts<ANTLRv4Parser::LabeledAltContext>();
}

ANTLRv4Parser::LabeledAltContext *ANTLRv4Parser::RuleAltListContext::labeledAlt(
    size_t i) {
  return getRuleContext<ANTLRv4Parser::LabeledAltContext>(i);
}

std::vector<tree::TerminalNode *> ANTLRv4Parser::RuleAltListContext::OR() {
  return getTokens(ANTLRv4Parser::OR);
}

tree::TerminalNode *ANTLRv4Parser::RuleAltListContext::OR(size_t i) {
  return getToken(ANTLRv4Parser::OR, i);
}

size_t ANTLRv4Parser::RuleAltListContext::getRuleIndex() const {
  return ANTLRv4Parser::RuleRuleAltList;
}

void ANTLRv4Parser::RuleAltListContext::enterRule(
    tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ANTLRv4ParserListener *>(listener);
  if (parserListener != nullptr) parserListener->enterRuleAltList(this);
}

void ANTLRv4Parser::RuleAltListContext::exitRule(
    tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ANTLRv4ParserListener *>(listener);
  if (parserListener != nullptr) parserListener->exitRuleAltList(this);
}

ANTLRv4Parser::RuleAltListContext *ANTLRv4Parser::ruleAltList() {
  RuleAltListContext *_localctx =
      _tracker.createInstance<RuleAltListContext>(_ctx, getState());
  enterRule(_localctx, 62, ANTLRv4Parser::RuleRuleAltList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(357);
    labeledAlt();
    setState(362);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == ANTLRv4Parser::OR) {
      setState(358);
      match(ANTLRv4Parser::OR);
      setState(359);
      labeledAlt();
      setState(364);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LabeledAltContext
//------------------------------------------------------------------

ANTLRv4Parser::LabeledAltContext::LabeledAltContext(ParserRuleContext *parent,
                                                    size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

ANTLRv4Parser::AlternativeContext *
ANTLRv4Parser::LabeledAltContext::alternative() {
  return getRuleContext<ANTLRv4Parser::AlternativeContext>(0);
}

tree::TerminalNode *ANTLRv4Parser::LabeledAltContext::POUND() {
  return getToken(ANTLRv4Parser::POUND, 0);
}

ANTLRv4Parser::IdentifierContext *
ANTLRv4Parser::LabeledAltContext::identifier() {
  return getRuleContext<ANTLRv4Parser::IdentifierContext>(0);
}

size_t ANTLRv4Parser::LabeledAltContext::getRuleIndex() const {
  return ANTLRv4Parser::RuleLabeledAlt;
}

void ANTLRv4Parser::LabeledAltContext::enterRule(
    tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ANTLRv4ParserListener *>(listener);
  if (parserListener != nullptr) parserListener->enterLabeledAlt(this);
}

void ANTLRv4Parser::LabeledAltContext::exitRule(
    tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ANTLRv4ParserListener *>(listener);
  if (parserListener != nullptr) parserListener->exitLabeledAlt(this);
}

ANTLRv4Parser::LabeledAltContext *ANTLRv4Parser::labeledAlt() {
  LabeledAltContext *_localctx =
      _tracker.createInstance<LabeledAltContext>(_ctx, getState());
  enterRule(_localctx, 64, ANTLRv4Parser::RuleLabeledAlt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(365);
    alternative();
    setState(368);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ANTLRv4Parser::POUND) {
      setState(366);
      match(ANTLRv4Parser::POUND);
      setState(367);
      identifier();
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LexerRuleSpecContext
//------------------------------------------------------------------

ANTLRv4Parser::LexerRuleSpecContext::LexerRuleSpecContext(
    ParserRuleContext *parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

tree::TerminalNode *ANTLRv4Parser::LexerRuleSpecContext::TOKEN_REF() {
  return getToken(ANTLRv4Parser::TOKEN_REF, 0);
}

tree::TerminalNode *ANTLRv4Parser::LexerRuleSpecContext::COLON() {
  return getToken(ANTLRv4Parser::COLON, 0);
}

ANTLRv4Parser::LexerRuleBlockContext *
ANTLRv4Parser::LexerRuleSpecContext::lexerRuleBlock() {
  return getRuleContext<ANTLRv4Parser::LexerRuleBlockContext>(0);
}

tree::TerminalNode *ANTLRv4Parser::LexerRuleSpecContext::SEMI() {
  return getToken(ANTLRv4Parser::SEMI, 0);
}

tree::TerminalNode *ANTLRv4Parser::LexerRuleSpecContext::FRAGMENT() {
  return getToken(ANTLRv4Parser::FRAGMENT, 0);
}

size_t ANTLRv4Parser::LexerRuleSpecContext::getRuleIndex() const {
  return ANTLRv4Parser::RuleLexerRuleSpec;
}

void ANTLRv4Parser::LexerRuleSpecContext::enterRule(
    tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ANTLRv4ParserListener *>(listener);
  if (parserListener != nullptr) parserListener->enterLexerRuleSpec(this);
}

void ANTLRv4Parser::LexerRuleSpecContext::exitRule(
    tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ANTLRv4ParserListener *>(listener);
  if (parserListener != nullptr) parserListener->exitLexerRuleSpec(this);
}

ANTLRv4Parser::LexerRuleSpecContext *ANTLRv4Parser::lexerRuleSpec() {
  LexerRuleSpecContext *_localctx =
      _tracker.createInstance<LexerRuleSpecContext>(_ctx, getState());
  enterRule(_localctx, 66, ANTLRv4Parser::RuleLexerRuleSpec);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(371);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ANTLRv4Parser::FRAGMENT) {
      setState(370);
      match(ANTLRv4Parser::FRAGMENT);
    }
    setState(373);
    match(ANTLRv4Parser::TOKEN_REF);
    setState(374);
    match(ANTLRv4Parser::COLON);
    setState(375);
    lexerRuleBlock();
    setState(376);
    match(ANTLRv4Parser::SEMI);

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LexerRuleBlockContext
//------------------------------------------------------------------

ANTLRv4Parser::LexerRuleBlockContext::LexerRuleBlockContext(
    ParserRuleContext *parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

ANTLRv4Parser::LexerAltListContext *
ANTLRv4Parser::LexerRuleBlockContext::lexerAltList() {
  return getRuleContext<ANTLRv4Parser::LexerAltListContext>(0);
}

size_t ANTLRv4Parser::LexerRuleBlockContext::getRuleIndex() const {
  return ANTLRv4Parser::RuleLexerRuleBlock;
}

void ANTLRv4Parser::LexerRuleBlockContext::enterRule(
    tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ANTLRv4ParserListener *>(listener);
  if (parserListener != nullptr) parserListener->enterLexerRuleBlock(this);
}

void ANTLRv4Parser::LexerRuleBlockContext::exitRule(
    tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ANTLRv4ParserListener *>(listener);
  if (parserListener != nullptr) parserListener->exitLexerRuleBlock(this);
}

ANTLRv4Parser::LexerRuleBlockContext *ANTLRv4Parser::lexerRuleBlock() {
  LexerRuleBlockContext *_localctx =
      _tracker.createInstance<LexerRuleBlockContext>(_ctx, getState());
  enterRule(_localctx, 68, ANTLRv4Parser::RuleLexerRuleBlock);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(378);
    lexerAltList();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LexerAltListContext
//------------------------------------------------------------------

ANTLRv4Parser::LexerAltListContext::LexerAltListContext(
    ParserRuleContext *parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

std::vector<ANTLRv4Parser::LexerAltContext *>
ANTLRv4Parser::LexerAltListContext::lexerAlt() {
  return getRuleContexts<ANTLRv4Parser::LexerAltContext>();
}

ANTLRv4Parser::LexerAltContext *ANTLRv4Parser::LexerAltListContext::lexerAlt(
    size_t i) {
  return getRuleContext<ANTLRv4Parser::LexerAltContext>(i);
}

std::vector<tree::TerminalNode *> ANTLRv4Parser::LexerAltListContext::OR() {
  return getTokens(ANTLRv4Parser::OR);
}

tree::TerminalNode *ANTLRv4Parser::LexerAltListContext::OR(size_t i) {
  return getToken(ANTLRv4Parser::OR, i);
}

size_t ANTLRv4Parser::LexerAltListContext::getRuleIndex() const {
  return ANTLRv4Parser::RuleLexerAltList;
}

void ANTLRv4Parser::LexerAltListContext::enterRule(
    tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ANTLRv4ParserListener *>(listener);
  if (parserListener != nullptr) parserListener->enterLexerAltList(this);
}

void ANTLRv4Parser::LexerAltListContext::exitRule(
    tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ANTLRv4ParserListener *>(listener);
  if (parserListener != nullptr) parserListener->exitLexerAltList(this);
}

ANTLRv4Parser::LexerAltListContext *ANTLRv4Parser::lexerAltList() {
  LexerAltListContext *_localctx =
      _tracker.createInstance<LexerAltListContext>(_ctx, getState());
  enterRule(_localctx, 70, ANTLRv4Parser::RuleLexerAltList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(380);
    lexerAlt();
    setState(385);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == ANTLRv4Parser::OR) {
      setState(381);
      match(ANTLRv4Parser::OR);
      setState(382);
      lexerAlt();
      setState(387);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LexerAltContext
//------------------------------------------------------------------

ANTLRv4Parser::LexerAltContext::LexerAltContext(ParserRuleContext *parent,
                                                size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

ANTLRv4Parser::LexerElementsContext *
ANTLRv4Parser::LexerAltContext::lexerElements() {
  return getRuleContext<ANTLRv4Parser::LexerElementsContext>(0);
}

ANTLRv4Parser::LexerCommandsContext *
ANTLRv4Parser::LexerAltContext::lexerCommands() {
  return getRuleContext<ANTLRv4Parser::LexerCommandsContext>(0);
}

size_t ANTLRv4Parser::LexerAltContext::getRuleIndex() const {
  return ANTLRv4Parser::RuleLexerAlt;
}

void ANTLRv4Parser::LexerAltContext::enterRule(
    tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ANTLRv4ParserListener *>(listener);
  if (parserListener != nullptr) parserListener->enterLexerAlt(this);
}

void ANTLRv4Parser::LexerAltContext::exitRule(
    tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ANTLRv4ParserListener *>(listener);
  if (parserListener != nullptr) parserListener->exitLexerAlt(this);
}

ANTLRv4Parser::LexerAltContext *ANTLRv4Parser::lexerAlt() {
  LexerAltContext *_localctx =
      _tracker.createInstance<LexerAltContext>(_ctx, getState());
  enterRule(_localctx, 72, ANTLRv4Parser::RuleLexerAlt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(393);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(
        _input, 36, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(388);
        lexerElements();
        setState(390);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == ANTLRv4Parser::RARROW) {
          setState(389);
          lexerCommands();
        }
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);

        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LexerElementsContext
//------------------------------------------------------------------

ANTLRv4Parser::LexerElementsContext::LexerElementsContext(
    ParserRuleContext *parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

std::vector<ANTLRv4Parser::LexerElementContext *>
ANTLRv4Parser::LexerElementsContext::lexerElement() {
  return getRuleContexts<ANTLRv4Parser::LexerElementContext>();
}

ANTLRv4Parser::LexerElementContext *
ANTLRv4Parser::LexerElementsContext::lexerElement(size_t i) {
  return getRuleContext<ANTLRv4Parser::LexerElementContext>(i);
}

size_t ANTLRv4Parser::LexerElementsContext::getRuleIndex() const {
  return ANTLRv4Parser::RuleLexerElements;
}

void ANTLRv4Parser::LexerElementsContext::enterRule(
    tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ANTLRv4ParserListener *>(listener);
  if (parserListener != nullptr) parserListener->enterLexerElements(this);
}

void ANTLRv4Parser::LexerElementsContext::exitRule(
    tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ANTLRv4ParserListener *>(listener);
  if (parserListener != nullptr) parserListener->exitLexerElements(this);
}

ANTLRv4Parser::LexerElementsContext *ANTLRv4Parser::lexerElements() {
  LexerElementsContext *_localctx =
      _tracker.createInstance<LexerElementsContext>(_ctx, getState());
  enterRule(_localctx, 74, ANTLRv4Parser::RuleLexerElements);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(401);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case ANTLRv4Parser::TOKEN_REF:
      case ANTLRv4Parser::RULE_REF:
      case ANTLRv4Parser::LEXER_CHAR_SET:
      case ANTLRv4Parser::STRING_LITERAL:
      case ANTLRv4Parser::BEGIN_ACTION:
      case ANTLRv4Parser::LPAREN:
      case ANTLRv4Parser::DOT:
      case ANTLRv4Parser::NOT: {
        enterOuterAlt(_localctx, 1);
        setState(396);
        _errHandler->sync(this);
        _la = _input->LA(1);
        do {
          setState(395);
          lexerElement();
          setState(398);
          _errHandler->sync(this);
          _la = _input->LA(1);
        } while ((((_la & ~0x3fULL) == 0) &&
                  ((1ULL << _la) & 2533283380332814) != 0));
        break;
      }

      case ANTLRv4Parser::SEMI:
      case ANTLRv4Parser::RPAREN:
      case ANTLRv4Parser::RARROW:
      case ANTLRv4Parser::OR: {
        enterOuterAlt(_localctx, 2);

        break;
      }

      default:
        throw NoViableAltException(this);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LexerElementContext
//------------------------------------------------------------------

ANTLRv4Parser::LexerElementContext::LexerElementContext(
    ParserRuleContext *parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

ANTLRv4Parser::LabeledLexerElementContext *
ANTLRv4Parser::LexerElementContext::labeledLexerElement() {
  return getRuleContext<ANTLRv4Parser::LabeledLexerElementContext>(0);
}

ANTLRv4Parser::EbnfSuffixContext *
ANTLRv4Parser::LexerElementContext::ebnfSuffix() {
  return getRuleContext<ANTLRv4Parser::EbnfSuffixContext>(0);
}

ANTLRv4Parser::LexerAtomContext *
ANTLRv4Parser::LexerElementContext::lexerAtom() {
  return getRuleContext<ANTLRv4Parser::LexerAtomContext>(0);
}

ANTLRv4Parser::LexerBlockContext *
ANTLRv4Parser::LexerElementContext::lexerBlock() {
  return getRuleContext<ANTLRv4Parser::LexerBlockContext>(0);
}

ANTLRv4Parser::ActionBlockContext *
ANTLRv4Parser::LexerElementContext::actionBlock() {
  return getRuleContext<ANTLRv4Parser::ActionBlockContext>(0);
}

tree::TerminalNode *ANTLRv4Parser::LexerElementContext::QUESTION() {
  return getToken(ANTLRv4Parser::QUESTION, 0);
}

size_t ANTLRv4Parser::LexerElementContext::getRuleIndex() const {
  return ANTLRv4Parser::RuleLexerElement;
}

void ANTLRv4Parser::LexerElementContext::enterRule(
    tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ANTLRv4ParserListener *>(listener);
  if (parserListener != nullptr) parserListener->enterLexerElement(this);
}

void ANTLRv4Parser::LexerElementContext::exitRule(
    tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ANTLRv4ParserListener *>(listener);
  if (parserListener != nullptr) parserListener->exitLexerElement(this);
}

ANTLRv4Parser::LexerElementContext *ANTLRv4Parser::lexerElement() {
  LexerElementContext *_localctx =
      _tracker.createInstance<LexerElementContext>(_ctx, getState());
  enterRule(_localctx, 76, ANTLRv4Parser::RuleLexerElement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(419);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(
        _input, 43, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(403);
        labeledLexerElement();
        setState(405);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if ((((_la & ~0x3fULL) == 0) &&
             ((1ULL << _la) & 24189255811072) != 0)) {
          setState(404);
          ebnfSuffix();
        }
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(407);
        lexerAtom();
        setState(409);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if ((((_la & ~0x3fULL) == 0) &&
             ((1ULL << _la) & 24189255811072) != 0)) {
          setState(408);
          ebnfSuffix();
        }
        break;
      }

      case 3: {
        enterOuterAlt(_localctx, 3);
        setState(411);
        lexerBlock();
        setState(413);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if ((((_la & ~0x3fULL) == 0) &&
             ((1ULL << _la) & 24189255811072) != 0)) {
          setState(412);
          ebnfSuffix();
        }
        break;
      }

      case 4: {
        enterOuterAlt(_localctx, 4);
        setState(415);
        actionBlock();
        setState(417);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == ANTLRv4Parser::QUESTION) {
          setState(416);
          match(ANTLRv4Parser::QUESTION);
        }
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LabeledLexerElementContext
//------------------------------------------------------------------

ANTLRv4Parser::LabeledLexerElementContext::LabeledLexerElementContext(
    ParserRuleContext *parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

ANTLRv4Parser::IdentifierContext *
ANTLRv4Parser::LabeledLexerElementContext::identifier() {
  return getRuleContext<ANTLRv4Parser::IdentifierContext>(0);
}

tree::TerminalNode *ANTLRv4Parser::LabeledLexerElementContext::ASSIGN() {
  return getToken(ANTLRv4Parser::ASSIGN, 0);
}

tree::TerminalNode *ANTLRv4Parser::LabeledLexerElementContext::PLUS_ASSIGN() {
  return getToken(ANTLRv4Parser::PLUS_ASSIGN, 0);
}

ANTLRv4Parser::LexerAtomContext *
ANTLRv4Parser::LabeledLexerElementContext::lexerAtom() {
  return getRuleContext<ANTLRv4Parser::LexerAtomContext>(0);
}

ANTLRv4Parser::LexerBlockContext *
ANTLRv4Parser::LabeledLexerElementContext::lexerBlock() {
  return getRuleContext<ANTLRv4Parser::LexerBlockContext>(0);
}

size_t ANTLRv4Parser::LabeledLexerElementContext::getRuleIndex() const {
  return ANTLRv4Parser::RuleLabeledLexerElement;
}

void ANTLRv4Parser::LabeledLexerElementContext::enterRule(
    tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ANTLRv4ParserListener *>(listener);
  if (parserListener != nullptr) parserListener->enterLabeledLexerElement(this);
}

void ANTLRv4Parser::LabeledLexerElementContext::exitRule(
    tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ANTLRv4ParserListener *>(listener);
  if (parserListener != nullptr) parserListener->exitLabeledLexerElement(this);
}

ANTLRv4Parser::LabeledLexerElementContext *
ANTLRv4Parser::labeledLexerElement() {
  LabeledLexerElementContext *_localctx =
      _tracker.createInstance<LabeledLexerElementContext>(_ctx, getState());
  enterRule(_localctx, 78, ANTLRv4Parser::RuleLabeledLexerElement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(421);
    identifier();
    setState(422);
    _la = _input->LA(1);
    if (!(_la == ANTLRv4Parser::ASSIGN

          || _la == ANTLRv4Parser::PLUS_ASSIGN)) {
      _errHandler->recoverInline(this);
    } else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(425);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case ANTLRv4Parser::TOKEN_REF:
      case ANTLRv4Parser::LEXER_CHAR_SET:
      case ANTLRv4Parser::STRING_LITERAL:
      case ANTLRv4Parser::DOT:
      case ANTLRv4Parser::NOT: {
        setState(423);
        lexerAtom();
        break;
      }

      case ANTLRv4Parser::LPAREN: {
        setState(424);
        lexerBlock();
        break;
      }

      default:
        throw NoViableAltException(this);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LexerBlockContext
//------------------------------------------------------------------

ANTLRv4Parser::LexerBlockContext::LexerBlockContext(ParserRuleContext *parent,
                                                    size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

tree::TerminalNode *ANTLRv4Parser::LexerBlockContext::LPAREN() {
  return getToken(ANTLRv4Parser::LPAREN, 0);
}

ANTLRv4Parser::LexerAltListContext *
ANTLRv4Parser::LexerBlockContext::lexerAltList() {
  return getRuleContext<ANTLRv4Parser::LexerAltListContext>(0);
}

tree::TerminalNode *ANTLRv4Parser::LexerBlockContext::RPAREN() {
  return getToken(ANTLRv4Parser::RPAREN, 0);
}

size_t ANTLRv4Parser::LexerBlockContext::getRuleIndex() const {
  return ANTLRv4Parser::RuleLexerBlock;
}

void ANTLRv4Parser::LexerBlockContext::enterRule(
    tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ANTLRv4ParserListener *>(listener);
  if (parserListener != nullptr) parserListener->enterLexerBlock(this);
}

void ANTLRv4Parser::LexerBlockContext::exitRule(
    tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ANTLRv4ParserListener *>(listener);
  if (parserListener != nullptr) parserListener->exitLexerBlock(this);
}

ANTLRv4Parser::LexerBlockContext *ANTLRv4Parser::lexerBlock() {
  LexerBlockContext *_localctx =
      _tracker.createInstance<LexerBlockContext>(_ctx, getState());
  enterRule(_localctx, 80, ANTLRv4Parser::RuleLexerBlock);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(427);
    match(ANTLRv4Parser::LPAREN);
    setState(428);
    lexerAltList();
    setState(429);
    match(ANTLRv4Parser::RPAREN);

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LexerCommandsContext
//------------------------------------------------------------------

ANTLRv4Parser::LexerCommandsContext::LexerCommandsContext(
    ParserRuleContext *parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

tree::TerminalNode *ANTLRv4Parser::LexerCommandsContext::RARROW() {
  return getToken(ANTLRv4Parser::RARROW, 0);
}

std::vector<ANTLRv4Parser::LexerCommandContext *>
ANTLRv4Parser::LexerCommandsContext::lexerCommand() {
  return getRuleContexts<ANTLRv4Parser::LexerCommandContext>();
}

ANTLRv4Parser::LexerCommandContext *
ANTLRv4Parser::LexerCommandsContext::lexerCommand(size_t i) {
  return getRuleContext<ANTLRv4Parser::LexerCommandContext>(i);
}

std::vector<tree::TerminalNode *> ANTLRv4Parser::LexerCommandsContext::COMMA() {
  return getTokens(ANTLRv4Parser::COMMA);
}

tree::TerminalNode *ANTLRv4Parser::LexerCommandsContext::COMMA(size_t i) {
  return getToken(ANTLRv4Parser::COMMA, i);
}

size_t ANTLRv4Parser::LexerCommandsContext::getRuleIndex() const {
  return ANTLRv4Parser::RuleLexerCommands;
}

void ANTLRv4Parser::LexerCommandsContext::enterRule(
    tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ANTLRv4ParserListener *>(listener);
  if (parserListener != nullptr) parserListener->enterLexerCommands(this);
}

void ANTLRv4Parser::LexerCommandsContext::exitRule(
    tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ANTLRv4ParserListener *>(listener);
  if (parserListener != nullptr) parserListener->exitLexerCommands(this);
}

ANTLRv4Parser::LexerCommandsContext *ANTLRv4Parser::lexerCommands() {
  LexerCommandsContext *_localctx =
      _tracker.createInstance<LexerCommandsContext>(_ctx, getState());
  enterRule(_localctx, 82, ANTLRv4Parser::RuleLexerCommands);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(431);
    match(ANTLRv4Parser::RARROW);
    setState(432);
    lexerCommand();
    setState(437);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == ANTLRv4Parser::COMMA) {
      setState(433);
      match(ANTLRv4Parser::COMMA);
      setState(434);
      lexerCommand();
      setState(439);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LexerCommandContext
//------------------------------------------------------------------

ANTLRv4Parser::LexerCommandContext::LexerCommandContext(
    ParserRuleContext *parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

ANTLRv4Parser::LexerCommandNameContext *
ANTLRv4Parser::LexerCommandContext::lexerCommandName() {
  return getRuleContext<ANTLRv4Parser::LexerCommandNameContext>(0);
}

tree::TerminalNode *ANTLRv4Parser::LexerCommandContext::LPAREN() {
  return getToken(ANTLRv4Parser::LPAREN, 0);
}

ANTLRv4Parser::LexerCommandExprContext *
ANTLRv4Parser::LexerCommandContext::lexerCommandExpr() {
  return getRuleContext<ANTLRv4Parser::LexerCommandExprContext>(0);
}

tree::TerminalNode *ANTLRv4Parser::LexerCommandContext::RPAREN() {
  return getToken(ANTLRv4Parser::RPAREN, 0);
}

size_t ANTLRv4Parser::LexerCommandContext::getRuleIndex() const {
  return ANTLRv4Parser::RuleLexerCommand;
}

void ANTLRv4Parser::LexerCommandContext::enterRule(
    tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ANTLRv4ParserListener *>(listener);
  if (parserListener != nullptr) parserListener->enterLexerCommand(this);
}

void ANTLRv4Parser::LexerCommandContext::exitRule(
    tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ANTLRv4ParserListener *>(listener);
  if (parserListener != nullptr) parserListener->exitLexerCommand(this);
}

ANTLRv4Parser::LexerCommandContext *ANTLRv4Parser::lexerCommand() {
  LexerCommandContext *_localctx =
      _tracker.createInstance<LexerCommandContext>(_ctx, getState());
  enterRule(_localctx, 84, ANTLRv4Parser::RuleLexerCommand);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(446);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(
        _input, 46, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(440);
        lexerCommandName();
        setState(441);
        match(ANTLRv4Parser::LPAREN);
        setState(442);
        lexerCommandExpr();
        setState(443);
        match(ANTLRv4Parser::RPAREN);
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(445);
        lexerCommandName();
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LexerCommandNameContext
//------------------------------------------------------------------

ANTLRv4Parser::LexerCommandNameContext::LexerCommandNameContext(
    ParserRuleContext *parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

ANTLRv4Parser::IdentifierContext *
ANTLRv4Parser::LexerCommandNameContext::identifier() {
  return getRuleContext<ANTLRv4Parser::IdentifierContext>(0);
}

tree::TerminalNode *ANTLRv4Parser::LexerCommandNameContext::MODE() {
  return getToken(ANTLRv4Parser::MODE, 0);
}

size_t ANTLRv4Parser::LexerCommandNameContext::getRuleIndex() const {
  return ANTLRv4Parser::RuleLexerCommandName;
}

void ANTLRv4Parser::LexerCommandNameContext::enterRule(
    tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ANTLRv4ParserListener *>(listener);
  if (parserListener != nullptr) parserListener->enterLexerCommandName(this);
}

void ANTLRv4Parser::LexerCommandNameContext::exitRule(
    tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ANTLRv4ParserListener *>(listener);
  if (parserListener != nullptr) parserListener->exitLexerCommandName(this);
}

ANTLRv4Parser::LexerCommandNameContext *ANTLRv4Parser::lexerCommandName() {
  LexerCommandNameContext *_localctx =
      _tracker.createInstance<LexerCommandNameContext>(_ctx, getState());
  enterRule(_localctx, 86, ANTLRv4Parser::RuleLexerCommandName);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(450);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case ANTLRv4Parser::TOKEN_REF:
      case ANTLRv4Parser::RULE_REF: {
        enterOuterAlt(_localctx, 1);
        setState(448);
        identifier();
        break;
      }

      case ANTLRv4Parser::MODE: {
        enterOuterAlt(_localctx, 2);
        setState(449);
        match(ANTLRv4Parser::MODE);
        break;
      }

      default:
        throw NoViableAltException(this);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LexerCommandExprContext
//------------------------------------------------------------------

ANTLRv4Parser::LexerCommandExprContext::LexerCommandExprContext(
    ParserRuleContext *parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

ANTLRv4Parser::IdentifierContext *
ANTLRv4Parser::LexerCommandExprContext::identifier() {
  return getRuleContext<ANTLRv4Parser::IdentifierContext>(0);
}

tree::TerminalNode *ANTLRv4Parser::LexerCommandExprContext::INT() {
  return getToken(ANTLRv4Parser::INT, 0);
}

size_t ANTLRv4Parser::LexerCommandExprContext::getRuleIndex() const {
  return ANTLRv4Parser::RuleLexerCommandExpr;
}

void ANTLRv4Parser::LexerCommandExprContext::enterRule(
    tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ANTLRv4ParserListener *>(listener);
  if (parserListener != nullptr) parserListener->enterLexerCommandExpr(this);
}

void ANTLRv4Parser::LexerCommandExprContext::exitRule(
    tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ANTLRv4ParserListener *>(listener);
  if (parserListener != nullptr) parserListener->exitLexerCommandExpr(this);
}

ANTLRv4Parser::LexerCommandExprContext *ANTLRv4Parser::lexerCommandExpr() {
  LexerCommandExprContext *_localctx =
      _tracker.createInstance<LexerCommandExprContext>(_ctx, getState());
  enterRule(_localctx, 88, ANTLRv4Parser::RuleLexerCommandExpr);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(454);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case ANTLRv4Parser::TOKEN_REF:
      case ANTLRv4Parser::RULE_REF: {
        enterOuterAlt(_localctx, 1);
        setState(452);
        identifier();
        break;
      }

      case ANTLRv4Parser::INT: {
        enterOuterAlt(_localctx, 2);
        setState(453);
        match(ANTLRv4Parser::INT);
        break;
      }

      default:
        throw NoViableAltException(this);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AltListContext
//------------------------------------------------------------------

ANTLRv4Parser::AltListContext::AltListContext(ParserRuleContext *parent,
                                              size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

std::vector<ANTLRv4Parser::AlternativeContext *>
ANTLRv4Parser::AltListContext::alternative() {
  return getRuleContexts<ANTLRv4Parser::AlternativeContext>();
}

ANTLRv4Parser::AlternativeContext *ANTLRv4Parser::AltListContext::alternative(
    size_t i) {
  return getRuleContext<ANTLRv4Parser::AlternativeContext>(i);
}

std::vector<tree::TerminalNode *> ANTLRv4Parser::AltListContext::OR() {
  return getTokens(ANTLRv4Parser::OR);
}

tree::TerminalNode *ANTLRv4Parser::AltListContext::OR(size_t i) {
  return getToken(ANTLRv4Parser::OR, i);
}

size_t ANTLRv4Parser::AltListContext::getRuleIndex() const {
  return ANTLRv4Parser::RuleAltList;
}

void ANTLRv4Parser::AltListContext::enterRule(
    tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ANTLRv4ParserListener *>(listener);
  if (parserListener != nullptr) parserListener->enterAltList(this);
}

void ANTLRv4Parser::AltListContext::exitRule(
    tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ANTLRv4ParserListener *>(listener);
  if (parserListener != nullptr) parserListener->exitAltList(this);
}

ANTLRv4Parser::AltListContext *ANTLRv4Parser::altList() {
  AltListContext *_localctx =
      _tracker.createInstance<AltListContext>(_ctx, getState());
  enterRule(_localctx, 90, ANTLRv4Parser::RuleAltList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(456);
    alternative();
    setState(461);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == ANTLRv4Parser::OR) {
      setState(457);
      match(ANTLRv4Parser::OR);
      setState(458);
      alternative();
      setState(463);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AlternativeContext
//------------------------------------------------------------------

ANTLRv4Parser::AlternativeContext::AlternativeContext(ParserRuleContext *parent,
                                                      size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

ANTLRv4Parser::ElementOptionsContext *
ANTLRv4Parser::AlternativeContext::elementOptions() {
  return getRuleContext<ANTLRv4Parser::ElementOptionsContext>(0);
}

std::vector<ANTLRv4Parser::ElementContext *>
ANTLRv4Parser::AlternativeContext::element() {
  return getRuleContexts<ANTLRv4Parser::ElementContext>();
}

ANTLRv4Parser::ElementContext *ANTLRv4Parser::AlternativeContext::element(
    size_t i) {
  return getRuleContext<ANTLRv4Parser::ElementContext>(i);
}

size_t ANTLRv4Parser::AlternativeContext::getRuleIndex() const {
  return ANTLRv4Parser::RuleAlternative;
}

void ANTLRv4Parser::AlternativeContext::enterRule(
    tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ANTLRv4ParserListener *>(listener);
  if (parserListener != nullptr) parserListener->enterAlternative(this);
}

void ANTLRv4Parser::AlternativeContext::exitRule(
    tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ANTLRv4ParserListener *>(listener);
  if (parserListener != nullptr) parserListener->exitAlternative(this);
}

ANTLRv4Parser::AlternativeContext *ANTLRv4Parser::alternative() {
  AlternativeContext *_localctx =
      _tracker.createInstance<AlternativeContext>(_ctx, getState());
  enterRule(_localctx, 92, ANTLRv4Parser::RuleAlternative);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(473);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case ANTLRv4Parser::TOKEN_REF:
      case ANTLRv4Parser::RULE_REF:
      case ANTLRv4Parser::STRING_LITERAL:
      case ANTLRv4Parser::BEGIN_ACTION:
      case ANTLRv4Parser::LPAREN:
      case ANTLRv4Parser::LT:
      case ANTLRv4Parser::DOT:
      case ANTLRv4Parser::NOT: {
        enterOuterAlt(_localctx, 1);
        setState(465);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == ANTLRv4Parser::LT) {
          setState(464);
          elementOptions();
        }
        setState(468);
        _errHandler->sync(this);
        _la = _input->LA(1);
        do {
          setState(467);
          element();
          setState(470);
          _errHandler->sync(this);
          _la = _input->LA(1);
        } while ((((_la & ~0x3fULL) == 0) &&
                  ((1ULL << _la) & 2533283380332806) != 0));
        break;
      }

      case ANTLRv4Parser::SEMI:
      case ANTLRv4Parser::RPAREN:
      case ANTLRv4Parser::OR:
      case ANTLRv4Parser::POUND: {
        enterOuterAlt(_localctx, 2);

        break;
      }

      default:
        throw NoViableAltException(this);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ElementContext
//------------------------------------------------------------------

ANTLRv4Parser::ElementContext::ElementContext(ParserRuleContext *parent,
                                              size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

ANTLRv4Parser::LabeledElementContext *
ANTLRv4Parser::ElementContext::labeledElement() {
  return getRuleContext<ANTLRv4Parser::LabeledElementContext>(0);
}

ANTLRv4Parser::EbnfSuffixContext *ANTLRv4Parser::ElementContext::ebnfSuffix() {
  return getRuleContext<ANTLRv4Parser::EbnfSuffixContext>(0);
}

ANTLRv4Parser::AtomContext *ANTLRv4Parser::ElementContext::atom() {
  return getRuleContext<ANTLRv4Parser::AtomContext>(0);
}

ANTLRv4Parser::EbnfContext *ANTLRv4Parser::ElementContext::ebnf() {
  return getRuleContext<ANTLRv4Parser::EbnfContext>(0);
}

ANTLRv4Parser::ActionBlockContext *
ANTLRv4Parser::ElementContext::actionBlock() {
  return getRuleContext<ANTLRv4Parser::ActionBlockContext>(0);
}

tree::TerminalNode *ANTLRv4Parser::ElementContext::QUESTION() {
  return getToken(ANTLRv4Parser::QUESTION, 0);
}

size_t ANTLRv4Parser::ElementContext::getRuleIndex() const {
  return ANTLRv4Parser::RuleElement;
}

void ANTLRv4Parser::ElementContext::enterRule(
    tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ANTLRv4ParserListener *>(listener);
  if (parserListener != nullptr) parserListener->enterElement(this);
}

void ANTLRv4Parser::ElementContext::exitRule(
    tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ANTLRv4ParserListener *>(listener);
  if (parserListener != nullptr) parserListener->exitElement(this);
}

ANTLRv4Parser::ElementContext *ANTLRv4Parser::element() {
  ElementContext *_localctx =
      _tracker.createInstance<ElementContext>(_ctx, getState());
  enterRule(_localctx, 94, ANTLRv4Parser::RuleElement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(490);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(
        _input, 56, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(475);
        labeledElement();
        setState(478);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case ANTLRv4Parser::QUESTION:
          case ANTLRv4Parser::STAR:
          case ANTLRv4Parser::PLUS: {
            setState(476);
            ebnfSuffix();
            break;
          }

          case ANTLRv4Parser::TOKEN_REF:
          case ANTLRv4Parser::RULE_REF:
          case ANTLRv4Parser::STRING_LITERAL:
          case ANTLRv4Parser::BEGIN_ACTION:
          case ANTLRv4Parser::SEMI:
          case ANTLRv4Parser::LPAREN:
          case ANTLRv4Parser::RPAREN:
          case ANTLRv4Parser::OR:
          case ANTLRv4Parser::DOT:
          case ANTLRv4Parser::POUND:
          case ANTLRv4Parser::NOT: {
            break;
          }

          default:
            throw NoViableAltException(this);
        }
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(480);
        atom();
        setState(483);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case ANTLRv4Parser::QUESTION:
          case ANTLRv4Parser::STAR:
          case ANTLRv4Parser::PLUS: {
            setState(481);
            ebnfSuffix();
            break;
          }

          case ANTLRv4Parser::TOKEN_REF:
          case ANTLRv4Parser::RULE_REF:
          case ANTLRv4Parser::STRING_LITERAL:
          case ANTLRv4Parser::BEGIN_ACTION:
          case ANTLRv4Parser::SEMI:
          case ANTLRv4Parser::LPAREN:
          case ANTLRv4Parser::RPAREN:
          case ANTLRv4Parser::OR:
          case ANTLRv4Parser::DOT:
          case ANTLRv4Parser::POUND:
          case ANTLRv4Parser::NOT: {
            break;
          }

          default:
            throw NoViableAltException(this);
        }
        break;
      }

      case 3: {
        enterOuterAlt(_localctx, 3);
        setState(485);
        ebnf();
        break;
      }

      case 4: {
        enterOuterAlt(_localctx, 4);
        setState(486);
        actionBlock();
        setState(488);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == ANTLRv4Parser::QUESTION) {
          setState(487);
          match(ANTLRv4Parser::QUESTION);
        }
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LabeledElementContext
//------------------------------------------------------------------

ANTLRv4Parser::LabeledElementContext::LabeledElementContext(
    ParserRuleContext *parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

ANTLRv4Parser::IdentifierContext *
ANTLRv4Parser::LabeledElementContext::identifier() {
  return getRuleContext<ANTLRv4Parser::IdentifierContext>(0);
}

tree::TerminalNode *ANTLRv4Parser::LabeledElementContext::ASSIGN() {
  return getToken(ANTLRv4Parser::ASSIGN, 0);
}

tree::TerminalNode *ANTLRv4Parser::LabeledElementContext::PLUS_ASSIGN() {
  return getToken(ANTLRv4Parser::PLUS_ASSIGN, 0);
}

ANTLRv4Parser::AtomContext *ANTLRv4Parser::LabeledElementContext::atom() {
  return getRuleContext<ANTLRv4Parser::AtomContext>(0);
}

ANTLRv4Parser::BlockContext *ANTLRv4Parser::LabeledElementContext::block() {
  return getRuleContext<ANTLRv4Parser::BlockContext>(0);
}

size_t ANTLRv4Parser::LabeledElementContext::getRuleIndex() const {
  return ANTLRv4Parser::RuleLabeledElement;
}

void ANTLRv4Parser::LabeledElementContext::enterRule(
    tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ANTLRv4ParserListener *>(listener);
  if (parserListener != nullptr) parserListener->enterLabeledElement(this);
}

void ANTLRv4Parser::LabeledElementContext::exitRule(
    tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ANTLRv4ParserListener *>(listener);
  if (parserListener != nullptr) parserListener->exitLabeledElement(this);
}

ANTLRv4Parser::LabeledElementContext *ANTLRv4Parser::labeledElement() {
  LabeledElementContext *_localctx =
      _tracker.createInstance<LabeledElementContext>(_ctx, getState());
  enterRule(_localctx, 96, ANTLRv4Parser::RuleLabeledElement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(492);
    identifier();
    setState(493);
    _la = _input->LA(1);
    if (!(_la == ANTLRv4Parser::ASSIGN

          || _la == ANTLRv4Parser::PLUS_ASSIGN)) {
      _errHandler->recoverInline(this);
    } else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(496);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case ANTLRv4Parser::TOKEN_REF:
      case ANTLRv4Parser::RULE_REF:
      case ANTLRv4Parser::STRING_LITERAL:
      case ANTLRv4Parser::DOT:
      case ANTLRv4Parser::NOT: {
        setState(494);
        atom();
        break;
      }

      case ANTLRv4Parser::LPAREN: {
        setState(495);
        block();
        break;
      }

      default:
        throw NoViableAltException(this);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EbnfContext
//------------------------------------------------------------------

ANTLRv4Parser::EbnfContext::EbnfContext(ParserRuleContext *parent,
                                        size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

ANTLRv4Parser::BlockContext *ANTLRv4Parser::EbnfContext::block() {
  return getRuleContext<ANTLRv4Parser::BlockContext>(0);
}

ANTLRv4Parser::BlockSuffixContext *ANTLRv4Parser::EbnfContext::blockSuffix() {
  return getRuleContext<ANTLRv4Parser::BlockSuffixContext>(0);
}

size_t ANTLRv4Parser::EbnfContext::getRuleIndex() const {
  return ANTLRv4Parser::RuleEbnf;
}

void ANTLRv4Parser::EbnfContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ANTLRv4ParserListener *>(listener);
  if (parserListener != nullptr) parserListener->enterEbnf(this);
}

void ANTLRv4Parser::EbnfContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ANTLRv4ParserListener *>(listener);
  if (parserListener != nullptr) parserListener->exitEbnf(this);
}

ANTLRv4Parser::EbnfContext *ANTLRv4Parser::ebnf() {
  EbnfContext *_localctx =
      _tracker.createInstance<EbnfContext>(_ctx, getState());
  enterRule(_localctx, 98, ANTLRv4Parser::RuleEbnf);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(498);
    block();
    setState(500);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~0x3fULL) == 0) && ((1ULL << _la) & 24189255811072) != 0)) {
      setState(499);
      blockSuffix();
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BlockSuffixContext
//------------------------------------------------------------------

ANTLRv4Parser::BlockSuffixContext::BlockSuffixContext(ParserRuleContext *parent,
                                                      size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

ANTLRv4Parser::EbnfSuffixContext *
ANTLRv4Parser::BlockSuffixContext::ebnfSuffix() {
  return getRuleContext<ANTLRv4Parser::EbnfSuffixContext>(0);
}

size_t ANTLRv4Parser::BlockSuffixContext::getRuleIndex() const {
  return ANTLRv4Parser::RuleBlockSuffix;
}

void ANTLRv4Parser::BlockSuffixContext::enterRule(
    tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ANTLRv4ParserListener *>(listener);
  if (parserListener != nullptr) parserListener->enterBlockSuffix(this);
}

void ANTLRv4Parser::BlockSuffixContext::exitRule(
    tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ANTLRv4ParserListener *>(listener);
  if (parserListener != nullptr) parserListener->exitBlockSuffix(this);
}

ANTLRv4Parser::BlockSuffixContext *ANTLRv4Parser::blockSuffix() {
  BlockSuffixContext *_localctx =
      _tracker.createInstance<BlockSuffixContext>(_ctx, getState());
  enterRule(_localctx, 100, ANTLRv4Parser::RuleBlockSuffix);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(502);
    ebnfSuffix();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EbnfSuffixContext
//------------------------------------------------------------------

ANTLRv4Parser::EbnfSuffixContext::EbnfSuffixContext(ParserRuleContext *parent,
                                                    size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

std::vector<tree::TerminalNode *> ANTLRv4Parser::EbnfSuffixContext::QUESTION() {
  return getTokens(ANTLRv4Parser::QUESTION);
}

tree::TerminalNode *ANTLRv4Parser::EbnfSuffixContext::QUESTION(size_t i) {
  return getToken(ANTLRv4Parser::QUESTION, i);
}

tree::TerminalNode *ANTLRv4Parser::EbnfSuffixContext::STAR() {
  return getToken(ANTLRv4Parser::STAR, 0);
}

tree::TerminalNode *ANTLRv4Parser::EbnfSuffixContext::PLUS() {
  return getToken(ANTLRv4Parser::PLUS, 0);
}

size_t ANTLRv4Parser::EbnfSuffixContext::getRuleIndex() const {
  return ANTLRv4Parser::RuleEbnfSuffix;
}

void ANTLRv4Parser::EbnfSuffixContext::enterRule(
    tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ANTLRv4ParserListener *>(listener);
  if (parserListener != nullptr) parserListener->enterEbnfSuffix(this);
}

void ANTLRv4Parser::EbnfSuffixContext::exitRule(
    tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ANTLRv4ParserListener *>(listener);
  if (parserListener != nullptr) parserListener->exitEbnfSuffix(this);
}

ANTLRv4Parser::EbnfSuffixContext *ANTLRv4Parser::ebnfSuffix() {
  EbnfSuffixContext *_localctx =
      _tracker.createInstance<EbnfSuffixContext>(_ctx, getState());
  enterRule(_localctx, 102, ANTLRv4Parser::RuleEbnfSuffix);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(516);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case ANTLRv4Parser::QUESTION: {
        enterOuterAlt(_localctx, 1);
        setState(504);
        match(ANTLRv4Parser::QUESTION);
        setState(506);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == ANTLRv4Parser::QUESTION) {
          setState(505);
          match(ANTLRv4Parser::QUESTION);
        }
        break;
      }

      case ANTLRv4Parser::STAR: {
        enterOuterAlt(_localctx, 2);
        setState(508);
        match(ANTLRv4Parser::STAR);
        setState(510);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == ANTLRv4Parser::QUESTION) {
          setState(509);
          match(ANTLRv4Parser::QUESTION);
        }
        break;
      }

      case ANTLRv4Parser::PLUS: {
        enterOuterAlt(_localctx, 3);
        setState(512);
        match(ANTLRv4Parser::PLUS);
        setState(514);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == ANTLRv4Parser::QUESTION) {
          setState(513);
          match(ANTLRv4Parser::QUESTION);
        }
        break;
      }

      default:
        throw NoViableAltException(this);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LexerAtomContext
//------------------------------------------------------------------

ANTLRv4Parser::LexerAtomContext::LexerAtomContext(ParserRuleContext *parent,
                                                  size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

ANTLRv4Parser::CharacterRangeContext *
ANTLRv4Parser::LexerAtomContext::characterRange() {
  return getRuleContext<ANTLRv4Parser::CharacterRangeContext>(0);
}

ANTLRv4Parser::TerminalContext *ANTLRv4Parser::LexerAtomContext::terminal() {
  return getRuleContext<ANTLRv4Parser::TerminalContext>(0);
}

ANTLRv4Parser::NotSetContext *ANTLRv4Parser::LexerAtomContext::notSet() {
  return getRuleContext<ANTLRv4Parser::NotSetContext>(0);
}

tree::TerminalNode *ANTLRv4Parser::LexerAtomContext::LEXER_CHAR_SET() {
  return getToken(ANTLRv4Parser::LEXER_CHAR_SET, 0);
}

tree::TerminalNode *ANTLRv4Parser::LexerAtomContext::DOT() {
  return getToken(ANTLRv4Parser::DOT, 0);
}

ANTLRv4Parser::ElementOptionsContext *
ANTLRv4Parser::LexerAtomContext::elementOptions() {
  return getRuleContext<ANTLRv4Parser::ElementOptionsContext>(0);
}

size_t ANTLRv4Parser::LexerAtomContext::getRuleIndex() const {
  return ANTLRv4Parser::RuleLexerAtom;
}

void ANTLRv4Parser::LexerAtomContext::enterRule(
    tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ANTLRv4ParserListener *>(listener);
  if (parserListener != nullptr) parserListener->enterLexerAtom(this);
}

void ANTLRv4Parser::LexerAtomContext::exitRule(
    tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ANTLRv4ParserListener *>(listener);
  if (parserListener != nullptr) parserListener->exitLexerAtom(this);
}

ANTLRv4Parser::LexerAtomContext *ANTLRv4Parser::lexerAtom() {
  LexerAtomContext *_localctx =
      _tracker.createInstance<LexerAtomContext>(_ctx, getState());
  enterRule(_localctx, 104, ANTLRv4Parser::RuleLexerAtom);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(526);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(
        _input, 64, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(518);
        characterRange();
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(519);
        terminal();
        break;
      }

      case 3: {
        enterOuterAlt(_localctx, 3);
        setState(520);
        notSet();
        break;
      }

      case 4: {
        enterOuterAlt(_localctx, 4);
        setState(521);
        match(ANTLRv4Parser::LEXER_CHAR_SET);
        break;
      }

      case 5: {
        enterOuterAlt(_localctx, 5);
        setState(522);
        match(ANTLRv4Parser::DOT);
        setState(524);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == ANTLRv4Parser::LT) {
          setState(523);
          elementOptions();
        }
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AtomContext
//------------------------------------------------------------------

ANTLRv4Parser::AtomContext::AtomContext(ParserRuleContext *parent,
                                        size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

ANTLRv4Parser::TerminalContext *ANTLRv4Parser::AtomContext::terminal() {
  return getRuleContext<ANTLRv4Parser::TerminalContext>(0);
}

ANTLRv4Parser::RulerefContext *ANTLRv4Parser::AtomContext::ruleref() {
  return getRuleContext<ANTLRv4Parser::RulerefContext>(0);
}

ANTLRv4Parser::NotSetContext *ANTLRv4Parser::AtomContext::notSet() {
  return getRuleContext<ANTLRv4Parser::NotSetContext>(0);
}

tree::TerminalNode *ANTLRv4Parser::AtomContext::DOT() {
  return getToken(ANTLRv4Parser::DOT, 0);
}

ANTLRv4Parser::ElementOptionsContext *
ANTLRv4Parser::AtomContext::elementOptions() {
  return getRuleContext<ANTLRv4Parser::ElementOptionsContext>(0);
}

size_t ANTLRv4Parser::AtomContext::getRuleIndex() const {
  return ANTLRv4Parser::RuleAtom;
}

void ANTLRv4Parser::AtomContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ANTLRv4ParserListener *>(listener);
  if (parserListener != nullptr) parserListener->enterAtom(this);
}

void ANTLRv4Parser::AtomContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ANTLRv4ParserListener *>(listener);
  if (parserListener != nullptr) parserListener->exitAtom(this);
}

ANTLRv4Parser::AtomContext *ANTLRv4Parser::atom() {
  AtomContext *_localctx =
      _tracker.createInstance<AtomContext>(_ctx, getState());
  enterRule(_localctx, 106, ANTLRv4Parser::RuleAtom);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(535);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case ANTLRv4Parser::TOKEN_REF:
      case ANTLRv4Parser::STRING_LITERAL: {
        enterOuterAlt(_localctx, 1);
        setState(528);
        terminal();
        break;
      }

      case ANTLRv4Parser::RULE_REF: {
        enterOuterAlt(_localctx, 2);
        setState(529);
        ruleref();
        break;
      }

      case ANTLRv4Parser::NOT: {
        enterOuterAlt(_localctx, 3);
        setState(530);
        notSet();
        break;
      }

      case ANTLRv4Parser::DOT: {
        enterOuterAlt(_localctx, 4);
        setState(531);
        match(ANTLRv4Parser::DOT);
        setState(533);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == ANTLRv4Parser::LT) {
          setState(532);
          elementOptions();
        }
        break;
      }

      default:
        throw NoViableAltException(this);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NotSetContext
//------------------------------------------------------------------

ANTLRv4Parser::NotSetContext::NotSetContext(ParserRuleContext *parent,
                                            size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

tree::TerminalNode *ANTLRv4Parser::NotSetContext::NOT() {
  return getToken(ANTLRv4Parser::NOT, 0);
}

ANTLRv4Parser::SetElementContext *ANTLRv4Parser::NotSetContext::setElement() {
  return getRuleContext<ANTLRv4Parser::SetElementContext>(0);
}

ANTLRv4Parser::BlockSetContext *ANTLRv4Parser::NotSetContext::blockSet() {
  return getRuleContext<ANTLRv4Parser::BlockSetContext>(0);
}

size_t ANTLRv4Parser::NotSetContext::getRuleIndex() const {
  return ANTLRv4Parser::RuleNotSet;
}

void ANTLRv4Parser::NotSetContext::enterRule(
    tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ANTLRv4ParserListener *>(listener);
  if (parserListener != nullptr) parserListener->enterNotSet(this);
}

void ANTLRv4Parser::NotSetContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ANTLRv4ParserListener *>(listener);
  if (parserListener != nullptr) parserListener->exitNotSet(this);
}

ANTLRv4Parser::NotSetContext *ANTLRv4Parser::notSet() {
  NotSetContext *_localctx =
      _tracker.createInstance<NotSetContext>(_ctx, getState());
  enterRule(_localctx, 108, ANTLRv4Parser::RuleNotSet);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(541);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(
        _input, 67, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(537);
        match(ANTLRv4Parser::NOT);
        setState(538);
        setElement();
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(539);
        match(ANTLRv4Parser::NOT);
        setState(540);
        blockSet();
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BlockSetContext
//------------------------------------------------------------------

ANTLRv4Parser::BlockSetContext::BlockSetContext(ParserRuleContext *parent,
                                                size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

tree::TerminalNode *ANTLRv4Parser::BlockSetContext::LPAREN() {
  return getToken(ANTLRv4Parser::LPAREN, 0);
}

std::vector<ANTLRv4Parser::SetElementContext *>
ANTLRv4Parser::BlockSetContext::setElement() {
  return getRuleContexts<ANTLRv4Parser::SetElementContext>();
}

ANTLRv4Parser::SetElementContext *ANTLRv4Parser::BlockSetContext::setElement(
    size_t i) {
  return getRuleContext<ANTLRv4Parser::SetElementContext>(i);
}

tree::TerminalNode *ANTLRv4Parser::BlockSetContext::RPAREN() {
  return getToken(ANTLRv4Parser::RPAREN, 0);
}

std::vector<tree::TerminalNode *> ANTLRv4Parser::BlockSetContext::OR() {
  return getTokens(ANTLRv4Parser::OR);
}

tree::TerminalNode *ANTLRv4Parser::BlockSetContext::OR(size_t i) {
  return getToken(ANTLRv4Parser::OR, i);
}

size_t ANTLRv4Parser::BlockSetContext::getRuleIndex() const {
  return ANTLRv4Parser::RuleBlockSet;
}

void ANTLRv4Parser::BlockSetContext::enterRule(
    tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ANTLRv4ParserListener *>(listener);
  if (parserListener != nullptr) parserListener->enterBlockSet(this);
}

void ANTLRv4Parser::BlockSetContext::exitRule(
    tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ANTLRv4ParserListener *>(listener);
  if (parserListener != nullptr) parserListener->exitBlockSet(this);
}

ANTLRv4Parser::BlockSetContext *ANTLRv4Parser::blockSet() {
  BlockSetContext *_localctx =
      _tracker.createInstance<BlockSetContext>(_ctx, getState());
  enterRule(_localctx, 110, ANTLRv4Parser::RuleBlockSet);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(543);
    match(ANTLRv4Parser::LPAREN);
    setState(544);
    setElement();
    setState(549);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == ANTLRv4Parser::OR) {
      setState(545);
      match(ANTLRv4Parser::OR);
      setState(546);
      setElement();
      setState(551);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(552);
    match(ANTLRv4Parser::RPAREN);

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SetElementContext
//------------------------------------------------------------------

ANTLRv4Parser::SetElementContext::SetElementContext(ParserRuleContext *parent,
                                                    size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

tree::TerminalNode *ANTLRv4Parser::SetElementContext::TOKEN_REF() {
  return getToken(ANTLRv4Parser::TOKEN_REF, 0);
}

ANTLRv4Parser::ElementOptionsContext *
ANTLRv4Parser::SetElementContext::elementOptions() {
  return getRuleContext<ANTLRv4Parser::ElementOptionsContext>(0);
}

tree::TerminalNode *ANTLRv4Parser::SetElementContext::STRING_LITERAL() {
  return getToken(ANTLRv4Parser::STRING_LITERAL, 0);
}

ANTLRv4Parser::CharacterRangeContext *
ANTLRv4Parser::SetElementContext::characterRange() {
  return getRuleContext<ANTLRv4Parser::CharacterRangeContext>(0);
}

tree::TerminalNode *ANTLRv4Parser::SetElementContext::LEXER_CHAR_SET() {
  return getToken(ANTLRv4Parser::LEXER_CHAR_SET, 0);
}

size_t ANTLRv4Parser::SetElementContext::getRuleIndex() const {
  return ANTLRv4Parser::RuleSetElement;
}

void ANTLRv4Parser::SetElementContext::enterRule(
    tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ANTLRv4ParserListener *>(listener);
  if (parserListener != nullptr) parserListener->enterSetElement(this);
}

void ANTLRv4Parser::SetElementContext::exitRule(
    tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ANTLRv4ParserListener *>(listener);
  if (parserListener != nullptr) parserListener->exitSetElement(this);
}

ANTLRv4Parser::SetElementContext *ANTLRv4Parser::setElement() {
  SetElementContext *_localctx =
      _tracker.createInstance<SetElementContext>(_ctx, getState());
  enterRule(_localctx, 112, ANTLRv4Parser::RuleSetElement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(564);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(
        _input, 71, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(554);
        match(ANTLRv4Parser::TOKEN_REF);
        setState(556);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == ANTLRv4Parser::LT) {
          setState(555);
          elementOptions();
        }
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(558);
        match(ANTLRv4Parser::STRING_LITERAL);
        setState(560);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == ANTLRv4Parser::LT) {
          setState(559);
          elementOptions();
        }
        break;
      }

      case 3: {
        enterOuterAlt(_localctx, 3);
        setState(562);
        characterRange();
        break;
      }

      case 4: {
        enterOuterAlt(_localctx, 4);
        setState(563);
        match(ANTLRv4Parser::LEXER_CHAR_SET);
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BlockContext
//------------------------------------------------------------------

ANTLRv4Parser::BlockContext::BlockContext(ParserRuleContext *parent,
                                          size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

tree::TerminalNode *ANTLRv4Parser::BlockContext::LPAREN() {
  return getToken(ANTLRv4Parser::LPAREN, 0);
}

ANTLRv4Parser::AltListContext *ANTLRv4Parser::BlockContext::altList() {
  return getRuleContext<ANTLRv4Parser::AltListContext>(0);
}

tree::TerminalNode *ANTLRv4Parser::BlockContext::RPAREN() {
  return getToken(ANTLRv4Parser::RPAREN, 0);
}

tree::TerminalNode *ANTLRv4Parser::BlockContext::COLON() {
  return getToken(ANTLRv4Parser::COLON, 0);
}

ANTLRv4Parser::OptionsSpecContext *ANTLRv4Parser::BlockContext::optionsSpec() {
  return getRuleContext<ANTLRv4Parser::OptionsSpecContext>(0);
}

std::vector<ANTLRv4Parser::RuleActionContext *>
ANTLRv4Parser::BlockContext::ruleAction() {
  return getRuleContexts<ANTLRv4Parser::RuleActionContext>();
}

ANTLRv4Parser::RuleActionContext *ANTLRv4Parser::BlockContext::ruleAction(
    size_t i) {
  return getRuleContext<ANTLRv4Parser::RuleActionContext>(i);
}

size_t ANTLRv4Parser::BlockContext::getRuleIndex() const {
  return ANTLRv4Parser::RuleBlock;
}

void ANTLRv4Parser::BlockContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ANTLRv4ParserListener *>(listener);
  if (parserListener != nullptr) parserListener->enterBlock(this);
}

void ANTLRv4Parser::BlockContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ANTLRv4ParserListener *>(listener);
  if (parserListener != nullptr) parserListener->exitBlock(this);
}

ANTLRv4Parser::BlockContext *ANTLRv4Parser::block() {
  BlockContext *_localctx =
      _tracker.createInstance<BlockContext>(_ctx, getState());
  enterRule(_localctx, 114, ANTLRv4Parser::RuleBlock);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(566);
    match(ANTLRv4Parser::LPAREN);
    setState(577);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~0x3fULL) == 0) && ((1ULL << _la) & 562950490296320) != 0)) {
      setState(568);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == ANTLRv4Parser::OPTIONS) {
        setState(567);
        optionsSpec();
      }
      setState(573);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == ANTLRv4Parser::AT) {
        setState(570);
        ruleAction();
        setState(575);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(576);
      match(ANTLRv4Parser::COLON);
    }
    setState(579);
    altList();
    setState(580);
    match(ANTLRv4Parser::RPAREN);

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RulerefContext
//------------------------------------------------------------------

ANTLRv4Parser::RulerefContext::RulerefContext(ParserRuleContext *parent,
                                              size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

tree::TerminalNode *ANTLRv4Parser::RulerefContext::RULE_REF() {
  return getToken(ANTLRv4Parser::RULE_REF, 0);
}

ANTLRv4Parser::ArgActionBlockContext *
ANTLRv4Parser::RulerefContext::argActionBlock() {
  return getRuleContext<ANTLRv4Parser::ArgActionBlockContext>(0);
}

ANTLRv4Parser::ElementOptionsContext *
ANTLRv4Parser::RulerefContext::elementOptions() {
  return getRuleContext<ANTLRv4Parser::ElementOptionsContext>(0);
}

size_t ANTLRv4Parser::RulerefContext::getRuleIndex() const {
  return ANTLRv4Parser::RuleRuleref;
}

void ANTLRv4Parser::RulerefContext::enterRule(
    tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ANTLRv4ParserListener *>(listener);
  if (parserListener != nullptr) parserListener->enterRuleref(this);
}

void ANTLRv4Parser::RulerefContext::exitRule(
    tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ANTLRv4ParserListener *>(listener);
  if (parserListener != nullptr) parserListener->exitRuleref(this);
}

ANTLRv4Parser::RulerefContext *ANTLRv4Parser::ruleref() {
  RulerefContext *_localctx =
      _tracker.createInstance<RulerefContext>(_ctx, getState());
  enterRule(_localctx, 116, ANTLRv4Parser::RuleRuleref);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(582);
    match(ANTLRv4Parser::RULE_REF);
    setState(584);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ANTLRv4Parser::BEGIN_ARGUMENT) {
      setState(583);
      argActionBlock();
    }
    setState(587);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ANTLRv4Parser::LT) {
      setState(586);
      elementOptions();
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CharacterRangeContext
//------------------------------------------------------------------

ANTLRv4Parser::CharacterRangeContext::CharacterRangeContext(
    ParserRuleContext *parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

std::vector<tree::TerminalNode *>
ANTLRv4Parser::CharacterRangeContext::STRING_LITERAL() {
  return getTokens(ANTLRv4Parser::STRING_LITERAL);
}

tree::TerminalNode *ANTLRv4Parser::CharacterRangeContext::STRING_LITERAL(
    size_t i) {
  return getToken(ANTLRv4Parser::STRING_LITERAL, i);
}

tree::TerminalNode *ANTLRv4Parser::CharacterRangeContext::RANGE() {
  return getToken(ANTLRv4Parser::RANGE, 0);
}

size_t ANTLRv4Parser::CharacterRangeContext::getRuleIndex() const {
  return ANTLRv4Parser::RuleCharacterRange;
}

void ANTLRv4Parser::CharacterRangeContext::enterRule(
    tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ANTLRv4ParserListener *>(listener);
  if (parserListener != nullptr) parserListener->enterCharacterRange(this);
}

void ANTLRv4Parser::CharacterRangeContext::exitRule(
    tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ANTLRv4ParserListener *>(listener);
  if (parserListener != nullptr) parserListener->exitCharacterRange(this);
}

ANTLRv4Parser::CharacterRangeContext *ANTLRv4Parser::characterRange() {
  CharacterRangeContext *_localctx =
      _tracker.createInstance<CharacterRangeContext>(_ctx, getState());
  enterRule(_localctx, 118, ANTLRv4Parser::RuleCharacterRange);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(589);
    match(ANTLRv4Parser::STRING_LITERAL);
    setState(590);
    match(ANTLRv4Parser::RANGE);
    setState(591);
    match(ANTLRv4Parser::STRING_LITERAL);

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TerminalContext
//------------------------------------------------------------------

ANTLRv4Parser::TerminalContext::TerminalContext(ParserRuleContext *parent,
                                                size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

tree::TerminalNode *ANTLRv4Parser::TerminalContext::TOKEN_REF() {
  return getToken(ANTLRv4Parser::TOKEN_REF, 0);
}

ANTLRv4Parser::ElementOptionsContext *
ANTLRv4Parser::TerminalContext::elementOptions() {
  return getRuleContext<ANTLRv4Parser::ElementOptionsContext>(0);
}

tree::TerminalNode *ANTLRv4Parser::TerminalContext::STRING_LITERAL() {
  return getToken(ANTLRv4Parser::STRING_LITERAL, 0);
}

size_t ANTLRv4Parser::TerminalContext::getRuleIndex() const {
  return ANTLRv4Parser::RuleTerminal;
}

void ANTLRv4Parser::TerminalContext::enterRule(
    tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ANTLRv4ParserListener *>(listener);
  if (parserListener != nullptr) parserListener->enterTerminal(this);
}

void ANTLRv4Parser::TerminalContext::exitRule(
    tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ANTLRv4ParserListener *>(listener);
  if (parserListener != nullptr) parserListener->exitTerminal(this);
}

ANTLRv4Parser::TerminalContext *ANTLRv4Parser::terminal() {
  TerminalContext *_localctx =
      _tracker.createInstance<TerminalContext>(_ctx, getState());
  enterRule(_localctx, 120, ANTLRv4Parser::RuleTerminal);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(601);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case ANTLRv4Parser::TOKEN_REF: {
        enterOuterAlt(_localctx, 1);
        setState(593);
        match(ANTLRv4Parser::TOKEN_REF);
        setState(595);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == ANTLRv4Parser::LT) {
          setState(594);
          elementOptions();
        }
        break;
      }

      case ANTLRv4Parser::STRING_LITERAL: {
        enterOuterAlt(_localctx, 2);
        setState(597);
        match(ANTLRv4Parser::STRING_LITERAL);
        setState(599);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == ANTLRv4Parser::LT) {
          setState(598);
          elementOptions();
        }
        break;
      }

      default:
        throw NoViableAltException(this);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ElementOptionsContext
//------------------------------------------------------------------

ANTLRv4Parser::ElementOptionsContext::ElementOptionsContext(
    ParserRuleContext *parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

tree::TerminalNode *ANTLRv4Parser::ElementOptionsContext::LT() {
  return getToken(ANTLRv4Parser::LT, 0);
}

std::vector<ANTLRv4Parser::ElementOptionContext *>
ANTLRv4Parser::ElementOptionsContext::elementOption() {
  return getRuleContexts<ANTLRv4Parser::ElementOptionContext>();
}

ANTLRv4Parser::ElementOptionContext *
ANTLRv4Parser::ElementOptionsContext::elementOption(size_t i) {
  return getRuleContext<ANTLRv4Parser::ElementOptionContext>(i);
}

tree::TerminalNode *ANTLRv4Parser::ElementOptionsContext::GT() {
  return getToken(ANTLRv4Parser::GT, 0);
}

std::vector<tree::TerminalNode *>
ANTLRv4Parser::ElementOptionsContext::COMMA() {
  return getTokens(ANTLRv4Parser::COMMA);
}

tree::TerminalNode *ANTLRv4Parser::ElementOptionsContext::COMMA(size_t i) {
  return getToken(ANTLRv4Parser::COMMA, i);
}

size_t ANTLRv4Parser::ElementOptionsContext::getRuleIndex() const {
  return ANTLRv4Parser::RuleElementOptions;
}

void ANTLRv4Parser::ElementOptionsContext::enterRule(
    tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ANTLRv4ParserListener *>(listener);
  if (parserListener != nullptr) parserListener->enterElementOptions(this);
}

void ANTLRv4Parser::ElementOptionsContext::exitRule(
    tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ANTLRv4ParserListener *>(listener);
  if (parserListener != nullptr) parserListener->exitElementOptions(this);
}

ANTLRv4Parser::ElementOptionsContext *ANTLRv4Parser::elementOptions() {
  ElementOptionsContext *_localctx =
      _tracker.createInstance<ElementOptionsContext>(_ctx, getState());
  enterRule(_localctx, 122, ANTLRv4Parser::RuleElementOptions);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(603);
    match(ANTLRv4Parser::LT);
    setState(604);
    elementOption();
    setState(609);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == ANTLRv4Parser::COMMA) {
      setState(605);
      match(ANTLRv4Parser::COMMA);
      setState(606);
      elementOption();
      setState(611);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(612);
    match(ANTLRv4Parser::GT);

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ElementOptionContext
//------------------------------------------------------------------

ANTLRv4Parser::ElementOptionContext::ElementOptionContext(
    ParserRuleContext *parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

std::vector<ANTLRv4Parser::IdentifierContext *>
ANTLRv4Parser::ElementOptionContext::identifier() {
  return getRuleContexts<ANTLRv4Parser::IdentifierContext>();
}

ANTLRv4Parser::IdentifierContext *
ANTLRv4Parser::ElementOptionContext::identifier(size_t i) {
  return getRuleContext<ANTLRv4Parser::IdentifierContext>(i);
}

tree::TerminalNode *ANTLRv4Parser::ElementOptionContext::ASSIGN() {
  return getToken(ANTLRv4Parser::ASSIGN, 0);
}

tree::TerminalNode *ANTLRv4Parser::ElementOptionContext::STRING_LITERAL() {
  return getToken(ANTLRv4Parser::STRING_LITERAL, 0);
}

size_t ANTLRv4Parser::ElementOptionContext::getRuleIndex() const {
  return ANTLRv4Parser::RuleElementOption;
}

void ANTLRv4Parser::ElementOptionContext::enterRule(
    tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ANTLRv4ParserListener *>(listener);
  if (parserListener != nullptr) parserListener->enterElementOption(this);
}

void ANTLRv4Parser::ElementOptionContext::exitRule(
    tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ANTLRv4ParserListener *>(listener);
  if (parserListener != nullptr) parserListener->exitElementOption(this);
}

ANTLRv4Parser::ElementOptionContext *ANTLRv4Parser::elementOption() {
  ElementOptionContext *_localctx =
      _tracker.createInstance<ElementOptionContext>(_ctx, getState());
  enterRule(_localctx, 124, ANTLRv4Parser::RuleElementOption);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(621);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(
        _input, 82, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(614);
        identifier();
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(615);
        identifier();
        setState(616);
        match(ANTLRv4Parser::ASSIGN);
        setState(619);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case ANTLRv4Parser::TOKEN_REF:
          case ANTLRv4Parser::RULE_REF: {
            setState(617);
            identifier();
            break;
          }

          case ANTLRv4Parser::STRING_LITERAL: {
            setState(618);
            match(ANTLRv4Parser::STRING_LITERAL);
            break;
          }

          default:
            throw NoViableAltException(this);
        }
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IdentifierContext
//------------------------------------------------------------------

ANTLRv4Parser::IdentifierContext::IdentifierContext(ParserRuleContext *parent,
                                                    size_t invokingState)
    : ParserRuleContext(parent, invokingState) {}

tree::TerminalNode *ANTLRv4Parser::IdentifierContext::RULE_REF() {
  return getToken(ANTLRv4Parser::RULE_REF, 0);
}

tree::TerminalNode *ANTLRv4Parser::IdentifierContext::TOKEN_REF() {
  return getToken(ANTLRv4Parser::TOKEN_REF, 0);
}

size_t ANTLRv4Parser::IdentifierContext::getRuleIndex() const {
  return ANTLRv4Parser::RuleIdentifier;
}

void ANTLRv4Parser::IdentifierContext::enterRule(
    tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ANTLRv4ParserListener *>(listener);
  if (parserListener != nullptr) parserListener->enterIdentifier(this);
}

void ANTLRv4Parser::IdentifierContext::exitRule(
    tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ANTLRv4ParserListener *>(listener);
  if (parserListener != nullptr) parserListener->exitIdentifier(this);
}

ANTLRv4Parser::IdentifierContext *ANTLRv4Parser::identifier() {
  IdentifierContext *_localctx =
      _tracker.createInstance<IdentifierContext>(_ctx, getState());
  enterRule(_localctx, 126, ANTLRv4Parser::RuleIdentifier);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(623);
    _la = _input->LA(1);
    if (!(_la == ANTLRv4Parser::TOKEN_REF

          || _la == ANTLRv4Parser::RULE_REF)) {
      _errHandler->recoverInline(this);
    } else {
      _errHandler->reportMatch(this);
      consume();
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

void ANTLRv4Parser::initialize() {
  ::antlr4::internal::call_once(antlrv4parserParserOnceFlag,
                                antlrv4parserParserInitialize);
}
