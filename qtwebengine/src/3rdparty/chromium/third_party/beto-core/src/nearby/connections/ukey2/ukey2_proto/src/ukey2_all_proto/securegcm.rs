// Copyright 2023 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// This file is generated by rust-protobuf 3.2.0. Do not edit
// .proto file is parsed by protoc 3.19.1
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `securegcm.proto`
// Generated for lite runtime

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_2_0;

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:securegcm.GcmDeviceInfo)
pub struct GcmDeviceInfo {
    // message fields
    // @@protoc_insertion_point(field:securegcm.GcmDeviceInfo.android_device_id)
    pub android_device_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:securegcm.GcmDeviceInfo.gcm_registration_id)
    pub gcm_registration_id: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:securegcm.GcmDeviceInfo.apn_registration_id)
    pub apn_registration_id: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:securegcm.GcmDeviceInfo.notification_enabled)
    pub notification_enabled: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:securegcm.GcmDeviceInfo.bluetooth_mac_address)
    pub bluetooth_mac_address: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:securegcm.GcmDeviceInfo.device_master_key_hash)
    pub device_master_key_hash: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:securegcm.GcmDeviceInfo.user_public_key)
    pub user_public_key: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:securegcm.GcmDeviceInfo.device_model)
    pub device_model: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:securegcm.GcmDeviceInfo.locale)
    pub locale: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:securegcm.GcmDeviceInfo.key_handle)
    pub key_handle: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:securegcm.GcmDeviceInfo.counter)
    pub counter: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:securegcm.GcmDeviceInfo.device_os_version)
    pub device_os_version: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:securegcm.GcmDeviceInfo.device_os_version_code)
    pub device_os_version_code: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:securegcm.GcmDeviceInfo.device_os_release)
    pub device_os_release: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:securegcm.GcmDeviceInfo.device_os_codename)
    pub device_os_codename: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:securegcm.GcmDeviceInfo.device_software_version)
    pub device_software_version: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:securegcm.GcmDeviceInfo.device_software_version_code)
    pub device_software_version_code: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:securegcm.GcmDeviceInfo.device_software_package)
    pub device_software_package: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:securegcm.GcmDeviceInfo.device_display_diagonal_mils)
    pub device_display_diagonal_mils: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:securegcm.GcmDeviceInfo.device_authzen_version)
    pub device_authzen_version: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:securegcm.GcmDeviceInfo.long_device_id)
    pub long_device_id: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:securegcm.GcmDeviceInfo.device_manufacturer)
    pub device_manufacturer: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:securegcm.GcmDeviceInfo.device_type)
    pub device_type: ::std::option::Option<::protobuf::EnumOrUnknown<DeviceType>>,
    // @@protoc_insertion_point(field:securegcm.GcmDeviceInfo.using_secure_screenlock)
    pub using_secure_screenlock: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:securegcm.GcmDeviceInfo.auto_unlock_screenlock_supported)
    pub auto_unlock_screenlock_supported: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:securegcm.GcmDeviceInfo.auto_unlock_screenlock_enabled)
    pub auto_unlock_screenlock_enabled: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:securegcm.GcmDeviceInfo.bluetooth_radio_supported)
    pub bluetooth_radio_supported: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:securegcm.GcmDeviceInfo.bluetooth_radio_enabled)
    pub bluetooth_radio_enabled: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:securegcm.GcmDeviceInfo.mobile_data_supported)
    pub mobile_data_supported: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:securegcm.GcmDeviceInfo.tethering_supported)
    pub tethering_supported: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:securegcm.GcmDeviceInfo.ble_radio_supported)
    pub ble_radio_supported: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:securegcm.GcmDeviceInfo.pixel_experience)
    pub pixel_experience: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:securegcm.GcmDeviceInfo.arc_plus_plus)
    pub arc_plus_plus: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:securegcm.GcmDeviceInfo.is_screenlock_state_flaky)
    pub is_screenlock_state_flaky: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:securegcm.GcmDeviceInfo.supported_software_features)
    pub supported_software_features: ::std::vec::Vec<::protobuf::EnumOrUnknown<SoftwareFeature>>,
    // @@protoc_insertion_point(field:securegcm.GcmDeviceInfo.enabled_software_features)
    pub enabled_software_features: ::std::vec::Vec<::protobuf::EnumOrUnknown<SoftwareFeature>>,
    // @@protoc_insertion_point(field:securegcm.GcmDeviceInfo.enrollment_session_id)
    pub enrollment_session_id: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:securegcm.GcmDeviceInfo.oauth_token)
    pub oauth_token: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:securegcm.GcmDeviceInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GcmDeviceInfo {
    fn default() -> &'a GcmDeviceInfo {
        <GcmDeviceInfo as ::protobuf::Message>::default_instance()
    }
}

impl GcmDeviceInfo {
    pub fn new() -> GcmDeviceInfo {
        ::std::default::Default::default()
    }

    // optional fixed64 android_device_id = 1;

    pub fn android_device_id(&self) -> u64 {
        self.android_device_id.unwrap_or(0)
    }

    pub fn clear_android_device_id(&mut self) {
        self.android_device_id = ::std::option::Option::None;
    }

    pub fn has_android_device_id(&self) -> bool {
        self.android_device_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_android_device_id(&mut self, v: u64) {
        self.android_device_id = ::std::option::Option::Some(v);
    }

    // optional bytes gcm_registration_id = 102;

    pub fn gcm_registration_id(&self) -> &[u8] {
        match self.gcm_registration_id.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_gcm_registration_id(&mut self) {
        self.gcm_registration_id = ::std::option::Option::None;
    }

    pub fn has_gcm_registration_id(&self) -> bool {
        self.gcm_registration_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gcm_registration_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.gcm_registration_id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gcm_registration_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.gcm_registration_id.is_none() {
            self.gcm_registration_id = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.gcm_registration_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_gcm_registration_id(&mut self) -> ::std::vec::Vec<u8> {
        self.gcm_registration_id.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes apn_registration_id = 202;

    pub fn apn_registration_id(&self) -> &[u8] {
        match self.apn_registration_id.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_apn_registration_id(&mut self) {
        self.apn_registration_id = ::std::option::Option::None;
    }

    pub fn has_apn_registration_id(&self) -> bool {
        self.apn_registration_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_apn_registration_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.apn_registration_id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_apn_registration_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.apn_registration_id.is_none() {
            self.apn_registration_id = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.apn_registration_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_apn_registration_id(&mut self) -> ::std::vec::Vec<u8> {
        self.apn_registration_id.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bool notification_enabled = 203;

    pub fn notification_enabled(&self) -> bool {
        self.notification_enabled.unwrap_or(true)
    }

    pub fn clear_notification_enabled(&mut self) {
        self.notification_enabled = ::std::option::Option::None;
    }

    pub fn has_notification_enabled(&self) -> bool {
        self.notification_enabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_notification_enabled(&mut self, v: bool) {
        self.notification_enabled = ::std::option::Option::Some(v);
    }

    // optional string bluetooth_mac_address = 302;

    pub fn bluetooth_mac_address(&self) -> &str {
        match self.bluetooth_mac_address.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_bluetooth_mac_address(&mut self) {
        self.bluetooth_mac_address = ::std::option::Option::None;
    }

    pub fn has_bluetooth_mac_address(&self) -> bool {
        self.bluetooth_mac_address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bluetooth_mac_address(&mut self, v: ::std::string::String) {
        self.bluetooth_mac_address = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bluetooth_mac_address(&mut self) -> &mut ::std::string::String {
        if self.bluetooth_mac_address.is_none() {
            self.bluetooth_mac_address = ::std::option::Option::Some(::std::string::String::new());
        }
        self.bluetooth_mac_address.as_mut().unwrap()
    }

    // Take field
    pub fn take_bluetooth_mac_address(&mut self) -> ::std::string::String {
        self.bluetooth_mac_address.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes device_master_key_hash = 103;

    pub fn device_master_key_hash(&self) -> &[u8] {
        match self.device_master_key_hash.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_device_master_key_hash(&mut self) {
        self.device_master_key_hash = ::std::option::Option::None;
    }

    pub fn has_device_master_key_hash(&self) -> bool {
        self.device_master_key_hash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_device_master_key_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.device_master_key_hash = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_device_master_key_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.device_master_key_hash.is_none() {
            self.device_master_key_hash = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.device_master_key_hash.as_mut().unwrap()
    }

    // Take field
    pub fn take_device_master_key_hash(&mut self) -> ::std::vec::Vec<u8> {
        self.device_master_key_hash.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // required bytes user_public_key = 4;

    pub fn user_public_key(&self) -> &[u8] {
        match self.user_public_key.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_user_public_key(&mut self) {
        self.user_public_key = ::std::option::Option::None;
    }

    pub fn has_user_public_key(&self) -> bool {
        self.user_public_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_public_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.user_public_key = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_public_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.user_public_key.is_none() {
            self.user_public_key = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.user_public_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_public_key(&mut self) -> ::std::vec::Vec<u8> {
        self.user_public_key.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional string device_model = 7;

    pub fn device_model(&self) -> &str {
        match self.device_model.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_device_model(&mut self) {
        self.device_model = ::std::option::Option::None;
    }

    pub fn has_device_model(&self) -> bool {
        self.device_model.is_some()
    }

    // Param is passed by value, moved
    pub fn set_device_model(&mut self, v: ::std::string::String) {
        self.device_model = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_device_model(&mut self) -> &mut ::std::string::String {
        if self.device_model.is_none() {
            self.device_model = ::std::option::Option::Some(::std::string::String::new());
        }
        self.device_model.as_mut().unwrap()
    }

    // Take field
    pub fn take_device_model(&mut self) -> ::std::string::String {
        self.device_model.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string locale = 8;

    pub fn locale(&self) -> &str {
        match self.locale.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_locale(&mut self) {
        self.locale = ::std::option::Option::None;
    }

    pub fn has_locale(&self) -> bool {
        self.locale.is_some()
    }

    // Param is passed by value, moved
    pub fn set_locale(&mut self, v: ::std::string::String) {
        self.locale = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_locale(&mut self) -> &mut ::std::string::String {
        if self.locale.is_none() {
            self.locale = ::std::option::Option::Some(::std::string::String::new());
        }
        self.locale.as_mut().unwrap()
    }

    // Take field
    pub fn take_locale(&mut self) -> ::std::string::String {
        self.locale.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes key_handle = 9;

    pub fn key_handle(&self) -> &[u8] {
        match self.key_handle.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_key_handle(&mut self) {
        self.key_handle = ::std::option::Option::None;
    }

    pub fn has_key_handle(&self) -> bool {
        self.key_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key_handle(&mut self, v: ::std::vec::Vec<u8>) {
        self.key_handle = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key_handle(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.key_handle.is_none() {
            self.key_handle = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.key_handle.as_mut().unwrap()
    }

    // Take field
    pub fn take_key_handle(&mut self) -> ::std::vec::Vec<u8> {
        self.key_handle.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional int64 counter = 12;

    pub fn counter(&self) -> i64 {
        self.counter.unwrap_or(0i64)
    }

    pub fn clear_counter(&mut self) {
        self.counter = ::std::option::Option::None;
    }

    pub fn has_counter(&self) -> bool {
        self.counter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_counter(&mut self, v: i64) {
        self.counter = ::std::option::Option::Some(v);
    }

    // optional string device_os_version = 13;

    pub fn device_os_version(&self) -> &str {
        match self.device_os_version.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_device_os_version(&mut self) {
        self.device_os_version = ::std::option::Option::None;
    }

    pub fn has_device_os_version(&self) -> bool {
        self.device_os_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_device_os_version(&mut self, v: ::std::string::String) {
        self.device_os_version = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_device_os_version(&mut self) -> &mut ::std::string::String {
        if self.device_os_version.is_none() {
            self.device_os_version = ::std::option::Option::Some(::std::string::String::new());
        }
        self.device_os_version.as_mut().unwrap()
    }

    // Take field
    pub fn take_device_os_version(&mut self) -> ::std::string::String {
        self.device_os_version.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int64 device_os_version_code = 14;

    pub fn device_os_version_code(&self) -> i64 {
        self.device_os_version_code.unwrap_or(0)
    }

    pub fn clear_device_os_version_code(&mut self) {
        self.device_os_version_code = ::std::option::Option::None;
    }

    pub fn has_device_os_version_code(&self) -> bool {
        self.device_os_version_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_device_os_version_code(&mut self, v: i64) {
        self.device_os_version_code = ::std::option::Option::Some(v);
    }

    // optional string device_os_release = 15;

    pub fn device_os_release(&self) -> &str {
        match self.device_os_release.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_device_os_release(&mut self) {
        self.device_os_release = ::std::option::Option::None;
    }

    pub fn has_device_os_release(&self) -> bool {
        self.device_os_release.is_some()
    }

    // Param is passed by value, moved
    pub fn set_device_os_release(&mut self, v: ::std::string::String) {
        self.device_os_release = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_device_os_release(&mut self) -> &mut ::std::string::String {
        if self.device_os_release.is_none() {
            self.device_os_release = ::std::option::Option::Some(::std::string::String::new());
        }
        self.device_os_release.as_mut().unwrap()
    }

    // Take field
    pub fn take_device_os_release(&mut self) -> ::std::string::String {
        self.device_os_release.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string device_os_codename = 16;

    pub fn device_os_codename(&self) -> &str {
        match self.device_os_codename.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_device_os_codename(&mut self) {
        self.device_os_codename = ::std::option::Option::None;
    }

    pub fn has_device_os_codename(&self) -> bool {
        self.device_os_codename.is_some()
    }

    // Param is passed by value, moved
    pub fn set_device_os_codename(&mut self, v: ::std::string::String) {
        self.device_os_codename = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_device_os_codename(&mut self) -> &mut ::std::string::String {
        if self.device_os_codename.is_none() {
            self.device_os_codename = ::std::option::Option::Some(::std::string::String::new());
        }
        self.device_os_codename.as_mut().unwrap()
    }

    // Take field
    pub fn take_device_os_codename(&mut self) -> ::std::string::String {
        self.device_os_codename.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string device_software_version = 17;

    pub fn device_software_version(&self) -> &str {
        match self.device_software_version.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_device_software_version(&mut self) {
        self.device_software_version = ::std::option::Option::None;
    }

    pub fn has_device_software_version(&self) -> bool {
        self.device_software_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_device_software_version(&mut self, v: ::std::string::String) {
        self.device_software_version = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_device_software_version(&mut self) -> &mut ::std::string::String {
        if self.device_software_version.is_none() {
            self.device_software_version = ::std::option::Option::Some(::std::string::String::new());
        }
        self.device_software_version.as_mut().unwrap()
    }

    // Take field
    pub fn take_device_software_version(&mut self) -> ::std::string::String {
        self.device_software_version.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int64 device_software_version_code = 18;

    pub fn device_software_version_code(&self) -> i64 {
        self.device_software_version_code.unwrap_or(0)
    }

    pub fn clear_device_software_version_code(&mut self) {
        self.device_software_version_code = ::std::option::Option::None;
    }

    pub fn has_device_software_version_code(&self) -> bool {
        self.device_software_version_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_device_software_version_code(&mut self, v: i64) {
        self.device_software_version_code = ::std::option::Option::Some(v);
    }

    // optional string device_software_package = 19;

    pub fn device_software_package(&self) -> &str {
        match self.device_software_package.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_device_software_package(&mut self) {
        self.device_software_package = ::std::option::Option::None;
    }

    pub fn has_device_software_package(&self) -> bool {
        self.device_software_package.is_some()
    }

    // Param is passed by value, moved
    pub fn set_device_software_package(&mut self, v: ::std::string::String) {
        self.device_software_package = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_device_software_package(&mut self) -> &mut ::std::string::String {
        if self.device_software_package.is_none() {
            self.device_software_package = ::std::option::Option::Some(::std::string::String::new());
        }
        self.device_software_package.as_mut().unwrap()
    }

    // Take field
    pub fn take_device_software_package(&mut self) -> ::std::string::String {
        self.device_software_package.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 device_display_diagonal_mils = 22;

    pub fn device_display_diagonal_mils(&self) -> i32 {
        self.device_display_diagonal_mils.unwrap_or(0)
    }

    pub fn clear_device_display_diagonal_mils(&mut self) {
        self.device_display_diagonal_mils = ::std::option::Option::None;
    }

    pub fn has_device_display_diagonal_mils(&self) -> bool {
        self.device_display_diagonal_mils.is_some()
    }

    // Param is passed by value, moved
    pub fn set_device_display_diagonal_mils(&mut self, v: i32) {
        self.device_display_diagonal_mils = ::std::option::Option::Some(v);
    }

    // optional int32 device_authzen_version = 24;

    pub fn device_authzen_version(&self) -> i32 {
        self.device_authzen_version.unwrap_or(0)
    }

    pub fn clear_device_authzen_version(&mut self) {
        self.device_authzen_version = ::std::option::Option::None;
    }

    pub fn has_device_authzen_version(&self) -> bool {
        self.device_authzen_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_device_authzen_version(&mut self, v: i32) {
        self.device_authzen_version = ::std::option::Option::Some(v);
    }

    // optional bytes long_device_id = 29;

    pub fn long_device_id(&self) -> &[u8] {
        match self.long_device_id.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_long_device_id(&mut self) {
        self.long_device_id = ::std::option::Option::None;
    }

    pub fn has_long_device_id(&self) -> bool {
        self.long_device_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_long_device_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.long_device_id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_long_device_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.long_device_id.is_none() {
            self.long_device_id = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.long_device_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_long_device_id(&mut self) -> ::std::vec::Vec<u8> {
        self.long_device_id.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional string device_manufacturer = 31;

    pub fn device_manufacturer(&self) -> &str {
        match self.device_manufacturer.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_device_manufacturer(&mut self) {
        self.device_manufacturer = ::std::option::Option::None;
    }

    pub fn has_device_manufacturer(&self) -> bool {
        self.device_manufacturer.is_some()
    }

    // Param is passed by value, moved
    pub fn set_device_manufacturer(&mut self, v: ::std::string::String) {
        self.device_manufacturer = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_device_manufacturer(&mut self) -> &mut ::std::string::String {
        if self.device_manufacturer.is_none() {
            self.device_manufacturer = ::std::option::Option::Some(::std::string::String::new());
        }
        self.device_manufacturer.as_mut().unwrap()
    }

    // Take field
    pub fn take_device_manufacturer(&mut self) -> ::std::string::String {
        self.device_manufacturer.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .securegcm.DeviceType device_type = 32;

    pub fn device_type(&self) -> DeviceType {
        match self.device_type {
            Some(e) => e.enum_value_or(DeviceType::ANDROID),
            None => DeviceType::ANDROID,
        }
    }

    pub fn clear_device_type(&mut self) {
        self.device_type = ::std::option::Option::None;
    }

    pub fn has_device_type(&self) -> bool {
        self.device_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_device_type(&mut self, v: DeviceType) {
        self.device_type = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional bool using_secure_screenlock = 400;

    pub fn using_secure_screenlock(&self) -> bool {
        self.using_secure_screenlock.unwrap_or(false)
    }

    pub fn clear_using_secure_screenlock(&mut self) {
        self.using_secure_screenlock = ::std::option::Option::None;
    }

    pub fn has_using_secure_screenlock(&self) -> bool {
        self.using_secure_screenlock.is_some()
    }

    // Param is passed by value, moved
    pub fn set_using_secure_screenlock(&mut self, v: bool) {
        self.using_secure_screenlock = ::std::option::Option::Some(v);
    }

    // optional bool auto_unlock_screenlock_supported = 401;

    pub fn auto_unlock_screenlock_supported(&self) -> bool {
        self.auto_unlock_screenlock_supported.unwrap_or(false)
    }

    pub fn clear_auto_unlock_screenlock_supported(&mut self) {
        self.auto_unlock_screenlock_supported = ::std::option::Option::None;
    }

    pub fn has_auto_unlock_screenlock_supported(&self) -> bool {
        self.auto_unlock_screenlock_supported.is_some()
    }

    // Param is passed by value, moved
    pub fn set_auto_unlock_screenlock_supported(&mut self, v: bool) {
        self.auto_unlock_screenlock_supported = ::std::option::Option::Some(v);
    }

    // optional bool auto_unlock_screenlock_enabled = 402;

    pub fn auto_unlock_screenlock_enabled(&self) -> bool {
        self.auto_unlock_screenlock_enabled.unwrap_or(false)
    }

    pub fn clear_auto_unlock_screenlock_enabled(&mut self) {
        self.auto_unlock_screenlock_enabled = ::std::option::Option::None;
    }

    pub fn has_auto_unlock_screenlock_enabled(&self) -> bool {
        self.auto_unlock_screenlock_enabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_auto_unlock_screenlock_enabled(&mut self, v: bool) {
        self.auto_unlock_screenlock_enabled = ::std::option::Option::Some(v);
    }

    // optional bool bluetooth_radio_supported = 403;

    pub fn bluetooth_radio_supported(&self) -> bool {
        self.bluetooth_radio_supported.unwrap_or(false)
    }

    pub fn clear_bluetooth_radio_supported(&mut self) {
        self.bluetooth_radio_supported = ::std::option::Option::None;
    }

    pub fn has_bluetooth_radio_supported(&self) -> bool {
        self.bluetooth_radio_supported.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bluetooth_radio_supported(&mut self, v: bool) {
        self.bluetooth_radio_supported = ::std::option::Option::Some(v);
    }

    // optional bool bluetooth_radio_enabled = 404;

    pub fn bluetooth_radio_enabled(&self) -> bool {
        self.bluetooth_radio_enabled.unwrap_or(false)
    }

    pub fn clear_bluetooth_radio_enabled(&mut self) {
        self.bluetooth_radio_enabled = ::std::option::Option::None;
    }

    pub fn has_bluetooth_radio_enabled(&self) -> bool {
        self.bluetooth_radio_enabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bluetooth_radio_enabled(&mut self, v: bool) {
        self.bluetooth_radio_enabled = ::std::option::Option::Some(v);
    }

    // optional bool mobile_data_supported = 405;

    pub fn mobile_data_supported(&self) -> bool {
        self.mobile_data_supported.unwrap_or(false)
    }

    pub fn clear_mobile_data_supported(&mut self) {
        self.mobile_data_supported = ::std::option::Option::None;
    }

    pub fn has_mobile_data_supported(&self) -> bool {
        self.mobile_data_supported.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mobile_data_supported(&mut self, v: bool) {
        self.mobile_data_supported = ::std::option::Option::Some(v);
    }

    // optional bool tethering_supported = 406;

    pub fn tethering_supported(&self) -> bool {
        self.tethering_supported.unwrap_or(false)
    }

    pub fn clear_tethering_supported(&mut self) {
        self.tethering_supported = ::std::option::Option::None;
    }

    pub fn has_tethering_supported(&self) -> bool {
        self.tethering_supported.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tethering_supported(&mut self, v: bool) {
        self.tethering_supported = ::std::option::Option::Some(v);
    }

    // optional bool ble_radio_supported = 407;

    pub fn ble_radio_supported(&self) -> bool {
        self.ble_radio_supported.unwrap_or(false)
    }

    pub fn clear_ble_radio_supported(&mut self) {
        self.ble_radio_supported = ::std::option::Option::None;
    }

    pub fn has_ble_radio_supported(&self) -> bool {
        self.ble_radio_supported.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ble_radio_supported(&mut self, v: bool) {
        self.ble_radio_supported = ::std::option::Option::Some(v);
    }

    // optional bool pixel_experience = 408;

    pub fn pixel_experience(&self) -> bool {
        self.pixel_experience.unwrap_or(false)
    }

    pub fn clear_pixel_experience(&mut self) {
        self.pixel_experience = ::std::option::Option::None;
    }

    pub fn has_pixel_experience(&self) -> bool {
        self.pixel_experience.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pixel_experience(&mut self, v: bool) {
        self.pixel_experience = ::std::option::Option::Some(v);
    }

    // optional bool arc_plus_plus = 409;

    pub fn arc_plus_plus(&self) -> bool {
        self.arc_plus_plus.unwrap_or(false)
    }

    pub fn clear_arc_plus_plus(&mut self) {
        self.arc_plus_plus = ::std::option::Option::None;
    }

    pub fn has_arc_plus_plus(&self) -> bool {
        self.arc_plus_plus.is_some()
    }

    // Param is passed by value, moved
    pub fn set_arc_plus_plus(&mut self, v: bool) {
        self.arc_plus_plus = ::std::option::Option::Some(v);
    }

    // optional bool is_screenlock_state_flaky = 410;

    pub fn is_screenlock_state_flaky(&self) -> bool {
        self.is_screenlock_state_flaky.unwrap_or(false)
    }

    pub fn clear_is_screenlock_state_flaky(&mut self) {
        self.is_screenlock_state_flaky = ::std::option::Option::None;
    }

    pub fn has_is_screenlock_state_flaky(&self) -> bool {
        self.is_screenlock_state_flaky.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_screenlock_state_flaky(&mut self, v: bool) {
        self.is_screenlock_state_flaky = ::std::option::Option::Some(v);
    }

    // optional bytes enrollment_session_id = 1000;

    pub fn enrollment_session_id(&self) -> &[u8] {
        match self.enrollment_session_id.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_enrollment_session_id(&mut self) {
        self.enrollment_session_id = ::std::option::Option::None;
    }

    pub fn has_enrollment_session_id(&self) -> bool {
        self.enrollment_session_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enrollment_session_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.enrollment_session_id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_enrollment_session_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.enrollment_session_id.is_none() {
            self.enrollment_session_id = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.enrollment_session_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_enrollment_session_id(&mut self) -> ::std::vec::Vec<u8> {
        self.enrollment_session_id.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional string oauth_token = 1001;

    pub fn oauth_token(&self) -> &str {
        match self.oauth_token.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_oauth_token(&mut self) {
        self.oauth_token = ::std::option::Option::None;
    }

    pub fn has_oauth_token(&self) -> bool {
        self.oauth_token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_oauth_token(&mut self, v: ::std::string::String) {
        self.oauth_token = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_oauth_token(&mut self) -> &mut ::std::string::String {
        if self.oauth_token.is_none() {
            self.oauth_token = ::std::option::Option::Some(::std::string::String::new());
        }
        self.oauth_token.as_mut().unwrap()
    }

    // Take field
    pub fn take_oauth_token(&mut self) -> ::std::string::String {
        self.oauth_token.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for GcmDeviceInfo {
    const NAME: &'static str = "GcmDeviceInfo";

    fn is_initialized(&self) -> bool {
        if self.user_public_key.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.android_device_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                818 => {
                    self.gcm_registration_id = ::std::option::Option::Some(is.read_bytes()?);
                },
                1618 => {
                    self.apn_registration_id = ::std::option::Option::Some(is.read_bytes()?);
                },
                1624 => {
                    self.notification_enabled = ::std::option::Option::Some(is.read_bool()?);
                },
                2418 => {
                    self.bluetooth_mac_address = ::std::option::Option::Some(is.read_string()?);
                },
                826 => {
                    self.device_master_key_hash = ::std::option::Option::Some(is.read_bytes()?);
                },
                34 => {
                    self.user_public_key = ::std::option::Option::Some(is.read_bytes()?);
                },
                58 => {
                    self.device_model = ::std::option::Option::Some(is.read_string()?);
                },
                66 => {
                    self.locale = ::std::option::Option::Some(is.read_string()?);
                },
                74 => {
                    self.key_handle = ::std::option::Option::Some(is.read_bytes()?);
                },
                96 => {
                    self.counter = ::std::option::Option::Some(is.read_int64()?);
                },
                106 => {
                    self.device_os_version = ::std::option::Option::Some(is.read_string()?);
                },
                112 => {
                    self.device_os_version_code = ::std::option::Option::Some(is.read_int64()?);
                },
                122 => {
                    self.device_os_release = ::std::option::Option::Some(is.read_string()?);
                },
                130 => {
                    self.device_os_codename = ::std::option::Option::Some(is.read_string()?);
                },
                138 => {
                    self.device_software_version = ::std::option::Option::Some(is.read_string()?);
                },
                144 => {
                    self.device_software_version_code = ::std::option::Option::Some(is.read_int64()?);
                },
                154 => {
                    self.device_software_package = ::std::option::Option::Some(is.read_string()?);
                },
                176 => {
                    self.device_display_diagonal_mils = ::std::option::Option::Some(is.read_int32()?);
                },
                192 => {
                    self.device_authzen_version = ::std::option::Option::Some(is.read_int32()?);
                },
                234 => {
                    self.long_device_id = ::std::option::Option::Some(is.read_bytes()?);
                },
                250 => {
                    self.device_manufacturer = ::std::option::Option::Some(is.read_string()?);
                },
                256 => {
                    self.device_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                3200 => {
                    self.using_secure_screenlock = ::std::option::Option::Some(is.read_bool()?);
                },
                3208 => {
                    self.auto_unlock_screenlock_supported = ::std::option::Option::Some(is.read_bool()?);
                },
                3216 => {
                    self.auto_unlock_screenlock_enabled = ::std::option::Option::Some(is.read_bool()?);
                },
                3224 => {
                    self.bluetooth_radio_supported = ::std::option::Option::Some(is.read_bool()?);
                },
                3232 => {
                    self.bluetooth_radio_enabled = ::std::option::Option::Some(is.read_bool()?);
                },
                3240 => {
                    self.mobile_data_supported = ::std::option::Option::Some(is.read_bool()?);
                },
                3248 => {
                    self.tethering_supported = ::std::option::Option::Some(is.read_bool()?);
                },
                3256 => {
                    self.ble_radio_supported = ::std::option::Option::Some(is.read_bool()?);
                },
                3264 => {
                    self.pixel_experience = ::std::option::Option::Some(is.read_bool()?);
                },
                3272 => {
                    self.arc_plus_plus = ::std::option::Option::Some(is.read_bool()?);
                },
                3280 => {
                    self.is_screenlock_state_flaky = ::std::option::Option::Some(is.read_bool()?);
                },
                3288 => {
                    self.supported_software_features.push(is.read_enum_or_unknown()?);
                },
                3290 => {
                    ::protobuf::rt::read_repeated_packed_enum_or_unknown_into(is, &mut self.supported_software_features)?
                },
                3296 => {
                    self.enabled_software_features.push(is.read_enum_or_unknown()?);
                },
                3298 => {
                    ::protobuf::rt::read_repeated_packed_enum_or_unknown_into(is, &mut self.enabled_software_features)?
                },
                8002 => {
                    self.enrollment_session_id = ::std::option::Option::Some(is.read_bytes()?);
                },
                8010 => {
                    self.oauth_token = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.android_device_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.gcm_registration_id.as_ref() {
            my_size += ::protobuf::rt::bytes_size(102, &v);
        }
        if let Some(v) = self.apn_registration_id.as_ref() {
            my_size += ::protobuf::rt::bytes_size(202, &v);
        }
        if let Some(v) = self.notification_enabled {
            my_size += 2 + 1;
        }
        if let Some(v) = self.bluetooth_mac_address.as_ref() {
            my_size += ::protobuf::rt::string_size(302, &v);
        }
        if let Some(v) = self.device_master_key_hash.as_ref() {
            my_size += ::protobuf::rt::bytes_size(103, &v);
        }
        if let Some(v) = self.user_public_key.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(v) = self.device_model.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.locale.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(v) = self.key_handle.as_ref() {
            my_size += ::protobuf::rt::bytes_size(9, &v);
        }
        if let Some(v) = self.counter {
            my_size += ::protobuf::rt::int64_size(12, v);
        }
        if let Some(v) = self.device_os_version.as_ref() {
            my_size += ::protobuf::rt::string_size(13, &v);
        }
        if let Some(v) = self.device_os_version_code {
            my_size += ::protobuf::rt::int64_size(14, v);
        }
        if let Some(v) = self.device_os_release.as_ref() {
            my_size += ::protobuf::rt::string_size(15, &v);
        }
        if let Some(v) = self.device_os_codename.as_ref() {
            my_size += ::protobuf::rt::string_size(16, &v);
        }
        if let Some(v) = self.device_software_version.as_ref() {
            my_size += ::protobuf::rt::string_size(17, &v);
        }
        if let Some(v) = self.device_software_version_code {
            my_size += ::protobuf::rt::int64_size(18, v);
        }
        if let Some(v) = self.device_software_package.as_ref() {
            my_size += ::protobuf::rt::string_size(19, &v);
        }
        if let Some(v) = self.device_display_diagonal_mils {
            my_size += ::protobuf::rt::int32_size(22, v);
        }
        if let Some(v) = self.device_authzen_version {
            my_size += ::protobuf::rt::int32_size(24, v);
        }
        if let Some(v) = self.long_device_id.as_ref() {
            my_size += ::protobuf::rt::bytes_size(29, &v);
        }
        if let Some(v) = self.device_manufacturer.as_ref() {
            my_size += ::protobuf::rt::string_size(31, &v);
        }
        if let Some(v) = self.device_type {
            my_size += ::protobuf::rt::int32_size(32, v.value());
        }
        if let Some(v) = self.using_secure_screenlock {
            my_size += 2 + 1;
        }
        if let Some(v) = self.auto_unlock_screenlock_supported {
            my_size += 2 + 1;
        }
        if let Some(v) = self.auto_unlock_screenlock_enabled {
            my_size += 2 + 1;
        }
        if let Some(v) = self.bluetooth_radio_supported {
            my_size += 2 + 1;
        }
        if let Some(v) = self.bluetooth_radio_enabled {
            my_size += 2 + 1;
        }
        if let Some(v) = self.mobile_data_supported {
            my_size += 2 + 1;
        }
        if let Some(v) = self.tethering_supported {
            my_size += 2 + 1;
        }
        if let Some(v) = self.ble_radio_supported {
            my_size += 2 + 1;
        }
        if let Some(v) = self.pixel_experience {
            my_size += 2 + 1;
        }
        if let Some(v) = self.arc_plus_plus {
            my_size += 2 + 1;
        }
        if let Some(v) = self.is_screenlock_state_flaky {
            my_size += 2 + 1;
        }
        for value in &self.supported_software_features {
            my_size += ::protobuf::rt::int32_size(411, value.value());
        };
        for value in &self.enabled_software_features {
            my_size += ::protobuf::rt::int32_size(412, value.value());
        };
        if let Some(v) = self.enrollment_session_id.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1000, &v);
        }
        if let Some(v) = self.oauth_token.as_ref() {
            my_size += ::protobuf::rt::string_size(1001, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.android_device_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.gcm_registration_id.as_ref() {
            os.write_bytes(102, v)?;
        }
        if let Some(v) = self.apn_registration_id.as_ref() {
            os.write_bytes(202, v)?;
        }
        if let Some(v) = self.notification_enabled {
            os.write_bool(203, v)?;
        }
        if let Some(v) = self.bluetooth_mac_address.as_ref() {
            os.write_string(302, v)?;
        }
        if let Some(v) = self.device_master_key_hash.as_ref() {
            os.write_bytes(103, v)?;
        }
        if let Some(v) = self.user_public_key.as_ref() {
            os.write_bytes(4, v)?;
        }
        if let Some(v) = self.device_model.as_ref() {
            os.write_string(7, v)?;
        }
        if let Some(v) = self.locale.as_ref() {
            os.write_string(8, v)?;
        }
        if let Some(v) = self.key_handle.as_ref() {
            os.write_bytes(9, v)?;
        }
        if let Some(v) = self.counter {
            os.write_int64(12, v)?;
        }
        if let Some(v) = self.device_os_version.as_ref() {
            os.write_string(13, v)?;
        }
        if let Some(v) = self.device_os_version_code {
            os.write_int64(14, v)?;
        }
        if let Some(v) = self.device_os_release.as_ref() {
            os.write_string(15, v)?;
        }
        if let Some(v) = self.device_os_codename.as_ref() {
            os.write_string(16, v)?;
        }
        if let Some(v) = self.device_software_version.as_ref() {
            os.write_string(17, v)?;
        }
        if let Some(v) = self.device_software_version_code {
            os.write_int64(18, v)?;
        }
        if let Some(v) = self.device_software_package.as_ref() {
            os.write_string(19, v)?;
        }
        if let Some(v) = self.device_display_diagonal_mils {
            os.write_int32(22, v)?;
        }
        if let Some(v) = self.device_authzen_version {
            os.write_int32(24, v)?;
        }
        if let Some(v) = self.long_device_id.as_ref() {
            os.write_bytes(29, v)?;
        }
        if let Some(v) = self.device_manufacturer.as_ref() {
            os.write_string(31, v)?;
        }
        if let Some(v) = self.device_type {
            os.write_enum(32, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.using_secure_screenlock {
            os.write_bool(400, v)?;
        }
        if let Some(v) = self.auto_unlock_screenlock_supported {
            os.write_bool(401, v)?;
        }
        if let Some(v) = self.auto_unlock_screenlock_enabled {
            os.write_bool(402, v)?;
        }
        if let Some(v) = self.bluetooth_radio_supported {
            os.write_bool(403, v)?;
        }
        if let Some(v) = self.bluetooth_radio_enabled {
            os.write_bool(404, v)?;
        }
        if let Some(v) = self.mobile_data_supported {
            os.write_bool(405, v)?;
        }
        if let Some(v) = self.tethering_supported {
            os.write_bool(406, v)?;
        }
        if let Some(v) = self.ble_radio_supported {
            os.write_bool(407, v)?;
        }
        if let Some(v) = self.pixel_experience {
            os.write_bool(408, v)?;
        }
        if let Some(v) = self.arc_plus_plus {
            os.write_bool(409, v)?;
        }
        if let Some(v) = self.is_screenlock_state_flaky {
            os.write_bool(410, v)?;
        }
        for v in &self.supported_software_features {
            os.write_enum(411, ::protobuf::EnumOrUnknown::value(v))?;
        };
        for v in &self.enabled_software_features {
            os.write_enum(412, ::protobuf::EnumOrUnknown::value(v))?;
        };
        if let Some(v) = self.enrollment_session_id.as_ref() {
            os.write_bytes(1000, v)?;
        }
        if let Some(v) = self.oauth_token.as_ref() {
            os.write_string(1001, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GcmDeviceInfo {
        GcmDeviceInfo::new()
    }

    fn clear(&mut self) {
        self.android_device_id = ::std::option::Option::None;
        self.gcm_registration_id = ::std::option::Option::None;
        self.apn_registration_id = ::std::option::Option::None;
        self.notification_enabled = ::std::option::Option::None;
        self.bluetooth_mac_address = ::std::option::Option::None;
        self.device_master_key_hash = ::std::option::Option::None;
        self.user_public_key = ::std::option::Option::None;
        self.device_model = ::std::option::Option::None;
        self.locale = ::std::option::Option::None;
        self.key_handle = ::std::option::Option::None;
        self.counter = ::std::option::Option::None;
        self.device_os_version = ::std::option::Option::None;
        self.device_os_version_code = ::std::option::Option::None;
        self.device_os_release = ::std::option::Option::None;
        self.device_os_codename = ::std::option::Option::None;
        self.device_software_version = ::std::option::Option::None;
        self.device_software_version_code = ::std::option::Option::None;
        self.device_software_package = ::std::option::Option::None;
        self.device_display_diagonal_mils = ::std::option::Option::None;
        self.device_authzen_version = ::std::option::Option::None;
        self.long_device_id = ::std::option::Option::None;
        self.device_manufacturer = ::std::option::Option::None;
        self.device_type = ::std::option::Option::None;
        self.using_secure_screenlock = ::std::option::Option::None;
        self.auto_unlock_screenlock_supported = ::std::option::Option::None;
        self.auto_unlock_screenlock_enabled = ::std::option::Option::None;
        self.bluetooth_radio_supported = ::std::option::Option::None;
        self.bluetooth_radio_enabled = ::std::option::Option::None;
        self.mobile_data_supported = ::std::option::Option::None;
        self.tethering_supported = ::std::option::Option::None;
        self.ble_radio_supported = ::std::option::Option::None;
        self.pixel_experience = ::std::option::Option::None;
        self.arc_plus_plus = ::std::option::Option::None;
        self.is_screenlock_state_flaky = ::std::option::Option::None;
        self.supported_software_features.clear();
        self.enabled_software_features.clear();
        self.enrollment_session_id = ::std::option::Option::None;
        self.oauth_token = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GcmDeviceInfo {
        static instance: GcmDeviceInfo = GcmDeviceInfo {
            android_device_id: ::std::option::Option::None,
            gcm_registration_id: ::std::option::Option::None,
            apn_registration_id: ::std::option::Option::None,
            notification_enabled: ::std::option::Option::None,
            bluetooth_mac_address: ::std::option::Option::None,
            device_master_key_hash: ::std::option::Option::None,
            user_public_key: ::std::option::Option::None,
            device_model: ::std::option::Option::None,
            locale: ::std::option::Option::None,
            key_handle: ::std::option::Option::None,
            counter: ::std::option::Option::None,
            device_os_version: ::std::option::Option::None,
            device_os_version_code: ::std::option::Option::None,
            device_os_release: ::std::option::Option::None,
            device_os_codename: ::std::option::Option::None,
            device_software_version: ::std::option::Option::None,
            device_software_version_code: ::std::option::Option::None,
            device_software_package: ::std::option::Option::None,
            device_display_diagonal_mils: ::std::option::Option::None,
            device_authzen_version: ::std::option::Option::None,
            long_device_id: ::std::option::Option::None,
            device_manufacturer: ::std::option::Option::None,
            device_type: ::std::option::Option::None,
            using_secure_screenlock: ::std::option::Option::None,
            auto_unlock_screenlock_supported: ::std::option::Option::None,
            auto_unlock_screenlock_enabled: ::std::option::Option::None,
            bluetooth_radio_supported: ::std::option::Option::None,
            bluetooth_radio_enabled: ::std::option::Option::None,
            mobile_data_supported: ::std::option::Option::None,
            tethering_supported: ::std::option::Option::None,
            ble_radio_supported: ::std::option::Option::None,
            pixel_experience: ::std::option::Option::None,
            arc_plus_plus: ::std::option::Option::None,
            is_screenlock_state_flaky: ::std::option::Option::None,
            supported_software_features: ::std::vec::Vec::new(),
            enabled_software_features: ::std::vec::Vec::new(),
            enrollment_session_id: ::std::option::Option::None,
            oauth_token: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:securegcm.GcmMetadata)
pub struct GcmMetadata {
    // message fields
    // @@protoc_insertion_point(field:securegcm.GcmMetadata.type)
    pub type_: ::std::option::Option<::protobuf::EnumOrUnknown<Type>>,
    // @@protoc_insertion_point(field:securegcm.GcmMetadata.version)
    pub version: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:securegcm.GcmMetadata.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GcmMetadata {
    fn default() -> &'a GcmMetadata {
        <GcmMetadata as ::protobuf::Message>::default_instance()
    }
}

impl GcmMetadata {
    pub fn new() -> GcmMetadata {
        ::std::default::Default::default()
    }

    // required .securegcm.Type type = 1;

    pub fn type_(&self) -> Type {
        match self.type_ {
            Some(e) => e.enum_value_or(Type::ENROLLMENT),
            None => Type::ENROLLMENT,
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: Type) {
        self.type_ = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional int32 version = 2;

    pub fn version(&self) -> i32 {
        self.version.unwrap_or(0i32)
    }

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: i32) {
        self.version = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for GcmMetadata {
    const NAME: &'static str = "GcmMetadata";

    fn is_initialized(&self) -> bool {
        if self.type_.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.type_ = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.version = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.type_ {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.version {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.type_ {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.version {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GcmMetadata {
        GcmMetadata::new()
    }

    fn clear(&mut self) {
        self.type_ = ::std::option::Option::None;
        self.version = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GcmMetadata {
        static instance: GcmMetadata = GcmMetadata {
            type_: ::std::option::Option::None,
            version: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:securegcm.Tickle)
pub struct Tickle {
    // message fields
    // @@protoc_insertion_point(field:securegcm.Tickle.expiry_time)
    pub expiry_time: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:securegcm.Tickle.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Tickle {
    fn default() -> &'a Tickle {
        <Tickle as ::protobuf::Message>::default_instance()
    }
}

impl Tickle {
    pub fn new() -> Tickle {
        ::std::default::Default::default()
    }

    // optional fixed64 expiry_time = 1;

    pub fn expiry_time(&self) -> u64 {
        self.expiry_time.unwrap_or(0)
    }

    pub fn clear_expiry_time(&mut self) {
        self.expiry_time = ::std::option::Option::None;
    }

    pub fn has_expiry_time(&self) -> bool {
        self.expiry_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_expiry_time(&mut self, v: u64) {
        self.expiry_time = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for Tickle {
    const NAME: &'static str = "Tickle";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.expiry_time = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.expiry_time {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.expiry_time {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Tickle {
        Tickle::new()
    }

    fn clear(&mut self) {
        self.expiry_time = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Tickle {
        static instance: Tickle = Tickle {
            expiry_time: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:securegcm.LoginNotificationInfo)
pub struct LoginNotificationInfo {
    // message fields
    // @@protoc_insertion_point(field:securegcm.LoginNotificationInfo.creation_time)
    pub creation_time: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:securegcm.LoginNotificationInfo.email)
    pub email: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:securegcm.LoginNotificationInfo.host)
    pub host: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:securegcm.LoginNotificationInfo.source)
    pub source: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:securegcm.LoginNotificationInfo.event_type)
    pub event_type: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:securegcm.LoginNotificationInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LoginNotificationInfo {
    fn default() -> &'a LoginNotificationInfo {
        <LoginNotificationInfo as ::protobuf::Message>::default_instance()
    }
}

impl LoginNotificationInfo {
    pub fn new() -> LoginNotificationInfo {
        ::std::default::Default::default()
    }

    // optional fixed64 creation_time = 2;

    pub fn creation_time(&self) -> u64 {
        self.creation_time.unwrap_or(0)
    }

    pub fn clear_creation_time(&mut self) {
        self.creation_time = ::std::option::Option::None;
    }

    pub fn has_creation_time(&self) -> bool {
        self.creation_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_creation_time(&mut self, v: u64) {
        self.creation_time = ::std::option::Option::Some(v);
    }

    // optional string email = 3;

    pub fn email(&self) -> &str {
        match self.email.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_email(&mut self) {
        self.email = ::std::option::Option::None;
    }

    pub fn has_email(&self) -> bool {
        self.email.is_some()
    }

    // Param is passed by value, moved
    pub fn set_email(&mut self, v: ::std::string::String) {
        self.email = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_email(&mut self) -> &mut ::std::string::String {
        if self.email.is_none() {
            self.email = ::std::option::Option::Some(::std::string::String::new());
        }
        self.email.as_mut().unwrap()
    }

    // Take field
    pub fn take_email(&mut self) -> ::std::string::String {
        self.email.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string host = 4;

    pub fn host(&self) -> &str {
        match self.host.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_host(&mut self) {
        self.host = ::std::option::Option::None;
    }

    pub fn has_host(&self) -> bool {
        self.host.is_some()
    }

    // Param is passed by value, moved
    pub fn set_host(&mut self, v: ::std::string::String) {
        self.host = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_host(&mut self) -> &mut ::std::string::String {
        if self.host.is_none() {
            self.host = ::std::option::Option::Some(::std::string::String::new());
        }
        self.host.as_mut().unwrap()
    }

    // Take field
    pub fn take_host(&mut self) -> ::std::string::String {
        self.host.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string source = 5;

    pub fn source(&self) -> &str {
        match self.source.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_source(&mut self) {
        self.source = ::std::option::Option::None;
    }

    pub fn has_source(&self) -> bool {
        self.source.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source(&mut self, v: ::std::string::String) {
        self.source = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_source(&mut self) -> &mut ::std::string::String {
        if self.source.is_none() {
            self.source = ::std::option::Option::Some(::std::string::String::new());
        }
        self.source.as_mut().unwrap()
    }

    // Take field
    pub fn take_source(&mut self) -> ::std::string::String {
        self.source.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string event_type = 6;

    pub fn event_type(&self) -> &str {
        match self.event_type.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_event_type(&mut self) {
        self.event_type = ::std::option::Option::None;
    }

    pub fn has_event_type(&self) -> bool {
        self.event_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_type(&mut self, v: ::std::string::String) {
        self.event_type = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_event_type(&mut self) -> &mut ::std::string::String {
        if self.event_type.is_none() {
            self.event_type = ::std::option::Option::Some(::std::string::String::new());
        }
        self.event_type.as_mut().unwrap()
    }

    // Take field
    pub fn take_event_type(&mut self) -> ::std::string::String {
        self.event_type.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for LoginNotificationInfo {
    const NAME: &'static str = "LoginNotificationInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                17 => {
                    self.creation_time = ::std::option::Option::Some(is.read_fixed64()?);
                },
                26 => {
                    self.email = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.host = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.source = ::std::option::Option::Some(is.read_string()?);
                },
                50 => {
                    self.event_type = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.creation_time {
            my_size += 1 + 8;
        }
        if let Some(v) = self.email.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.host.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.source.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.event_type.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.creation_time {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.email.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.host.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.source.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.event_type.as_ref() {
            os.write_string(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LoginNotificationInfo {
        LoginNotificationInfo::new()
    }

    fn clear(&mut self) {
        self.creation_time = ::std::option::Option::None;
        self.email = ::std::option::Option::None;
        self.host = ::std::option::Option::None;
        self.source = ::std::option::Option::None;
        self.event_type = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LoginNotificationInfo {
        static instance: LoginNotificationInfo = LoginNotificationInfo {
            creation_time: ::std::option::Option::None,
            email: ::std::option::Option::None,
            host: ::std::option::Option::None,
            source: ::std::option::Option::None,
            event_type: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:securegcm.AppleDeviceDiagonalMils)
pub enum AppleDeviceDiagonalMils {
    // @@protoc_insertion_point(enum_value:securegcm.AppleDeviceDiagonalMils.APPLE_PHONE)
    APPLE_PHONE = 4000,
    // @@protoc_insertion_point(enum_value:securegcm.AppleDeviceDiagonalMils.APPLE_PAD)
    APPLE_PAD = 7900,
}

impl ::protobuf::Enum for AppleDeviceDiagonalMils {
    const NAME: &'static str = "AppleDeviceDiagonalMils";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<AppleDeviceDiagonalMils> {
        match value {
            4000 => ::std::option::Option::Some(AppleDeviceDiagonalMils::APPLE_PHONE),
            7900 => ::std::option::Option::Some(AppleDeviceDiagonalMils::APPLE_PAD),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [AppleDeviceDiagonalMils] = &[
        AppleDeviceDiagonalMils::APPLE_PHONE,
        AppleDeviceDiagonalMils::APPLE_PAD,
    ];
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for AppleDeviceDiagonalMils {
    fn default() -> Self {
        AppleDeviceDiagonalMils::APPLE_PHONE
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:securegcm.DeviceType)
pub enum DeviceType {
    // @@protoc_insertion_point(enum_value:securegcm.DeviceType.UNKNOWN)
    UNKNOWN = 0,
    // @@protoc_insertion_point(enum_value:securegcm.DeviceType.ANDROID)
    ANDROID = 1,
    // @@protoc_insertion_point(enum_value:securegcm.DeviceType.CHROME)
    CHROME = 2,
    // @@protoc_insertion_point(enum_value:securegcm.DeviceType.IOS)
    IOS = 3,
    // @@protoc_insertion_point(enum_value:securegcm.DeviceType.BROWSER)
    BROWSER = 4,
    // @@protoc_insertion_point(enum_value:securegcm.DeviceType.OSX)
    OSX = 5,
}

impl ::protobuf::Enum for DeviceType {
    const NAME: &'static str = "DeviceType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DeviceType> {
        match value {
            0 => ::std::option::Option::Some(DeviceType::UNKNOWN),
            1 => ::std::option::Option::Some(DeviceType::ANDROID),
            2 => ::std::option::Option::Some(DeviceType::CHROME),
            3 => ::std::option::Option::Some(DeviceType::IOS),
            4 => ::std::option::Option::Some(DeviceType::BROWSER),
            5 => ::std::option::Option::Some(DeviceType::OSX),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [DeviceType] = &[
        DeviceType::UNKNOWN,
        DeviceType::ANDROID,
        DeviceType::CHROME,
        DeviceType::IOS,
        DeviceType::BROWSER,
        DeviceType::OSX,
    ];
}

impl ::std::default::Default for DeviceType {
    fn default() -> Self {
        DeviceType::UNKNOWN
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:securegcm.SoftwareFeature)
pub enum SoftwareFeature {
    // @@protoc_insertion_point(enum_value:securegcm.SoftwareFeature.UNKNOWN_FEATURE)
    UNKNOWN_FEATURE = 0,
    // @@protoc_insertion_point(enum_value:securegcm.SoftwareFeature.BETTER_TOGETHER_HOST)
    BETTER_TOGETHER_HOST = 1,
    // @@protoc_insertion_point(enum_value:securegcm.SoftwareFeature.BETTER_TOGETHER_CLIENT)
    BETTER_TOGETHER_CLIENT = 2,
    // @@protoc_insertion_point(enum_value:securegcm.SoftwareFeature.EASY_UNLOCK_HOST)
    EASY_UNLOCK_HOST = 3,
    // @@protoc_insertion_point(enum_value:securegcm.SoftwareFeature.EASY_UNLOCK_CLIENT)
    EASY_UNLOCK_CLIENT = 4,
    // @@protoc_insertion_point(enum_value:securegcm.SoftwareFeature.MAGIC_TETHER_HOST)
    MAGIC_TETHER_HOST = 5,
    // @@protoc_insertion_point(enum_value:securegcm.SoftwareFeature.MAGIC_TETHER_CLIENT)
    MAGIC_TETHER_CLIENT = 6,
    // @@protoc_insertion_point(enum_value:securegcm.SoftwareFeature.SMS_CONNECT_HOST)
    SMS_CONNECT_HOST = 7,
    // @@protoc_insertion_point(enum_value:securegcm.SoftwareFeature.SMS_CONNECT_CLIENT)
    SMS_CONNECT_CLIENT = 8,
}

impl ::protobuf::Enum for SoftwareFeature {
    const NAME: &'static str = "SoftwareFeature";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<SoftwareFeature> {
        match value {
            0 => ::std::option::Option::Some(SoftwareFeature::UNKNOWN_FEATURE),
            1 => ::std::option::Option::Some(SoftwareFeature::BETTER_TOGETHER_HOST),
            2 => ::std::option::Option::Some(SoftwareFeature::BETTER_TOGETHER_CLIENT),
            3 => ::std::option::Option::Some(SoftwareFeature::EASY_UNLOCK_HOST),
            4 => ::std::option::Option::Some(SoftwareFeature::EASY_UNLOCK_CLIENT),
            5 => ::std::option::Option::Some(SoftwareFeature::MAGIC_TETHER_HOST),
            6 => ::std::option::Option::Some(SoftwareFeature::MAGIC_TETHER_CLIENT),
            7 => ::std::option::Option::Some(SoftwareFeature::SMS_CONNECT_HOST),
            8 => ::std::option::Option::Some(SoftwareFeature::SMS_CONNECT_CLIENT),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [SoftwareFeature] = &[
        SoftwareFeature::UNKNOWN_FEATURE,
        SoftwareFeature::BETTER_TOGETHER_HOST,
        SoftwareFeature::BETTER_TOGETHER_CLIENT,
        SoftwareFeature::EASY_UNLOCK_HOST,
        SoftwareFeature::EASY_UNLOCK_CLIENT,
        SoftwareFeature::MAGIC_TETHER_HOST,
        SoftwareFeature::MAGIC_TETHER_CLIENT,
        SoftwareFeature::SMS_CONNECT_HOST,
        SoftwareFeature::SMS_CONNECT_CLIENT,
    ];
}

impl ::std::default::Default for SoftwareFeature {
    fn default() -> Self {
        SoftwareFeature::UNKNOWN_FEATURE
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:securegcm.InvocationReason)
pub enum InvocationReason {
    // @@protoc_insertion_point(enum_value:securegcm.InvocationReason.REASON_UNKNOWN)
    REASON_UNKNOWN = 0,
    // @@protoc_insertion_point(enum_value:securegcm.InvocationReason.REASON_INITIALIZATION)
    REASON_INITIALIZATION = 1,
    // @@protoc_insertion_point(enum_value:securegcm.InvocationReason.REASON_PERIODIC)
    REASON_PERIODIC = 2,
    // @@protoc_insertion_point(enum_value:securegcm.InvocationReason.REASON_SLOW_PERIODIC)
    REASON_SLOW_PERIODIC = 3,
    // @@protoc_insertion_point(enum_value:securegcm.InvocationReason.REASON_FAST_PERIODIC)
    REASON_FAST_PERIODIC = 4,
    // @@protoc_insertion_point(enum_value:securegcm.InvocationReason.REASON_EXPIRATION)
    REASON_EXPIRATION = 5,
    // @@protoc_insertion_point(enum_value:securegcm.InvocationReason.REASON_FAILURE_RECOVERY)
    REASON_FAILURE_RECOVERY = 6,
    // @@protoc_insertion_point(enum_value:securegcm.InvocationReason.REASON_NEW_ACCOUNT)
    REASON_NEW_ACCOUNT = 7,
    // @@protoc_insertion_point(enum_value:securegcm.InvocationReason.REASON_CHANGED_ACCOUNT)
    REASON_CHANGED_ACCOUNT = 8,
    // @@protoc_insertion_point(enum_value:securegcm.InvocationReason.REASON_FEATURE_TOGGLED)
    REASON_FEATURE_TOGGLED = 9,
    // @@protoc_insertion_point(enum_value:securegcm.InvocationReason.REASON_SERVER_INITIATED)
    REASON_SERVER_INITIATED = 10,
    // @@protoc_insertion_point(enum_value:securegcm.InvocationReason.REASON_ADDRESS_CHANGE)
    REASON_ADDRESS_CHANGE = 11,
    // @@protoc_insertion_point(enum_value:securegcm.InvocationReason.REASON_SOFTWARE_UPDATE)
    REASON_SOFTWARE_UPDATE = 12,
    // @@protoc_insertion_point(enum_value:securegcm.InvocationReason.REASON_MANUAL)
    REASON_MANUAL = 13,
    // @@protoc_insertion_point(enum_value:securegcm.InvocationReason.REASON_CUSTOM_KEY_INVALIDATION)
    REASON_CUSTOM_KEY_INVALIDATION = 14,
    // @@protoc_insertion_point(enum_value:securegcm.InvocationReason.REASON_PROXIMITY_PERIODIC)
    REASON_PROXIMITY_PERIODIC = 15,
}

impl ::protobuf::Enum for InvocationReason {
    const NAME: &'static str = "InvocationReason";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<InvocationReason> {
        match value {
            0 => ::std::option::Option::Some(InvocationReason::REASON_UNKNOWN),
            1 => ::std::option::Option::Some(InvocationReason::REASON_INITIALIZATION),
            2 => ::std::option::Option::Some(InvocationReason::REASON_PERIODIC),
            3 => ::std::option::Option::Some(InvocationReason::REASON_SLOW_PERIODIC),
            4 => ::std::option::Option::Some(InvocationReason::REASON_FAST_PERIODIC),
            5 => ::std::option::Option::Some(InvocationReason::REASON_EXPIRATION),
            6 => ::std::option::Option::Some(InvocationReason::REASON_FAILURE_RECOVERY),
            7 => ::std::option::Option::Some(InvocationReason::REASON_NEW_ACCOUNT),
            8 => ::std::option::Option::Some(InvocationReason::REASON_CHANGED_ACCOUNT),
            9 => ::std::option::Option::Some(InvocationReason::REASON_FEATURE_TOGGLED),
            10 => ::std::option::Option::Some(InvocationReason::REASON_SERVER_INITIATED),
            11 => ::std::option::Option::Some(InvocationReason::REASON_ADDRESS_CHANGE),
            12 => ::std::option::Option::Some(InvocationReason::REASON_SOFTWARE_UPDATE),
            13 => ::std::option::Option::Some(InvocationReason::REASON_MANUAL),
            14 => ::std::option::Option::Some(InvocationReason::REASON_CUSTOM_KEY_INVALIDATION),
            15 => ::std::option::Option::Some(InvocationReason::REASON_PROXIMITY_PERIODIC),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [InvocationReason] = &[
        InvocationReason::REASON_UNKNOWN,
        InvocationReason::REASON_INITIALIZATION,
        InvocationReason::REASON_PERIODIC,
        InvocationReason::REASON_SLOW_PERIODIC,
        InvocationReason::REASON_FAST_PERIODIC,
        InvocationReason::REASON_EXPIRATION,
        InvocationReason::REASON_FAILURE_RECOVERY,
        InvocationReason::REASON_NEW_ACCOUNT,
        InvocationReason::REASON_CHANGED_ACCOUNT,
        InvocationReason::REASON_FEATURE_TOGGLED,
        InvocationReason::REASON_SERVER_INITIATED,
        InvocationReason::REASON_ADDRESS_CHANGE,
        InvocationReason::REASON_SOFTWARE_UPDATE,
        InvocationReason::REASON_MANUAL,
        InvocationReason::REASON_CUSTOM_KEY_INVALIDATION,
        InvocationReason::REASON_PROXIMITY_PERIODIC,
    ];
}

impl ::std::default::Default for InvocationReason {
    fn default() -> Self {
        InvocationReason::REASON_UNKNOWN
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:securegcm.Type)
pub enum Type {
    // @@protoc_insertion_point(enum_value:securegcm.Type.ENROLLMENT)
    ENROLLMENT = 0,
    // @@protoc_insertion_point(enum_value:securegcm.Type.TICKLE)
    TICKLE = 1,
    // @@protoc_insertion_point(enum_value:securegcm.Type.TX_REQUEST)
    TX_REQUEST = 2,
    // @@protoc_insertion_point(enum_value:securegcm.Type.TX_REPLY)
    TX_REPLY = 3,
    // @@protoc_insertion_point(enum_value:securegcm.Type.TX_SYNC_REQUEST)
    TX_SYNC_REQUEST = 4,
    // @@protoc_insertion_point(enum_value:securegcm.Type.TX_SYNC_RESPONSE)
    TX_SYNC_RESPONSE = 5,
    // @@protoc_insertion_point(enum_value:securegcm.Type.TX_PING)
    TX_PING = 6,
    // @@protoc_insertion_point(enum_value:securegcm.Type.DEVICE_INFO_UPDATE)
    DEVICE_INFO_UPDATE = 7,
    // @@protoc_insertion_point(enum_value:securegcm.Type.TX_CANCEL_REQUEST)
    TX_CANCEL_REQUEST = 8,
    // @@protoc_insertion_point(enum_value:securegcm.Type.PROXIMITYAUTH_PAIRING)
    PROXIMITYAUTH_PAIRING = 10,
    // @@protoc_insertion_point(enum_value:securegcm.Type.GCMV1_IDENTITY_ASSERTION)
    GCMV1_IDENTITY_ASSERTION = 11,
    // @@protoc_insertion_point(enum_value:securegcm.Type.DEVICE_TO_DEVICE_RESPONDER_HELLO_PAYLOAD)
    DEVICE_TO_DEVICE_RESPONDER_HELLO_PAYLOAD = 12,
    // @@protoc_insertion_point(enum_value:securegcm.Type.DEVICE_TO_DEVICE_MESSAGE)
    DEVICE_TO_DEVICE_MESSAGE = 13,
    // @@protoc_insertion_point(enum_value:securegcm.Type.DEVICE_PROXIMITY_CALLBACK)
    DEVICE_PROXIMITY_CALLBACK = 14,
    // @@protoc_insertion_point(enum_value:securegcm.Type.UNLOCK_KEY_SIGNED_CHALLENGE)
    UNLOCK_KEY_SIGNED_CHALLENGE = 15,
    // @@protoc_insertion_point(enum_value:securegcm.Type.LOGIN_NOTIFICATION)
    LOGIN_NOTIFICATION = 101,
}

impl ::protobuf::Enum for Type {
    const NAME: &'static str = "Type";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Type> {
        match value {
            0 => ::std::option::Option::Some(Type::ENROLLMENT),
            1 => ::std::option::Option::Some(Type::TICKLE),
            2 => ::std::option::Option::Some(Type::TX_REQUEST),
            3 => ::std::option::Option::Some(Type::TX_REPLY),
            4 => ::std::option::Option::Some(Type::TX_SYNC_REQUEST),
            5 => ::std::option::Option::Some(Type::TX_SYNC_RESPONSE),
            6 => ::std::option::Option::Some(Type::TX_PING),
            7 => ::std::option::Option::Some(Type::DEVICE_INFO_UPDATE),
            8 => ::std::option::Option::Some(Type::TX_CANCEL_REQUEST),
            10 => ::std::option::Option::Some(Type::PROXIMITYAUTH_PAIRING),
            11 => ::std::option::Option::Some(Type::GCMV1_IDENTITY_ASSERTION),
            12 => ::std::option::Option::Some(Type::DEVICE_TO_DEVICE_RESPONDER_HELLO_PAYLOAD),
            13 => ::std::option::Option::Some(Type::DEVICE_TO_DEVICE_MESSAGE),
            14 => ::std::option::Option::Some(Type::DEVICE_PROXIMITY_CALLBACK),
            15 => ::std::option::Option::Some(Type::UNLOCK_KEY_SIGNED_CHALLENGE),
            101 => ::std::option::Option::Some(Type::LOGIN_NOTIFICATION),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [Type] = &[
        Type::ENROLLMENT,
        Type::TICKLE,
        Type::TX_REQUEST,
        Type::TX_REPLY,
        Type::TX_SYNC_REQUEST,
        Type::TX_SYNC_RESPONSE,
        Type::TX_PING,
        Type::DEVICE_INFO_UPDATE,
        Type::TX_CANCEL_REQUEST,
        Type::PROXIMITYAUTH_PAIRING,
        Type::GCMV1_IDENTITY_ASSERTION,
        Type::DEVICE_TO_DEVICE_RESPONDER_HELLO_PAYLOAD,
        Type::DEVICE_TO_DEVICE_MESSAGE,
        Type::DEVICE_PROXIMITY_CALLBACK,
        Type::UNLOCK_KEY_SIGNED_CHALLENGE,
        Type::LOGIN_NOTIFICATION,
    ];
}

impl ::std::default::Default for Type {
    fn default() -> Self {
        Type::ENROLLMENT
    }
}

