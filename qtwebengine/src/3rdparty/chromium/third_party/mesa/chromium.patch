diff -c -r Mesa-7.9/include/GL/gl.h MesaLib/include/GL/gl.h
*** Mesa-7.9/include/GL/gl.h	Tue Apr 27 14:41:21 2010
--- MesaLib/include/GL/gl.h	Thu Oct 14 14:41:53 2010
***************
*** 55,61 ****
  #  if (defined(_MSC_VER) || defined(__MINGW32__)) && defined(BUILD_GL32) /* tag specify we're building mesa as a DLL */
  #    define GLAPI __declspec(dllexport)
  #  elif (defined(_MSC_VER) || defined(__MINGW32__)) && defined(_DLL) /* tag specifying we're building for DLL runtime support */
! #    define GLAPI __declspec(dllimport)
  #  else /* for use with static link lib build of Win32 edition only */
  #    define GLAPI extern
  #  endif /* _STATIC_MESA support */
--- 55,65 ----
  #  if (defined(_MSC_VER) || defined(__MINGW32__)) && defined(BUILD_GL32) /* tag specify we're building mesa as a DLL */
  #    define GLAPI __declspec(dllexport)
  #  elif (defined(_MSC_VER) || defined(__MINGW32__)) && defined(_DLL) /* tag specifying we're building for DLL runtime support */
! // We always retrieve the entry points dynamically via GetProcAddress or
! // OSMesaGetProcAddress. This works around an issue where using the MSVC
! // multi-threaded runtime library, which defines _DLL.
! //#    define GLAPI __declspec(dllimport)
! #    define GLAPI
  #  else /* for use with static link lib build of Win32 edition only */
  #    define GLAPI extern
  #  endif /* _STATIC_MESA support */
***************
*** 72,80 ****
  #  define GLAPIENTRY
  #endif /* WIN32 && !CYGWIN */
  
! #if (defined(__BEOS__) && defined(__POWERPC__)) || defined(__QUICKDRAW__)
! #  define PRAGMA_EXPORT_SUPPORTED		1
! #endif
  
  /*
   * WINDOWS: Include windows.h here to define APIENTRY.
--- 76,86 ----
  #  define GLAPIENTRY
  #endif /* WIN32 && !CYGWIN */
  
! // Disabled this because __QUICKDRAW__ is defined on Mac and gcc does not
! // support the pragma.
! //#if (defined(__BEOS__) && defined(__POWERPC__)) || defined(__QUICKDRAW__)
! //#  define PRAGMA_EXPORT_SUPPORTED		1
! //#endif
  
  /*
   * WINDOWS: Include windows.h here to define APIENTRY.
diff -c -r Mesa-7.9/include/GL/glext.h MesaLib/include/GL/glext.h
*** Mesa-7.9/include/GL/glext.h	Fri Oct  1 15:51:28 2010
--- MesaLib/include/GL/glext.h	Thu Oct 14 14:50:37 2010
***************
*** 5030,5043 ****
  
  #ifndef GL_VERSION_1_5
  /* GL types for handling large vertex buffer objects */
! typedef ptrdiff_t GLintptr;
! typedef ptrdiff_t GLsizeiptr;
  #endif
  
  #ifndef GL_ARB_vertex_buffer_object
  /* GL types for handling large vertex buffer objects */
! typedef ptrdiff_t GLintptrARB;
! typedef ptrdiff_t GLsizeiptrARB;
  #endif
  
  #ifndef GL_ARB_shader_objects
--- 5030,5043 ----
  
  #ifndef GL_VERSION_1_5
  /* GL types for handling large vertex buffer objects */
! typedef signed long int GLintptr;
! typedef signed long int GLsizeiptr;
  #endif
  
  #ifndef GL_ARB_vertex_buffer_object
  /* GL types for handling large vertex buffer objects */
! typedef signed long int GLintptrARB;
! typedef signed long int GLsizeiptrARB;
  #endif
  
  #ifndef GL_ARB_shader_objects
diff -c -r Mesa-7.9/include/GL/osmesa.h MesaLib/include/GL/osmesa.h
*** Mesa-7.9/include/GL/osmesa.h	Thu Feb  4 16:10:39 2010
--- MesaLib/include/GL/osmesa.h	Thu Oct 14 14:47:08 2010
***************
*** 101,109 ****
  typedef struct osmesa_context *OSMesaContext;
  
  
! #if defined(__BEOS__) || defined(__QUICKDRAW__)
! #pragma export on
! #endif
  
  
  /*
--- 101,111 ----
  typedef struct osmesa_context *OSMesaContext;
  
  
! // Disabled this because __QUICKDRAW__ is defined on Mac and gcc does not
! // support the pragma.
! //#if defined(__BEOS__) || defined(__QUICKDRAW__)
! //#pragma export on
! //#endif
  
  
  /*
***************
*** 276,284 ****
  OSMesaColorClamp(GLboolean enable);
  
  
! #if defined(__BEOS__) || defined(__QUICKDRAW__)
! #pragma export off
! #endif
  
  
  #ifdef __cplusplus
--- 278,288 ----
  OSMesaColorClamp(GLboolean enable);
  
  
! // Disabled this because __QUICKDRAW__ is defined on Mac and gcc does not
! // support the pragma.
! //#if defined(__BEOS__) || defined(__QUICKDRAW__)
! //#pragma export off
! //#endif
  
  
  #ifdef __cplusplus
diff -c -r Mesa-7.9/src/glsl/ast_to_hir.cpp MesaLib/src/glsl/ast_to_hir.cpp
*** Mesa-7.9/src/glsl/ast_to_hir.cpp	Fri Oct  1 15:51:28 2010
--- MesaLib/src/glsl/ast_to_hir.cpp	Fri Oct 22 15:28:47 2010
***************
*** 55,60 ****
--- 55,61 ----
  #include "ast.h"
  #include "glsl_types.h"
  #include "ir.h"
+ #include "safe_strcmp.h"
  
  void
  _mesa_ast_to_hir(exec_list *instructions, struct _mesa_glsl_parse_state *state)
***************
*** 1615,1621 ****
     var->pixel_center_integer = qual->pixel_center_integer;
     var->origin_upper_left = qual->origin_upper_left;
     if ((qual->origin_upper_left || qual->pixel_center_integer)
!        && (strcmp(var->name, "gl_FragCoord") != 0)) {
        const char *const qual_string = (qual->origin_upper_left)
  	 ? "origin_upper_left" : "pixel_center_integer";
  
--- 1616,1622 ----
     var->pixel_center_integer = qual->pixel_center_integer;
     var->origin_upper_left = qual->origin_upper_left;
     if ((qual->origin_upper_left || qual->pixel_center_integer)
!        && (safe_strcmp(var->name, "gl_FragCoord") != 0)) {
        const char *const qual_string = (qual->origin_upper_left)
  	 ? "origin_upper_left" : "pixel_center_integer";
  
***************
*** 2003,2009 ****
  	     *     gl_MaxTextureCoords."
  	     */
  	    const unsigned size = unsigned(var->type->array_size());
! 	    if ((strcmp("gl_TexCoord", var->name) == 0)
  		&& (size > state->Const.MaxTextureCoords)) {
  	       YYLTYPE loc = this->get_location();
  
--- 2004,2010 ----
  	     *     gl_MaxTextureCoords."
  	     */
  	    const unsigned size = unsigned(var->type->array_size());
! 	    if ((safe_strcmp("gl_TexCoord", var->name) == 0)
  		&& (size > state->Const.MaxTextureCoords)) {
  	       YYLTYPE loc = this->get_location();
  
***************
*** 2022,2028 ****
  	    delete var;
  	    var = NULL;
  	 } else if (state->extensions->ARB_fragment_coord_conventions
! 		    && strcmp(var->name, "gl_FragCoord") == 0
  		    && earlier->type == var->type
  		    && earlier->mode == var->mode) {
  	    /* Allow redeclaration of gl_FragCoord for ARB_fcc layout
--- 2023,2029 ----
  	    delete var;
  	    var = NULL;
  	 } else if (state->extensions->ARB_fragment_coord_conventions
! 		    && safe_strcmp(var->name, "gl_FragCoord") == 0
  		    && earlier->type == var->type
  		    && earlier->mode == var->mode) {
  	    /* Allow redeclaration of gl_FragCoord for ARB_fcc layout
***************
*** 2336,2342 ****
     }
  
     /* Verify the return type of main() */
!    if (strcmp(name, "main") == 0) {
        if (! return_type->is_void()) {
  	 YYLTYPE loc = this->get_location();
  
--- 2337,2343 ----
     }
  
     /* Verify the return type of main() */
!    if (safe_strcmp(name, "main") == 0) {
        if (! return_type->is_void()) {
  	 YYLTYPE loc = this->get_location();
  
diff -c -r Mesa-7.9/src/glsl/glcpp/glcpp-parse.c MesaLib/src/glsl/glcpp/glcpp-parse.c
*** Mesa-7.9/src/glsl/glcpp/glcpp-parse.c	Fri Oct  1 15:51:28 2010
--- MesaLib/src/glsl/glcpp/glcpp-parse.c	Fri Oct 22 15:30:59 2010
***************
*** 96,106 ****
--- 96,114 ----
  #include <stdlib.h>
  #include <string.h>
  #include <assert.h>
+ /* The #include of inttypes.h causes problems on Windows */
+ #ifndef _MSC_VER
  #include <inttypes.h>
+ #endif
+ /* Windows headers do not define PRIiMAX */
+ #ifdef _MSC_VER
+ #define PRIiMAX "I64i"
+ #endif
  
  #include "glcpp.h"
  #include "main/core.h" /* for struct gl_extensions */
  #include "main/mtypes.h" /* for gl_api enum */
+ #include "safe_strcmp.h"
  
  #define glcpp_print(stream, str) stream = talloc_strdup_append(stream, str)
  #define glcpp_printf(stream, fmt, args, ...) \
***************
*** 2915,2921 ****
  		return 0;
  
  	for (i = 0, node = list->head; node; i++, node = node->next) {
! 		if (strcmp (node->str, member) == 0) {
  			if (index)
  				*index = i;
  			return 1;
--- 2923,2929 ----
  		return 0;
  
  	for (i = 0, node = list->head; node; i++, node = node->next) {
! 		if (safe_strcmp (node->str, member) == 0) {
  			if (index)
  				*index = i;
  			return 1;
***************
*** 2955,2961 ****
  	     node_a && node_b;
  	     node_a = node_a->next, node_b = node_b->next)
  	{
! 		if (strcmp (node_a->str, node_b->str))
  			return 0;
  	}
  
--- 2963,2969 ----
  	     node_a && node_b;
  	     node_a = node_a->next, node_b = node_b->next)
  	{
! 		if (safe_strcmp (node_a->str, node_b->str))
  			return 0;
  	}
  
***************
*** 3182,3189 ****
  		case IDENTIFIER:
  		case INTEGER_STRING:
  		case OTHER:
! 			if (strcmp (node_a->token->value.str,
! 				    node_b->token->value.str))
  			{
  				return 0;
  			}
--- 3190,3197 ----
  		case IDENTIFIER:
  		case INTEGER_STRING:
  		case OTHER:
! 			if (safe_strcmp (node_a->token->value.str,
! 					 node_b->token->value.str))
  			{
  				return 0;
  			}
***************
*** 3832,3838 ****
  		return 0;
  
  	for (node = list; node; node = node->next)
! 		if (strcmp (node->identifier, identifier) == 0)
  			return 1;
  
  	return 0;
--- 3840,3846 ----
  		return 0;
  
  	for (node = list; node; node = node->next)
! 		if (safe_strcmp (node->identifier, identifier) == 0)
  			return 1;
  
  	return 0;
diff -c -r Mesa-7.9/src/glsl/glcpp/glcpp-parse.y MesaLib/src/glsl/glcpp/glcpp-parse.y
*** Mesa-7.9/src/glsl/glcpp/glcpp-parse.y	Fri Oct  1 15:51:28 2010
--- MesaLib/src/glsl/glcpp/glcpp-parse.y	Fri Oct 22 15:30:47 2010
***************
*** 26,36 ****
--- 26,44 ----
  #include <stdlib.h>
  #include <string.h>
  #include <assert.h>
+ /* The #include of inttypes.h causes problems on Windows */
+ #ifndef _MSC_VER
  #include <inttypes.h>
+ #endif
+ /* Windows headers do not define PRIiMAX */
+ #ifdef _MSC_VER
+ #define PRIiMAX "I64i"
+ #endif
  
  #include "glcpp.h"
  #include "main/core.h" /* for struct gl_extensions */
  #include "main/mtypes.h" /* for gl_api enum */
+ #include "safe_strcmp.h"
  
  #define glcpp_print(stream, str) stream = talloc_strdup_append(stream, str)
  #define glcpp_printf(stream, fmt, args, ...) \
***************
*** 590,596 ****
  		return 0;
  
  	for (i = 0, node = list->head; node; i++, node = node->next) {
! 		if (strcmp (node->str, member) == 0) {
  			if (index)
  				*index = i;
  			return 1;
--- 598,604 ----
  		return 0;
  
  	for (i = 0, node = list->head; node; i++, node = node->next) {
! 		if (safe_strcmp (node->str, member) == 0) {
  			if (index)
  				*index = i;
  			return 1;
***************
*** 630,636 ****
  	     node_a && node_b;
  	     node_a = node_a->next, node_b = node_b->next)
  	{
! 		if (strcmp (node_a->str, node_b->str))
  			return 0;
  	}
  
--- 638,644 ----
  	     node_a && node_b;
  	     node_a = node_a->next, node_b = node_b->next)
  	{
! 		if (safe_strcmp (node_a->str, node_b->str))
  			return 0;
  	}
  
***************
*** 857,864 ****
  		case IDENTIFIER:
  		case INTEGER_STRING:
  		case OTHER:
! 			if (strcmp (node_a->token->value.str,
! 				    node_b->token->value.str))
  			{
  				return 0;
  			}
--- 865,872 ----
  		case IDENTIFIER:
  		case INTEGER_STRING:
  		case OTHER:
! 			if (safe_strcmp (node_a->token->value.str,
! 					 node_b->token->value.str))
  			{
  				return 0;
  			}
***************
*** 1507,1513 ****
  		return 0;
  
  	for (node = list; node; node = node->next)
! 		if (strcmp (node->identifier, identifier) == 0)
  			return 1;
  
  	return 0;
--- 1515,1521 ----
  		return 0;
  
  	for (node = list; node; node = node->next)
! 		if (safe_strcmp (node->identifier, identifier) == 0)
  			return 1;
  
  	return 0;
diff -c -r Mesa-7.9/src/glsl/glcpp/glcpp.c MesaLib/src/glsl/glcpp/glcpp.c
*** Mesa-7.9/src/glsl/glcpp/glcpp.c	Fri Oct  1 15:51:28 2010
--- MesaLib/src/glsl/glcpp/glcpp.c	Fri Oct 22 15:31:25 2010
***************
*** 29,34 ****
--- 29,35 ----
  #include <errno.h>
  #include "glcpp.h"
  #include "main/mtypes.h"
+ #include "safe_strcmp.h"
  
  extern int yydebug;
  
***************
*** 78,84 ****
  	char *text;
  	int fd;
  
! 	if (filename == NULL || strcmp (filename, "-") == 0)
  		return load_text_fd (ctx, STDIN_FILENO);
  
  	fd = open (filename, O_RDONLY);
--- 79,85 ----
  	char *text;
  	int fd;
  
! 	if (filename == NULL || safe_strcmp (filename, "-") == 0)
  		return load_text_fd (ctx, STDIN_FILENO);
  
  	fd = open (filename, O_RDONLY);
diff -c -r Mesa-7.9/src/glsl/glcpp/glcpp.h MesaLib/src/glsl/glcpp/glcpp.h
*** Mesa-7.9/src/glsl/glcpp/glcpp.h	Fri Oct  1 15:51:28 2010
--- MesaLib/src/glsl/glcpp/glcpp.h	Fri Oct 22 15:32:43 2010
***************
*** 24,30 ****
--- 24,33 ----
  #ifndef GLCPP_H
  #define GLCPP_H
  
+ /* Windows does not currently have stdint.h. */
+ #ifndef _MSC_VER
  #include <stdint.h>
+ #endif
  
  #include <talloc.h>
  
***************
*** 49,55 ****
--- 52,62 ----
  
  typedef union YYSTYPE
  {
+ #ifndef _MSC_VER
  	intmax_t ival;
+ #else
+         __int64 ival;
+ #endif
  	char *str;
  	string_list_t *string_list;
  	token_t *token;
diff -c -r Mesa-7.9/src/glsl/glsl_parser.cpp MesaLib/src/glsl/glsl_parser.cpp
*** Mesa-7.9/src/glsl/glsl_parser.cpp	Fri Oct  1 15:51:28 2010
--- MesaLib/src/glsl/glsl_parser.cpp	Fri Oct 22 15:33:24 2010
***************
*** 107,112 ****
--- 107,113 ----
  #include "ast.h"
  #include "glsl_parser_extras.h"
  #include "glsl_types.h"
+ #include "safe_strcmp.h"
  
  #define YYLEX_PARAM state->scanner
  
***************
*** 3966,3975 ****
  	   if (state->ARB_fragment_coord_conventions_enable) {
  	      bool got_one = false;
  
! 	      if (strcmp((yyvsp[(1) - (1)].identifier), "origin_upper_left") == 0) {
  		 got_one = true;
  		 (yyval.type_qualifier).q.origin_upper_left = 1;
! 	      } else if (strcmp((yyvsp[(1) - (1)].identifier), "pixel_center_integer") == 0) {
  		 got_one = true;
  		 (yyval.type_qualifier).q.pixel_center_integer = 1;
  	      }
--- 3967,3976 ----
  	   if (state->ARB_fragment_coord_conventions_enable) {
  	      bool got_one = false;
  
! 	      if (safe_strcmp((yyvsp[(1) - (1)].identifier), "origin_upper_left") == 0) {
  		 got_one = true;
  		 (yyval.type_qualifier).q.origin_upper_left = 1;
! 	      } else if (safe_strcmp((yyvsp[(1) - (1)].identifier), "pixel_center_integer") == 0) {
  		 got_one = true;
  		 (yyval.type_qualifier).q.pixel_center_integer = 1;
  	      }
diff -c -r Mesa-7.9/src/glsl/glsl_parser_extras.cpp MesaLib/src/glsl/glsl_parser_extras.cpp
*** Mesa-7.9/src/glsl/glsl_parser_extras.cpp	Fri Oct  1 15:51:28 2010
--- MesaLib/src/glsl/glsl_parser_extras.cpp	Fri Oct 22 15:33:37 2010
***************
*** 35,40 ****
--- 35,41 ----
  #include "glsl_parser.h"
  #include "ir_optimization.h"
  #include "loop_analysis.h"
+ #include "safe_strcmp.h"
  
  _mesa_glsl_parse_state::_mesa_glsl_parse_state(struct __GLcontextRec *ctx,
  					       GLenum target, void *mem_ctx)
***************
*** 148,160 ****
        extension_warn
     } ext_mode;
  
!    if (strcmp(behavior, "warn") == 0) {
        ext_mode = extension_warn;
!    } else if (strcmp(behavior, "require") == 0) {
        ext_mode = extension_require;
!    } else if (strcmp(behavior, "enable") == 0) {
        ext_mode = extension_enable;
!    } else if (strcmp(behavior, "disable") == 0) {
        ext_mode = extension_disable;
     } else {
        _mesa_glsl_error(behavior_locp, state,
--- 149,161 ----
        extension_warn
     } ext_mode;
  
!    if (safe_strcmp(behavior, "warn") == 0) {
        ext_mode = extension_warn;
!    } else if (safe_strcmp(behavior, "require") == 0) {
        ext_mode = extension_require;
!    } else if (safe_strcmp(behavior, "enable") == 0) {
        ext_mode = extension_enable;
!    } else if (safe_strcmp(behavior, "disable") == 0) {
        ext_mode = extension_disable;
     } else {
        _mesa_glsl_error(behavior_locp, state,
***************
*** 165,178 ****
  
     bool unsupported = false;
  
!    if (strcmp(name, "all") == 0) {
        if ((ext_mode == extension_enable) || (ext_mode == extension_require)) {
  	 _mesa_glsl_error(name_locp, state, "Cannot %s all extensions",
  			  (ext_mode == extension_enable)
  			  ? "enable" : "require");
  	 return false;
        }
!    } else if (strcmp(name, "GL_ARB_draw_buffers") == 0) {
        /* This extension is only supported in fragment shaders.
         */
        if (state->target != fragment_shader) {
--- 166,179 ----
  
     bool unsupported = false;
  
!    if (safe_strcmp(name, "all") == 0) {
        if ((ext_mode == extension_enable) || (ext_mode == extension_require)) {
  	 _mesa_glsl_error(name_locp, state, "Cannot %s all extensions",
  			  (ext_mode == extension_enable)
  			  ? "enable" : "require");
  	 return false;
        }
!    } else if (safe_strcmp(name, "GL_ARB_draw_buffers") == 0) {
        /* This extension is only supported in fragment shaders.
         */
        if (state->target != fragment_shader) {
***************
*** 181,197 ****
  	 state->ARB_draw_buffers_enable = (ext_mode != extension_disable);
  	 state->ARB_draw_buffers_warn = (ext_mode == extension_warn);
        }
!    } else if (strcmp(name, "GL_ARB_fragment_coord_conventions") == 0) {
        state->ARB_fragment_coord_conventions_enable =
  	 (ext_mode != extension_disable);
        state->ARB_fragment_coord_conventions_warn =
  	 (ext_mode == extension_warn);
  
        unsupported = !state->extensions->ARB_fragment_coord_conventions;
!    } else if (strcmp(name, "GL_ARB_texture_rectangle") == 0) {
        state->ARB_texture_rectangle_enable = (ext_mode != extension_disable);
        state->ARB_texture_rectangle_warn = (ext_mode == extension_warn);
!    } else if (strcmp(name, "GL_EXT_texture_array") == 0) {
        state->EXT_texture_array_enable = (ext_mode != extension_disable);
        state->EXT_texture_array_warn = (ext_mode == extension_warn);
  
--- 182,198 ----
  	 state->ARB_draw_buffers_enable = (ext_mode != extension_disable);
  	 state->ARB_draw_buffers_warn = (ext_mode == extension_warn);
        }
!    } else if (safe_strcmp(name, "GL_ARB_fragment_coord_conventions") == 0) {
        state->ARB_fragment_coord_conventions_enable =
  	 (ext_mode != extension_disable);
        state->ARB_fragment_coord_conventions_warn =
  	 (ext_mode == extension_warn);
  
        unsupported = !state->extensions->ARB_fragment_coord_conventions;
!    } else if (safe_strcmp(name, "GL_ARB_texture_rectangle") == 0) {
        state->ARB_texture_rectangle_enable = (ext_mode != extension_disable);
        state->ARB_texture_rectangle_warn = (ext_mode == extension_warn);
!    } else if (safe_strcmp(name, "GL_EXT_texture_array") == 0) {
        state->EXT_texture_array_enable = (ext_mode != extension_disable);
        state->EXT_texture_array_warn = (ext_mode == extension_warn);
  
diff -c -r Mesa-7.9/src/glsl/glsl_types.cpp MesaLib/src/glsl/glsl_types.cpp
*** Mesa-7.9/src/glsl/glsl_types.cpp	Fri Oct  1 15:51:28 2010
--- MesaLib/src/glsl/glsl_types.cpp	Fri Oct 22 15:33:51 2010
***************
*** 27,32 ****
--- 27,33 ----
  #include "glsl_symbol_table.h"
  #include "glsl_parser_extras.h"
  #include "glsl_types.h"
+ #include "safe_strcmp.h"
  #include "builtin_types.h"
  extern "C" {
  #include "program/hash_table.h"
***************
*** 374,380 ****
     /* Return zero is the types match (there is zero difference) or non-zero
      * otherwise.
      */
!    if (strcmp(key1->name, key2->name) != 0)
        return 1;
  
     if (key1->length != key2->length)
--- 375,381 ----
     /* Return zero is the types match (there is zero difference) or non-zero
      * otherwise.
      */
!    if (safe_strcmp(key1->name, key2->name) != 0)
        return 1;
  
     if (key1->length != key2->length)
***************
*** 383,389 ****
     for (unsigned i = 0; i < key1->length; i++) {
        if (key1->fields.structure[i].type != key2->fields.structure[i].type)
  	 return 1;
!       if (strcmp(key1->fields.structure[i].name,
  		 key2->fields.structure[i].name) != 0)
  	 return 1;
     }
--- 384,390 ----
     for (unsigned i = 0; i < key1->length; i++) {
        if (key1->fields.structure[i].type != key2->fields.structure[i].type)
  	 return 1;
!       if (safe_strcmp(key1->fields.structure[i].name,
  		 key2->fields.structure[i].name) != 0)
  	 return 1;
     }
***************
*** 433,439 ****
  
     assert(t->base_type == GLSL_TYPE_STRUCT);
     assert(t->length == num_fields);
!    assert(strcmp(t->name, name) == 0);
  
     return t;
  }
--- 434,440 ----
  
     assert(t->base_type == GLSL_TYPE_STRUCT);
     assert(t->length == num_fields);
!    assert(safe_strcmp(t->name, name) == 0);
  
     return t;
  }
***************
*** 446,452 ****
        return error_type;
  
     for (unsigned i = 0; i < this->length; i++) {
!       if (strcmp(name, this->fields.structure[i].name) == 0)
  	 return this->fields.structure[i].type;
     }
  
--- 447,453 ----
        return error_type;
  
     for (unsigned i = 0; i < this->length; i++) {
!       if (safe_strcmp(name, this->fields.structure[i].name) == 0)
  	 return this->fields.structure[i].type;
     }
  
***************
*** 461,467 ****
        return -1;
  
     for (unsigned i = 0; i < this->length; i++) {
!       if (strcmp(name, this->fields.structure[i].name) == 0)
  	 return i;
     }
  
--- 462,468 ----
        return -1;
  
     for (unsigned i = 0; i < this->length; i++) {
!       if (safe_strcmp(name, this->fields.structure[i].name) == 0)
  	 return i;
     }
  
diff -c -r Mesa-7.9/src/glsl/hir_field_selection.cpp MesaLib/src/glsl/hir_field_selection.cpp
*** Mesa-7.9/src/glsl/hir_field_selection.cpp	Fri Oct  1 15:51:28 2010
--- MesaLib/src/glsl/hir_field_selection.cpp	Fri Oct 22 15:34:11 2010
***************
*** 26,31 ****
--- 26,32 ----
  #include "glsl_parser_extras.h"
  #include "ast.h"
  #include "glsl_types.h"
+ #include "safe_strcmp.h"
  
  ir_rvalue *
  _mesa_ast_field_selection_to_hir(const ast_expression *expr,
***************
*** 81,87 ****
        const char *method;
        method = call->subexpressions[0]->primary_expression.identifier;
  
!       if (op->type->is_array() && strcmp(method, "length") == 0) {
  	 if (!call->expressions.is_empty())
  	    _mesa_glsl_error(&loc, state, "length method takes no arguments.");
  
--- 82,88 ----
        const char *method;
        method = call->subexpressions[0]->primary_expression.identifier;
  
!       if (op->type->is_array() && safe_strcmp(method, "length") == 0) {
  	 if (!call->expressions.is_empty())
  	    _mesa_glsl_error(&loc, state, "length method takes no arguments.");
  
diff -c -r Mesa-7.9/src/glsl/ir.cpp MesaLib/src/glsl/ir.cpp
*** Mesa-7.9/src/glsl/ir.cpp	Fri Oct  1 15:51:28 2010
--- MesaLib/src/glsl/ir.cpp	Fri Oct 22 15:34:20 2010
***************
*** 25,30 ****
--- 25,31 ----
  #include "ir.h"
  #include "ir_visitor.h"
  #include "glsl_types.h"
+ #include "safe_strcmp.h"
  
  ir_rvalue::ir_rvalue()
  {
***************
*** 338,344 ****
  {
     const int operator_count = sizeof(operator_strs) / sizeof(operator_strs[0]);
     for (int op = 0; op < operator_count; op++) {
!       if (strcmp(str, operator_strs[op]) == 0)
  	 return (ir_expression_operation) op;
     }
     return (ir_expression_operation) -1;
--- 339,345 ----
  {
     const int operator_count = sizeof(operator_strs) / sizeof(operator_strs[0]);
     for (int op = 0; op < operator_count; op++) {
!       if (safe_strcmp(str, operator_strs[op]) == 0)
  	 return (ir_expression_operation) op;
     }
     return (ir_expression_operation) -1;
***************
*** 878,884 ****
  {
     const int count = sizeof(tex_opcode_strs) / sizeof(tex_opcode_strs[0]);
     for (int op = 0; op < count; op++) {
!       if (strcmp(str, tex_opcode_strs[op]) == 0)
  	 return (ir_texture_opcode) op;
     }
     return (ir_texture_opcode) -1;
--- 879,885 ----
  {
     const int count = sizeof(tex_opcode_strs) / sizeof(tex_opcode_strs[0]);
     for (int op = 0; op < count; op++) {
!       if (safe_strcmp(str, tex_opcode_strs[op]) == 0)
  	 return (ir_texture_opcode) op;
     }
     return (ir_texture_opcode) -1;
diff -c -r Mesa-7.9/src/glsl/ir_constant_expression.cpp MesaLib/src/glsl/ir_constant_expression.cpp
*** Mesa-7.9/src/glsl/ir_constant_expression.cpp	Fri Oct  1 15:51:28 2010
--- MesaLib/src/glsl/ir_constant_expression.cpp	Fri Oct 22 15:34:40 2010
***************
*** 38,43 ****
--- 38,44 ----
  #include "ir.h"
  #include "ir_visitor.h"
  #include "glsl_types.h"
+ #include "safe_strcmp.h"
  
  static float
  dot(ir_constant *op0, ir_constant *op1)
***************
*** 850,880 ****
     memset(&data, 0, sizeof(data));
  
     const char *callee = this->callee_name();
!    if (strcmp(callee, "abs") == 0) {
        expr = new(mem_ctx) ir_expression(ir_unop_abs, type, op[0], NULL);
!    } else if (strcmp(callee, "all") == 0) {
        assert(op[0]->type->is_boolean());
        for (unsigned c = 0; c < op[0]->type->components(); c++) {
  	 if (!op[0]->value.b[c])
  	    return new(mem_ctx) ir_constant(false);
        }
        return new(mem_ctx) ir_constant(true);
!    } else if (strcmp(callee, "any") == 0) {
        assert(op[0]->type->is_boolean());
        for (unsigned c = 0; c < op[0]->type->components(); c++) {
  	 if (op[0]->value.b[c])
  	    return new(mem_ctx) ir_constant(true);
        }
        return new(mem_ctx) ir_constant(false);
!    } else if (strcmp(callee, "acos") == 0) {
        assert(op[0]->type->is_float());
        for (unsigned c = 0; c < op[0]->type->components(); c++)
  	 data.f[c] = acosf(op[0]->value.f[c]);
!    } else if (strcmp(callee, "asin") == 0) {
        assert(op[0]->type->is_float());
        for (unsigned c = 0; c < op[0]->type->components(); c++)
  	 data.f[c] = asinf(op[0]->value.f[c]);
!    } else if (strcmp(callee, "atan") == 0) {
        assert(op[0]->type->is_float());
        if (num_parameters == 2) {
  	 assert(op[1]->type->is_float());
--- 851,881 ----
     memset(&data, 0, sizeof(data));
  
     const char *callee = this->callee_name();
!    if (safe_strcmp(callee, "abs") == 0) {
        expr = new(mem_ctx) ir_expression(ir_unop_abs, type, op[0], NULL);
!    } else if (safe_strcmp(callee, "all") == 0) {
        assert(op[0]->type->is_boolean());
        for (unsigned c = 0; c < op[0]->type->components(); c++) {
  	 if (!op[0]->value.b[c])
  	    return new(mem_ctx) ir_constant(false);
        }
        return new(mem_ctx) ir_constant(true);
!    } else if (safe_strcmp(callee, "any") == 0) {
        assert(op[0]->type->is_boolean());
        for (unsigned c = 0; c < op[0]->type->components(); c++) {
  	 if (op[0]->value.b[c])
  	    return new(mem_ctx) ir_constant(true);
        }
        return new(mem_ctx) ir_constant(false);
!    } else if (safe_strcmp(callee, "acos") == 0) {
        assert(op[0]->type->is_float());
        for (unsigned c = 0; c < op[0]->type->components(); c++)
  	 data.f[c] = acosf(op[0]->value.f[c]);
!    } else if (safe_strcmp(callee, "asin") == 0) {
        assert(op[0]->type->is_float());
        for (unsigned c = 0; c < op[0]->type->components(); c++)
  	 data.f[c] = asinf(op[0]->value.f[c]);
!    } else if (safe_strcmp(callee, "atan") == 0) {
        assert(op[0]->type->is_float());
        if (num_parameters == 2) {
  	 assert(op[1]->type->is_float());
***************
*** 884,894 ****
  	 for (unsigned c = 0; c < op[0]->type->components(); c++)
  	    data.f[c] = atanf(op[0]->value.f[c]);
        }
!    } else if (strcmp(callee, "dFdx") == 0 || strcmp(callee, "dFdy") == 0) {
        return ir_constant::zero(mem_ctx, this->type);
!    } else if (strcmp(callee, "ceil") == 0) {
        expr = new(mem_ctx) ir_expression(ir_unop_ceil, type, op[0], NULL);
!    } else if (strcmp(callee, "clamp") == 0) {
        assert(num_parameters == 3);
        unsigned c1_inc = op[1]->type->is_scalar() ? 0 : 1;
        unsigned c2_inc = op[2]->type->is_scalar() ? 0 : 1;
--- 885,895 ----
  	 for (unsigned c = 0; c < op[0]->type->components(); c++)
  	    data.f[c] = atanf(op[0]->value.f[c]);
        }
!    } else if (safe_strcmp(callee, "dFdx") == 0 || safe_strcmp(callee, "dFdy") == 0) {
        return ir_constant::zero(mem_ctx, this->type);
!    } else if (safe_strcmp(callee, "ceil") == 0) {
        expr = new(mem_ctx) ir_expression(ir_unop_ceil, type, op[0], NULL);
!    } else if (safe_strcmp(callee, "clamp") == 0) {
        assert(num_parameters == 3);
        unsigned c1_inc = op[1]->type->is_scalar() ? 0 : 1;
        unsigned c2_inc = op[2]->type->is_scalar() ? 0 : 1;
***************
*** 913,931 ****
  	    assert(!"Should not get here.");
  	 }
        }
!    } else if (strcmp(callee, "cos") == 0) {
        expr = new(mem_ctx) ir_expression(ir_unop_cos, type, op[0], NULL);
!    } else if (strcmp(callee, "cosh") == 0) {
        assert(op[0]->type->is_float());
        for (unsigned c = 0; c < op[0]->type->components(); c++)
  	 data.f[c] = coshf(op[0]->value.f[c]);
!    } else if (strcmp(callee, "cross") == 0) {
        expr = new(mem_ctx) ir_expression(ir_binop_cross, type, op[0], op[1]);
!    } else if (strcmp(callee, "degrees") == 0) {
        assert(op[0]->type->is_float());
        for (unsigned c = 0; c < op[0]->type->components(); c++)
  	 data.f[c] = 180.0/M_PI * op[0]->value.f[c];
!    } else if (strcmp(callee, "distance") == 0) {
        assert(op[0]->type->is_float() && op[1]->type->is_float());
        float length_squared = 0.0;
        for (unsigned c = 0; c < op[0]->type->components(); c++) {
--- 914,932 ----
  	    assert(!"Should not get here.");
  	 }
        }
!    } else if (safe_strcmp(callee, "cos") == 0) {
        expr = new(mem_ctx) ir_expression(ir_unop_cos, type, op[0], NULL);
!    } else if (safe_strcmp(callee, "cosh") == 0) {
        assert(op[0]->type->is_float());
        for (unsigned c = 0; c < op[0]->type->components(); c++)
  	 data.f[c] = coshf(op[0]->value.f[c]);
!    } else if (safe_strcmp(callee, "cross") == 0) {
        expr = new(mem_ctx) ir_expression(ir_binop_cross, type, op[0], op[1]);
!    } else if (safe_strcmp(callee, "degrees") == 0) {
        assert(op[0]->type->is_float());
        for (unsigned c = 0; c < op[0]->type->components(); c++)
  	 data.f[c] = 180.0/M_PI * op[0]->value.f[c];
!    } else if (safe_strcmp(callee, "distance") == 0) {
        assert(op[0]->type->is_float() && op[1]->type->is_float());
        float length_squared = 0.0;
        for (unsigned c = 0; c < op[0]->type->components(); c++) {
***************
*** 933,941 ****
  	 length_squared += t * t;
        }
        return new(mem_ctx) ir_constant(sqrtf(length_squared));
!    } else if (strcmp(callee, "dot") == 0) {
        return new(mem_ctx) ir_constant(dot(op[0], op[1]));
!    } else if (strcmp(callee, "equal") == 0) {
        assert(op[0]->type->is_vector() && op[1] && op[1]->type->is_vector());
        for (unsigned c = 0; c < op[0]->type->components(); c++) {
  	 switch (op[0]->type->base_type) {
--- 934,942 ----
  	 length_squared += t * t;
        }
        return new(mem_ctx) ir_constant(sqrtf(length_squared));
!    } else if (safe_strcmp(callee, "dot") == 0) {
        return new(mem_ctx) ir_constant(dot(op[0], op[1]));
!    } else if (safe_strcmp(callee, "equal") == 0) {
        assert(op[0]->type->is_vector() && op[1] && op[1]->type->is_vector());
        for (unsigned c = 0; c < op[0]->type->components(); c++) {
  	 switch (op[0]->type->base_type) {
***************
*** 955,976 ****
  	    assert(!"Should not get here.");
  	 }
        }
!    } else if (strcmp(callee, "exp") == 0) {
        expr = new(mem_ctx) ir_expression(ir_unop_exp, type, op[0], NULL);
!    } else if (strcmp(callee, "exp2") == 0) {
        expr = new(mem_ctx) ir_expression(ir_unop_exp2, type, op[0], NULL);
!    } else if (strcmp(callee, "faceforward") == 0) {
        if (dot(op[2], op[1]) < 0)
  	 return op[0];
        for (unsigned c = 0; c < op[0]->type->components(); c++)
  	 data.f[c] = -op[0]->value.f[c];
!    } else if (strcmp(callee, "floor") == 0) {
        expr = new(mem_ctx) ir_expression(ir_unop_floor, type, op[0], NULL);
!    } else if (strcmp(callee, "fract") == 0) {
        expr = new(mem_ctx) ir_expression(ir_unop_fract, type, op[0], NULL);
!    } else if (strcmp(callee, "fwidth") == 0) {
        return ir_constant::zero(mem_ctx, this->type);
!    } else if (strcmp(callee, "greaterThan") == 0) {
        assert(op[0]->type->is_vector() && op[1] && op[1]->type->is_vector());
        for (unsigned c = 0; c < op[0]->type->components(); c++) {
  	 switch (op[0]->type->base_type) {
--- 956,977 ----
  	    assert(!"Should not get here.");
  	 }
        }
!    } else if (safe_strcmp(callee, "exp") == 0) {
        expr = new(mem_ctx) ir_expression(ir_unop_exp, type, op[0], NULL);
!    } else if (safe_strcmp(callee, "exp2") == 0) {
        expr = new(mem_ctx) ir_expression(ir_unop_exp2, type, op[0], NULL);
!    } else if (safe_strcmp(callee, "faceforward") == 0) {
        if (dot(op[2], op[1]) < 0)
  	 return op[0];
        for (unsigned c = 0; c < op[0]->type->components(); c++)
  	 data.f[c] = -op[0]->value.f[c];
!    } else if (safe_strcmp(callee, "floor") == 0) {
        expr = new(mem_ctx) ir_expression(ir_unop_floor, type, op[0], NULL);
!    } else if (safe_strcmp(callee, "fract") == 0) {
        expr = new(mem_ctx) ir_expression(ir_unop_fract, type, op[0], NULL);
!    } else if (safe_strcmp(callee, "fwidth") == 0) {
        return ir_constant::zero(mem_ctx, this->type);
!    } else if (safe_strcmp(callee, "greaterThan") == 0) {
        assert(op[0]->type->is_vector() && op[1] && op[1]->type->is_vector());
        for (unsigned c = 0; c < op[0]->type->components(); c++) {
  	 switch (op[0]->type->base_type) {
***************
*** 987,993 ****
  	    assert(!"Should not get here.");
  	 }
        }
!    } else if (strcmp(callee, "greaterThanEqual") == 0) {
        assert(op[0]->type->is_vector() && op[1] && op[1]->type->is_vector());
        for (unsigned c = 0; c < op[0]->type->components(); c++) {
  	 switch (op[0]->type->base_type) {
--- 988,994 ----
  	    assert(!"Should not get here.");
  	 }
        }
!    } else if (safe_strcmp(callee, "greaterThanEqual") == 0) {
        assert(op[0]->type->is_vector() && op[1] && op[1]->type->is_vector());
        for (unsigned c = 0; c < op[0]->type->components(); c++) {
  	 switch (op[0]->type->base_type) {
***************
*** 1004,1014 ****
  	    assert(!"Should not get here.");
  	 }
        }
!    } else if (strcmp(callee, "inversesqrt") == 0) {
        expr = new(mem_ctx) ir_expression(ir_unop_rsq, type, op[0], NULL);
!    } else if (strcmp(callee, "length") == 0) {
        return new(mem_ctx) ir_constant(sqrtf(dot(op[0], op[0])));
!    } else if (strcmp(callee, "lessThan") == 0) {
        assert(op[0]->type->is_vector() && op[1] && op[1]->type->is_vector());
        for (unsigned c = 0; c < op[0]->type->components(); c++) {
  	 switch (op[0]->type->base_type) {
--- 1005,1015 ----
  	    assert(!"Should not get here.");
  	 }
        }
!    } else if (safe_strcmp(callee, "inversesqrt") == 0) {
        expr = new(mem_ctx) ir_expression(ir_unop_rsq, type, op[0], NULL);
!    } else if (safe_strcmp(callee, "length") == 0) {
        return new(mem_ctx) ir_constant(sqrtf(dot(op[0], op[0])));
!    } else if (safe_strcmp(callee, "lessThan") == 0) {
        assert(op[0]->type->is_vector() && op[1] && op[1]->type->is_vector());
        for (unsigned c = 0; c < op[0]->type->components(); c++) {
  	 switch (op[0]->type->base_type) {
***************
*** 1025,1031 ****
  	    assert(!"Should not get here.");
  	 }
        }
!    } else if (strcmp(callee, "lessThanEqual") == 0) {
        assert(op[0]->type->is_vector() && op[1] && op[1]->type->is_vector());
        for (unsigned c = 0; c < op[0]->type->components(); c++) {
  	 switch (op[0]->type->base_type) {
--- 1026,1032 ----
  	    assert(!"Should not get here.");
  	 }
        }
!    } else if (safe_strcmp(callee, "lessThanEqual") == 0) {
        assert(op[0]->type->is_vector() && op[1] && op[1]->type->is_vector());
        for (unsigned c = 0; c < op[0]->type->components(); c++) {
  	 switch (op[0]->type->base_type) {
***************
*** 1042,1060 ****
  	    assert(!"Should not get here.");
  	 }
        }
!    } else if (strcmp(callee, "log") == 0) {
        expr = new(mem_ctx) ir_expression(ir_unop_log, type, op[0], NULL);
!    } else if (strcmp(callee, "log2") == 0) {
        expr = new(mem_ctx) ir_expression(ir_unop_log2, type, op[0], NULL);
!    } else if (strcmp(callee, "matrixCompMult") == 0) {
        assert(op[0]->type->is_float() && op[1]->type->is_float());
        for (unsigned c = 0; c < op[0]->type->components(); c++)
  	 data.f[c] = op[0]->value.f[c] * op[1]->value.f[c];
!    } else if (strcmp(callee, "max") == 0) {
        expr = new(mem_ctx) ir_expression(ir_binop_max, type, op[0], op[1]);
!    } else if (strcmp(callee, "min") == 0) {
        expr = new(mem_ctx) ir_expression(ir_binop_min, type, op[0], op[1]);
!    } else if (strcmp(callee, "mix") == 0) {
        assert(op[0]->type->is_float() && op[1]->type->is_float());
        if (op[2]->type->is_float()) {
  	 unsigned c2_inc = op[2]->type->is_scalar() ? 0 : 1;
--- 1043,1061 ----
  	    assert(!"Should not get here.");
  	 }
        }
!    } else if (safe_strcmp(callee, "log") == 0) {
        expr = new(mem_ctx) ir_expression(ir_unop_log, type, op[0], NULL);
!    } else if (safe_strcmp(callee, "log2") == 0) {
        expr = new(mem_ctx) ir_expression(ir_unop_log2, type, op[0], NULL);
!    } else if (safe_strcmp(callee, "matrixCompMult") == 0) {
        assert(op[0]->type->is_float() && op[1]->type->is_float());
        for (unsigned c = 0; c < op[0]->type->components(); c++)
  	 data.f[c] = op[0]->value.f[c] * op[1]->value.f[c];
!    } else if (safe_strcmp(callee, "max") == 0) {
        expr = new(mem_ctx) ir_expression(ir_binop_max, type, op[0], op[1]);
!    } else if (safe_strcmp(callee, "min") == 0) {
        expr = new(mem_ctx) ir_expression(ir_binop_min, type, op[0], op[1]);
!    } else if (safe_strcmp(callee, "mix") == 0) {
        assert(op[0]->type->is_float() && op[1]->type->is_float());
        if (op[2]->type->is_float()) {
  	 unsigned c2_inc = op[2]->type->is_scalar() ? 0 : 1;
***************
*** 1068,1076 ****
  	 for (unsigned c = 0; c < op[0]->type->components(); c++)
  	    data.f[c] = op[op[2]->value.b[c] ? 1 : 0]->value.f[c];
        }
!    } else if (strcmp(callee, "mod") == 0) {
        expr = new(mem_ctx) ir_expression(ir_binop_mod, type, op[0], op[1]);
!    } else if (strcmp(callee, "normalize") == 0) {
        assert(op[0]->type->is_float());
        float length = sqrtf(dot(op[0], op[0]));
  
--- 1069,1077 ----
  	 for (unsigned c = 0; c < op[0]->type->components(); c++)
  	    data.f[c] = op[op[2]->value.b[c] ? 1 : 0]->value.f[c];
        }
!    } else if (safe_strcmp(callee, "mod") == 0) {
        expr = new(mem_ctx) ir_expression(ir_binop_mod, type, op[0], op[1]);
!    } else if (safe_strcmp(callee, "normalize") == 0) {
        assert(op[0]->type->is_float());
        float length = sqrtf(dot(op[0], op[0]));
  
***************
*** 1079,1087 ****
  
        for (unsigned c = 0; c < op[0]->type->components(); c++)
  	 data.f[c] = op[0]->value.f[c] / length;
!    } else if (strcmp(callee, "not") == 0) {
        expr = new(mem_ctx) ir_expression(ir_unop_logic_not, type, op[0], NULL);
!    } else if (strcmp(callee, "notEqual") == 0) {
        assert(op[0]->type->is_vector() && op[1] && op[1]->type->is_vector());
        for (unsigned c = 0; c < op[0]->type->components(); c++) {
  	 switch (op[0]->type->base_type) {
--- 1080,1088 ----
  
        for (unsigned c = 0; c < op[0]->type->components(); c++)
  	 data.f[c] = op[0]->value.f[c] / length;
!    } else if (safe_strcmp(callee, "not") == 0) {
        expr = new(mem_ctx) ir_expression(ir_unop_logic_not, type, op[0], NULL);
!    } else if (safe_strcmp(callee, "notEqual") == 0) {
        assert(op[0]->type->is_vector() && op[1] && op[1]->type->is_vector());
        for (unsigned c = 0; c < op[0]->type->components(); c++) {
  	 switch (op[0]->type->base_type) {
***************
*** 1101,1107 ****
  	    assert(!"Should not get here.");
  	 }
        }
!    } else if (strcmp(callee, "outerProduct") == 0) {
        assert(op[0]->type->is_vector() && op[1]->type->is_vector());
        const unsigned m = op[0]->type->vector_elements;
        const unsigned n = op[1]->type->vector_elements;
--- 1102,1108 ----
  	    assert(!"Should not get here.");
  	 }
        }
!    } else if (safe_strcmp(callee, "outerProduct") == 0) {
        assert(op[0]->type->is_vector() && op[1]->type->is_vector());
        const unsigned m = op[0]->type->vector_elements;
        const unsigned n = op[1]->type->vector_elements;
***************
*** 1110,1127 ****
  	    data.f[i+m*j] = op[0]->value.f[i] * op[1]->value.f[j];
  	 }
        }
!    } else if (strcmp(callee, "pow") == 0) {
        expr = new(mem_ctx) ir_expression(ir_binop_pow, type, op[0], op[1]);
!    } else if (strcmp(callee, "radians") == 0) {
        assert(op[0]->type->is_float());
        for (unsigned c = 0; c < op[0]->type->components(); c++)
  	 data.f[c] = M_PI/180.0 * op[0]->value.f[c];
!    } else if (strcmp(callee, "reflect") == 0) {
        assert(op[0]->type->is_float());
        float dot_NI = dot(op[1], op[0]);
        for (unsigned c = 0; c < op[0]->type->components(); c++)
  	 data.f[c] = op[0]->value.f[c] - 2 * dot_NI * op[1]->value.f[c];
!    } else if (strcmp(callee, "refract") == 0) {
        const float eta = op[2]->value.f[0];
        const float dot_NI = dot(op[1], op[0]);
        const float k = 1.0 - eta * eta * (1.0 - dot_NI * dot_NI);
--- 1111,1128 ----
  	    data.f[i+m*j] = op[0]->value.f[i] * op[1]->value.f[j];
  	 }
        }
!    } else if (safe_strcmp(callee, "pow") == 0) {
        expr = new(mem_ctx) ir_expression(ir_binop_pow, type, op[0], op[1]);
!    } else if (safe_strcmp(callee, "radians") == 0) {
        assert(op[0]->type->is_float());
        for (unsigned c = 0; c < op[0]->type->components(); c++)
  	 data.f[c] = M_PI/180.0 * op[0]->value.f[c];
!    } else if (safe_strcmp(callee, "reflect") == 0) {
        assert(op[0]->type->is_float());
        float dot_NI = dot(op[1], op[0]);
        for (unsigned c = 0; c < op[0]->type->components(); c++)
  	 data.f[c] = op[0]->value.f[c] - 2 * dot_NI * op[1]->value.f[c];
!    } else if (safe_strcmp(callee, "refract") == 0) {
        const float eta = op[2]->value.f[0];
        const float dot_NI = dot(op[1], op[0]);
        const float k = 1.0 - eta * eta * (1.0 - dot_NI * dot_NI);
***************
*** 1133,1147 ****
  			    * op[1]->value.f[c];
  	 }
        }
!    } else if (strcmp(callee, "sign") == 0) {
        expr = new(mem_ctx) ir_expression(ir_unop_sign, type, op[0], NULL);
!    } else if (strcmp(callee, "sin") == 0) {
        expr = new(mem_ctx) ir_expression(ir_unop_sin, type, op[0], NULL);
!    } else if (strcmp(callee, "sinh") == 0) {
        assert(op[0]->type->is_float());
        for (unsigned c = 0; c < op[0]->type->components(); c++)
  	 data.f[c] = sinhf(op[0]->value.f[c]);
!    } else if (strcmp(callee, "smoothstep") == 0) {
        assert(num_parameters == 3);
        assert(op[1]->type == op[0]->type);
        unsigned edge_inc = op[0]->type->is_scalar() ? 0 : 1;
--- 1134,1148 ----
  			    * op[1]->value.f[c];
  	 }
        }
!    } else if (safe_strcmp(callee, "sign") == 0) {
        expr = new(mem_ctx) ir_expression(ir_unop_sign, type, op[0], NULL);
!    } else if (safe_strcmp(callee, "sin") == 0) {
        expr = new(mem_ctx) ir_expression(ir_unop_sin, type, op[0], NULL);
!    } else if (safe_strcmp(callee, "sinh") == 0) {
        assert(op[0]->type->is_float());
        for (unsigned c = 0; c < op[0]->type->components(); c++)
  	 data.f[c] = sinhf(op[0]->value.f[c]);
!    } else if (safe_strcmp(callee, "smoothstep") == 0) {
        assert(num_parameters == 3);
        assert(op[1]->type == op[0]->type);
        unsigned edge_inc = op[0]->type->is_scalar() ? 0 : 1;
***************
*** 1157,1179 ****
  	    data.f[c] = t * t * (3 - 2 * t);
  	 }
        }
!    } else if (strcmp(callee, "sqrt") == 0) {
        expr = new(mem_ctx) ir_expression(ir_unop_sqrt, type, op[0], NULL);
!    } else if (strcmp(callee, "step") == 0) {
        assert(op[0]->type->is_float() && op[1]->type->is_float());
        /* op[0] (edge) may be either a scalar or a vector */
        const unsigned c0_inc = op[0]->type->is_scalar() ? 0 : 1;
        for (unsigned c = 0, c0 = 0; c < type->components(); c0 += c0_inc, c++)
  	 data.f[c] = (op[1]->value.f[c] < op[0]->value.f[c0]) ? 0.0 : 1.0;
!    } else if (strcmp(callee, "tan") == 0) {
        assert(op[0]->type->is_float());
        for (unsigned c = 0; c < op[0]->type->components(); c++)
  	 data.f[c] = tanf(op[0]->value.f[c]);
!    } else if (strcmp(callee, "tanh") == 0) {
        assert(op[0]->type->is_float());
        for (unsigned c = 0; c < op[0]->type->components(); c++)
  	 data.f[c] = tanhf(op[0]->value.f[c]);
!    } else if (strcmp(callee, "transpose") == 0) {
        assert(op[0]->type->is_matrix());
        const unsigned n = op[0]->type->vector_elements;
        const unsigned m = op[0]->type->matrix_columns;
--- 1158,1180 ----
  	    data.f[c] = t * t * (3 - 2 * t);
  	 }
        }
!    } else if (safe_strcmp(callee, "sqrt") == 0) {
        expr = new(mem_ctx) ir_expression(ir_unop_sqrt, type, op[0], NULL);
!    } else if (safe_strcmp(callee, "step") == 0) {
        assert(op[0]->type->is_float() && op[1]->type->is_float());
        /* op[0] (edge) may be either a scalar or a vector */
        const unsigned c0_inc = op[0]->type->is_scalar() ? 0 : 1;
        for (unsigned c = 0, c0 = 0; c < type->components(); c0 += c0_inc, c++)
  	 data.f[c] = (op[1]->value.f[c] < op[0]->value.f[c0]) ? 0.0 : 1.0;
!    } else if (safe_strcmp(callee, "tan") == 0) {
        assert(op[0]->type->is_float());
        for (unsigned c = 0; c < op[0]->type->components(); c++)
  	 data.f[c] = tanf(op[0]->value.f[c]);
!    } else if (safe_strcmp(callee, "tanh") == 0) {
        assert(op[0]->type->is_float());
        for (unsigned c = 0; c < op[0]->type->components(); c++)
  	 data.f[c] = tanhf(op[0]->value.f[c]);
!    } else if (safe_strcmp(callee, "transpose") == 0) {
        assert(op[0]->type->is_matrix());
        const unsigned n = op[0]->type->vector_elements;
        const unsigned m = op[0]->type->matrix_columns;
diff -c -r Mesa-7.9/src/glsl/ir_dead_functions.cpp MesaLib/src/glsl/ir_dead_functions.cpp
*** Mesa-7.9/src/glsl/ir_dead_functions.cpp	Fri Oct  1 15:51:28 2010
--- MesaLib/src/glsl/ir_dead_functions.cpp	Fri Oct 22 15:34:54 2010
***************
*** 31,36 ****
--- 31,37 ----
   #include "ir_visitor.h"
   #include "ir_expression_flattening.h"
   #include "glsl_types.h"
+  #include "safe_strcmp.h"
  
   class signature_entry : public exec_node
   {
***************
*** 90,96 ****
   {
      signature_entry *entry = this->get_signature_entry(ir);
  
!     if (strcmp(ir->function_name(), "main") == 0) {
         entry->used = true;
      }
  
--- 91,97 ----
   {
      signature_entry *entry = this->get_signature_entry(ir);
  
!     if (safe_strcmp(ir->function_name(), "main") == 0) {
         entry->used = true;
      }
  
diff -c -r Mesa-7.9/src/glsl/ir_function_inlining.cpp MesaLib/src/glsl/ir_function_inlining.cpp
*** Mesa-7.9/src/glsl/ir_function_inlining.cpp	Fri Oct  1 15:51:28 2010
--- MesaLib/src/glsl/ir_function_inlining.cpp	Fri Oct 22 15:35:58 2010
***************
*** 27,33 ****
   * Replaces calls to functions with the body of the function.
   */
  
! #include <inttypes.h>
  #include "ir.h"
  #include "ir_visitor.h"
  #include "ir_function_inlining.h"
--- 27,34 ----
   * Replaces calls to functions with the body of the function.
   */
  
! /* The use of inttypes.h seems to be unnecessary and causes problems on Windows. */
! /* #include <inttypes.h> */
  #include "ir.h"
  #include "ir_visitor.h"
  #include "ir_function_inlining.h"
diff -c -r Mesa-7.9/src/glsl/ir_lower_jumps.cpp MesaLib/src/glsl/ir_lower_jumps.cpp
*** Mesa-7.9/src/glsl/ir_lower_jumps.cpp	Fri Oct  1 15:51:28 2010
--- MesaLib/src/glsl/ir_lower_jumps.cpp	Fri Oct 22 15:36:16 2010
***************
*** 28,33 ****
--- 28,34 ----
  #include "glsl_types.h"
  #include <string.h>
  #include "ir.h"
+ #include "safe_strcmp.h"
  
  enum jump_strength
  {
***************
*** 125,131 ****
        this->return_flag = 0;
        this->return_value = 0;
        this->nesting_depth = 0;
!       this->is_main = this->signature && (strcmp(this->signature->function_name(), "main") == 0);
     }
  
     ir_variable* get_return_flag()
--- 126,132 ----
        this->return_flag = 0;
        this->return_value = 0;
        this->nesting_depth = 0;
!       this->is_main = this->signature && (safe_strcmp(this->signature->function_name(), "main") == 0);
     }
  
     ir_variable* get_return_flag()
diff -c -r Mesa-7.9/src/glsl/ir_reader.cpp MesaLib/src/glsl/ir_reader.cpp
*** Mesa-7.9/src/glsl/ir_reader.cpp	Fri Oct  1 15:51:28 2010
--- MesaLib/src/glsl/ir_reader.cpp	Fri Oct 22 15:36:27 2010
***************
*** 31,36 ****
--- 31,37 ----
  #include "glsl_parser_extras.h"
  #include "glsl_types.h"
  #include "s_expression.h"
+ #include "safe_strcmp.h"
  
  const static bool debug = false;
  
***************
*** 128,134 ****
  	 ir_read_error(st, expr, "expected type (array ...) or (struct ...)");
  	 return NULL;
        }
!       if (strcmp(type_sym->value(), "array") == 0) {
  	 if (list->length() != 3) {
  	    ir_read_error(st, expr, "expected type (array <type> <int>)");
  	    return NULL;
--- 129,135 ----
  	 ir_read_error(st, expr, "expected type (array ...) or (struct ...)");
  	 return NULL;
        }
!       if (safe_strcmp(type_sym->value(), "array") == 0) {
  	 if (list->length() != 3) {
  	    ir_read_error(st, expr, "expected type (array <type> <int>)");
  	    return NULL;
***************
*** 150,156 ****
  	 }
  
  	 return glsl_type::get_array_instance(base_type, size->value());
!       } else if (strcmp(type_sym->value(), "struct") == 0) {
  	 assert(false); // FINISHME
        } else {
  	 ir_read_error(st, expr, "expected (array ...) or (struct ...); "
--- 151,157 ----
  	 }
  
  	 return glsl_type::get_array_instance(base_type, size->value());
!       } else if (safe_strcmp(type_sym->value(), "struct") == 0) {
  	 assert(false); // FINISHME
        } else {
  	 ir_read_error(st, expr, "expected (array ...) or (struct ...); "
***************
*** 189,195 ****
  	 continue; // not a (function ...); ignore it.
  
        s_symbol *tag = SX_AS_SYMBOL(sub->subexpressions.get_head());
!       if (tag == NULL || strcmp(tag->value(), "function") != 0)
  	 continue; // not a (function ...); ignore it.
  
        ir_function *f = read_function(st, sub, true);
--- 190,196 ----
  	 continue; // not a (function ...); ignore it.
  
        s_symbol *tag = SX_AS_SYMBOL(sub->subexpressions.get_head());
!       if (tag == NULL || safe_strcmp(tag->value(), "function") != 0)
  	 continue; // not a (function ...); ignore it.
  
        ir_function *f = read_function(st, sub, true);
***************
*** 233,239 ****
        }
  
        s_symbol *tag = SX_AS_SYMBOL(siglist->subexpressions.get_head());
!       if (tag == NULL || strcmp(tag->value(), "signature") != 0) {
  	 ir_read_error(st, siglist, "Expected (signature ...)");
  	 return NULL;
        }
--- 234,240 ----
        }
  
        s_symbol *tag = SX_AS_SYMBOL(siglist->subexpressions.get_head());
!       if (tag == NULL || safe_strcmp(tag->value(), "signature") != 0) {
  	 ir_read_error(st, siglist, "Expected (signature ...)");
  	 return NULL;
        }
***************
*** 267,273 ****
        return;
     }
     s_symbol *paramtag = SX_AS_SYMBOL(paramlist->subexpressions.get_head());
!    if (paramtag == NULL || strcmp(paramtag->value(), "parameters") != 0) {
        ir_read_error(st, paramlist, "Expected (parameters ...)");
        return;
     }
--- 268,274 ----
        return;
     }
     s_symbol *paramtag = SX_AS_SYMBOL(paramlist->subexpressions.get_head());
!    if (paramtag == NULL || safe_strcmp(paramtag->value(), "parameters") != 0) {
        ir_read_error(st, paramlist, "Expected (parameters ...)");
        return;
     }
***************
*** 364,372 ****
     void *ctx = st;
     s_symbol *symbol = SX_AS_SYMBOL(expr);
     if (symbol != NULL) {
!       if (strcmp(symbol->value(), "break") == 0 && loop_ctx != NULL)
  	 return new(ctx) ir_loop_jump(ir_loop_jump::jump_break);
!       if (strcmp(symbol->value(), "continue") == 0 && loop_ctx != NULL)
  	 return new(ctx) ir_loop_jump(ir_loop_jump::jump_continue);
     }
  
--- 365,373 ----
     void *ctx = st;
     s_symbol *symbol = SX_AS_SYMBOL(expr);
     if (symbol != NULL) {
!       if (safe_strcmp(symbol->value(), "break") == 0 && loop_ctx != NULL)
  	 return new(ctx) ir_loop_jump(ir_loop_jump::jump_break);
!       if (safe_strcmp(symbol->value(), "continue") == 0 && loop_ctx != NULL)
  	 return new(ctx) ir_loop_jump(ir_loop_jump::jump_continue);
     }
  
***************
*** 383,399 ****
     }
  
     ir_instruction *inst = NULL;
!    if (strcmp(tag->value(), "declare") == 0) {
        inst = read_declaration(st, list);
!    } else if (strcmp(tag->value(), "assign") == 0) {
        inst = read_assignment(st, list);
!    } else if (strcmp(tag->value(), "if") == 0) {
        inst = read_if(st, list, loop_ctx);
!    } else if (strcmp(tag->value(), "loop") == 0) {
        inst = read_loop(st, list);
!    } else if (strcmp(tag->value(), "return") == 0) {
        inst = read_return(st, list);
!    } else if (strcmp(tag->value(), "function") == 0) {
        inst = read_function(st, list, false);
     } else {
        inst = read_rvalue(st, list);
--- 384,400 ----
     }
  
     ir_instruction *inst = NULL;
!    if (safe_strcmp(tag->value(), "declare") == 0) {
        inst = read_declaration(st, list);
!    } else if (safe_strcmp(tag->value(), "assign") == 0) {
        inst = read_assignment(st, list);
!    } else if (safe_strcmp(tag->value(), "if") == 0) {
        inst = read_if(st, list, loop_ctx);
!    } else if (safe_strcmp(tag->value(), "loop") == 0) {
        inst = read_loop(st, list);
!    } else if (safe_strcmp(tag->value(), "return") == 0) {
        inst = read_return(st, list);
!    } else if (safe_strcmp(tag->value(), "function") == 0) {
        inst = read_function(st, list, false);
     } else {
        inst = read_rvalue(st, list);
***************
*** 443,467 ****
        }
  
        // FINISHME: Check for duplicate/conflicting qualifiers.
!       if (strcmp(qualifier->value(), "centroid") == 0) {
  	 var->centroid = 1;
!       } else if (strcmp(qualifier->value(), "invariant") == 0) {
  	 var->invariant = 1;
!       } else if (strcmp(qualifier->value(), "uniform") == 0) {
  	 var->mode = ir_var_uniform;
!       } else if (strcmp(qualifier->value(), "auto") == 0) {
  	 var->mode = ir_var_auto;
!       } else if (strcmp(qualifier->value(), "in") == 0) {
  	 var->mode = ir_var_in;
!       } else if (strcmp(qualifier->value(), "out") == 0) {
  	 var->mode = ir_var_out;
!       } else if (strcmp(qualifier->value(), "inout") == 0) {
  	 var->mode = ir_var_inout;
!       } else if (strcmp(qualifier->value(), "smooth") == 0) {
  	 var->interpolation = ir_var_smooth;
!       } else if (strcmp(qualifier->value(), "flat") == 0) {
  	 var->interpolation = ir_var_flat;
!       } else if (strcmp(qualifier->value(), "noperspective") == 0) {
  	 var->interpolation = ir_var_noperspective;
        } else {
  	 ir_read_error(st, list, "unknown qualifier: %s", qualifier->value());
--- 444,468 ----
        }
  
        // FINISHME: Check for duplicate/conflicting qualifiers.
!       if (safe_strcmp(qualifier->value(), "centroid") == 0) {
  	 var->centroid = 1;
!       } else if (safe_strcmp(qualifier->value(), "invariant") == 0) {
  	 var->invariant = 1;
!       } else if (safe_strcmp(qualifier->value(), "uniform") == 0) {
  	 var->mode = ir_var_uniform;
!       } else if (safe_strcmp(qualifier->value(), "auto") == 0) {
  	 var->mode = ir_var_auto;
!       } else if (safe_strcmp(qualifier->value(), "in") == 0) {
  	 var->mode = ir_var_in;
!       } else if (safe_strcmp(qualifier->value(), "out") == 0) {
  	 var->mode = ir_var_out;
!       } else if (safe_strcmp(qualifier->value(), "inout") == 0) {
  	 var->mode = ir_var_inout;
!       } else if (safe_strcmp(qualifier->value(), "smooth") == 0) {
  	 var->interpolation = ir_var_smooth;
!       } else if (safe_strcmp(qualifier->value(), "flat") == 0) {
  	 var->interpolation = ir_var_flat;
!       } else if (safe_strcmp(qualifier->value(), "noperspective") == 0) {
  	 var->interpolation = ir_var_noperspective;
        } else {
  	 ir_read_error(st, list, "unknown qualifier: %s", qualifier->value());
***************
*** 574,586 ****
     ir_rvalue *rvalue = read_dereference(st, list);
     if (rvalue != NULL || st->error)
        return rvalue;
!    else if (strcmp(tag->value(), "swiz") == 0) {
        rvalue = read_swizzle(st, list);
!    } else if (strcmp(tag->value(), "expression") == 0) {
        rvalue = read_expression(st, list);
!    } else if (strcmp(tag->value(), "call") == 0) {
        rvalue = read_call(st, list);
!    } else if (strcmp(tag->value(), "constant") == 0) {
        rvalue = read_constant(st, list);
     } else {
        rvalue = read_texture(st, list);
--- 575,587 ----
     ir_rvalue *rvalue = read_dereference(st, list);
     if (rvalue != NULL || st->error)
        return rvalue;
!    else if (safe_strcmp(tag->value(), "swiz") == 0) {
        rvalue = read_swizzle(st, list);
!    } else if (safe_strcmp(tag->value(), "expression") == 0) {
        rvalue = read_expression(st, list);
!    } else if (safe_strcmp(tag->value(), "call") == 0) {
        rvalue = read_call(st, list);
!    } else if (safe_strcmp(tag->value(), "constant") == 0) {
        rvalue = read_constant(st, list);
     } else {
        rvalue = read_texture(st, list);
***************
*** 921,931 ****
     s_symbol *tag = SX_AS_SYMBOL(list->subexpressions.head);
     assert(tag != NULL);
  
!    if (strcmp(tag->value(), "var_ref") == 0)
        return read_var_ref(st, list);
!    if (strcmp(tag->value(), "array_ref") == 0)
        return read_array_ref(st, list);
!    if (strcmp(tag->value(), "record_ref") == 0)
        return read_record_ref(st, list);
     return NULL;
  }
--- 922,932 ----
     s_symbol *tag = SX_AS_SYMBOL(list->subexpressions.head);
     assert(tag != NULL);
  
!    if (safe_strcmp(tag->value(), "var_ref") == 0)
        return read_var_ref(st, list);
!    if (safe_strcmp(tag->value(), "array_ref") == 0)
        return read_array_ref(st, list);
!    if (safe_strcmp(tag->value(), "record_ref") == 0)
        return read_record_ref(st, list);
     return NULL;
  }
diff -c -r Mesa-7.9/src/glsl/ir_structure_splitting.cpp MesaLib/src/glsl/ir_structure_splitting.cpp
*** Mesa-7.9/src/glsl/ir_structure_splitting.cpp	Fri Oct  1 15:51:28 2010
--- MesaLib/src/glsl/ir_structure_splitting.cpp	Fri Oct 22 15:36:52 2010
***************
*** 37,42 ****
--- 37,43 ----
  #include "ir_print_visitor.h"
  #include "ir_rvalue_visitor.h"
  #include "glsl_types.h"
+ #include "safe_strcmp.h"
  
  static bool debug = false;
  
***************
*** 228,235 ****
  
     unsigned int i;
     for (i = 0; i < entry->var->type->length; i++) {
!       if (strcmp(deref_record->field,
! 		 entry->var->type->fields.structure[i].name) == 0)
  	 break;
     }
     assert(i != entry->var->type->length);
--- 229,236 ----
  
     unsigned int i;
     for (i = 0; i < entry->var->type->length; i++) {
!       if (safe_strcmp(deref_record->field,
! 		      entry->var->type->fields.structure[i].name) == 0)
  	 break;
     }
     assert(i != entry->var->type->length);
diff -c -r Mesa-7.9/src/glsl/ir_validate.cpp MesaLib/src/glsl/ir_validate.cpp
*** Mesa-7.9/src/glsl/ir_validate.cpp	Mon Oct  4 18:58:00 2010
--- MesaLib/src/glsl/ir_validate.cpp	Fri Oct 22 15:37:24 2010
***************
*** 33,39 ****
   * a dereference chain.
   */
  
! #include <inttypes.h>
  #include "ir.h"
  #include "ir_hierarchical_visitor.h"
  #include "program/hash_table.h"
--- 33,40 ----
   * a dereference chain.
   */
  
! /* The use of inttypes.h seems to be unnecessary and causes problems on Windows. */
! /* #include <inttypes.h> */
  #include "ir.h"
  #include "ir_hierarchical_visitor.h"
  #include "program/hash_table.h"
diff -c -r Mesa-7.9/src/glsl/linker.cpp MesaLib/src/glsl/linker.cpp
*** Mesa-7.9/src/glsl/linker.cpp	Fri Oct  1 15:51:28 2010
--- MesaLib/src/glsl/linker.cpp	Fri Oct 22 15:38:08 2010
***************
*** 79,84 ****
--- 79,85 ----
  #include "program/hash_table.h"
  #include "linker.h"
  #include "ir_optimization.h"
+ #include "safe_strcmp.h"
  
  /**
   * Visitor that determines whether or not a variable is ever written.
***************
*** 95,101 ****
     {
        ir_variable *const var = ir->lhs->variable_referenced();
  
!       if (strcmp(name, var->name) == 0) {
  	 found = true;
  	 return visit_stop;
        }
--- 96,102 ----
     {
        ir_variable *const var = ir->lhs->variable_referenced();
  
!       if (safe_strcmp(name, var->name) == 0) {
  	 found = true;
  	 return visit_stop;
        }
***************
*** 113,119 ****
  	 if (sig_param->mode == ir_var_out ||
  	     sig_param->mode == ir_var_inout) {
  	    ir_variable *var = param_rval->variable_referenced();
! 	    if (var && strcmp(name, var->name) == 0) {
  	       found = true;
  	       return visit_stop;
  	    }
--- 114,120 ----
  	 if (sig_param->mode == ir_var_out ||
  	     sig_param->mode == ir_var_inout) {
  	    ir_variable *var = param_rval->variable_referenced();
! 	    if (var && safe_strcmp(name, var->name) == 0) {
  	       found = true;
  	       return visit_stop;
  	    }
***************
*** 148,154 ****
  
     virtual ir_visitor_status visit(ir_dereference_variable *ir)
     {
!       if (strcmp(this->name, ir->var->name) == 0) {
  	 this->found = true;
  	 return visit_stop;
        }
--- 149,155 ----
  
     virtual ir_visitor_status visit(ir_dereference_variable *ir)
     {
!       if (safe_strcmp(this->name, ir->var->name) == 0) {
  	 this->found = true;
  	 return visit_stop;
        }
***************
*** 876,882 ****
  	       if (!other_var)
  		  continue;
  
! 	       if (strcmp(var->name, other_var->name) == 0 &&
  		   other_var->max_array_access > size) {
  		  size = other_var->max_array_access;
  	       }
--- 877,883 ----
  	       if (!other_var)
  		  continue;
  
! 	       if (safe_strcmp(var->name, other_var->name) == 0 &&
  		   other_var->max_array_access > size) {
  		  size = other_var->max_array_access;
  	       }
diff -c -r Mesa-7.9/src/mapi/glapi/glapi_nop.c MesaLib/src/mapi/glapi/glapi_nop.c
*** Mesa-7.9/src/mapi/glapi/glapi_nop.c	Fri Oct  1 15:51:28 2010
--- MesaLib/src/mapi/glapi/glapi_nop.c	Fri Oct 22 15:41:35 2010
***************
*** 107,113 ****
     return 0;
  }
  
! #define TABLE_ENTRY(name) (_glapi_proc) NoOpGeneric
  
  #endif
  
--- 107,138 ----
     return 0;
  }
  
! /**
!  * This is called if the user somehow calls an unassigned GL dispatch function.
!  */
! static GLint
! NoOpUnused(void)
! {
!    return NoOpGeneric();
! }
! 
! /*
!  * It is necessary to generate custom no-op entry points at least on
!  * Windows, where the __stdcall calling convention is used (callee
!  * cleans the stack). This calling convention can not tolerate a
!  * mismatch between the numbers of arguments in caller and callee.
!  */
! #define KEYWORD1 static
! #define KEYWORD1_ALT static
! #define KEYWORD2 GLAPIENTRY
! #define NAME(func)  NoOp##func
! #define DISPATCH(func, args, msg)  NoOpGeneric();
! #define RETURN_DISPATCH(func, args, msg)  return NoOpGeneric();
! 
! /*
!  * Defines for the table of no-op entry points.
!  */
! #define TABLE_ENTRY(name) (_glapi_proc) NoOp##name
  
  #endif
  
diff -c -r Mesa-7.9/src/mesa/main/compiler.h MesaLib/src/mesa/main/compiler.h
*** Mesa-7.9/src/mesa/main/compiler.h	Fri Oct  1 15:51:28 2010
--- MesaLib/src/mesa/main/compiler.h	Fri Oct 22 15:44:23 2010
***************
*** 175,181 ****
--- 175,183 ----
  #  define PUBLIC __attribute__((visibility("default")))
  #  define USED __attribute__((used))
  #else
+ # ifndef PUBLIC
  #  define PUBLIC
+ # endif
  #  define USED
  #endif
  
diff -c -r Mesa-7.9/src/mesa/main/histogram.c MesaLib/src/mesa/main/histogram.c
*** Mesa-7.9/src/mesa/main/histogram.c	Mon Oct  4 18:58:00 2010
--- MesaLib/src/mesa/main/histogram.c	Tue Oct 26 11:17:37 2010
***************
*** 32,37 ****
--- 32,40 ----
  #include "macros.h"
  #include "main/dispatch.h"
  
+ #if defined(_MSC_VER)
+ #pragma optimize("", off)
+ #endif
  
  #if FEATURE_histogram
  
diff -c -r Mesa-7.9/src/mesa/main/image.c MesaLib/src/mesa/main/image.c
*** Mesa-7.9/src/mesa/main/image.c	Mon Oct  4 18:58:00 2010
--- MesaLib/src/mesa/main/image.c	Tue Oct 26 11:17:45 2010
***************
*** 37,42 ****
--- 37,45 ----
  #include "imports.h"
  #include "macros.h"
  
+ #if defined(_MSC_VER)
+ #pragma optimize("", off)
+ #endif
  
  /**
   * NOTE:
diff -c -r Mesa-7.9/src/mesa/main/mipmap.c MesaLib/src/mesa/main/mipmap.c
*** Mesa-7.9/src/mesa/main/mipmap.c	Fri Oct  1 15:51:28 2010
--- MesaLib/src/mesa/main/mipmap.c	Tue Oct 26 11:17:52 2010
***************
*** 34,40 ****
  #include "texstore.h"
  #include "image.h"
  
! 
  
  static GLint
  bytes_per_pixel(GLenum datatype, GLuint comps)
--- 34,42 ----
  #include "texstore.h"
  #include "image.h"
  
! #if defined(_MSC_VER)
! #pragma optimize("", off)
! #endif
  
  static GLint
  bytes_per_pixel(GLenum datatype, GLuint comps)
diff -c -r Mesa-7.9/src/mesa/main/querymatrix.c MesaLib/src/mesa/main/querymatrix.c
*** Mesa-7.9/src/mesa/main/querymatrix.c	Mon Oct  4 18:58:00 2010
--- MesaLib/src/mesa/main/querymatrix.c	Wed Oct  6 16:36:08 2010
***************
*** 73,79 ****
  #elif defined(__APPLE__) || defined(__CYGWIN__) || defined(__FreeBSD__) || \
       defined(__OpenBSD__) || defined(__NetBSD__) || defined(__DragonFly__) || \
       (defined(__sun) && defined(__C99FEATURES__)) || defined(__MINGW32__) || \
!      (defined(__sun) && defined(__GNUC__))
  
  /* fpclassify is available. */
  
--- 73,80 ----
  #elif defined(__APPLE__) || defined(__CYGWIN__) || defined(__FreeBSD__) || \
       defined(__OpenBSD__) || defined(__NetBSD__) || defined(__DragonFly__) || \
       (defined(__sun) && defined(__C99FEATURES__)) || defined(__MINGW32__) || \
!      (defined(__sun) && defined(__GNUC__)) || \
!      (defined(__linux) && defined(__GNUC__))
  
  /* fpclassify is available. */
  
diff -c -r Mesa-7.9/src/mesa/math/m_eval.c MesaLib/src/mesa/math/m_eval.c
*** Mesa-7.9/src/mesa/math/m_eval.c	Thu Feb  4 16:10:40 2010
--- MesaLib/src/mesa/math/m_eval.c	Tue Oct 26 11:18:00 2010
***************
*** 41,46 ****
--- 41,50 ----
  #include "main/config.h"
  #include "m_eval.h"
  
+ #if defined(_MSC_VER)
+ #pragma optimize("", off)
+ #endif
+ 
  static GLfloat inv_tab[MAX_EVAL_ORDER];
  
  
diff -c -r Mesa-7.9/src/mesa/swrast/s_texcombine.c MesaLib/src/mesa/swrast/s_texcombine.c
*** Mesa-7.9/src/mesa/swrast/s_texcombine.c	Fri Oct  1 15:51:28 2010
--- MesaLib/src/mesa/swrast/s_texcombine.c	Tue Oct 26 11:01:39 2010
***************
*** 34,39 ****
--- 34,42 ----
  #include "s_context.h"
  #include "s_texcombine.h"
  
+ #if defined(_MSC_VER)
+ #pragma optimize("", off)
+ #endif
  
  /**
   * Pointer to array of float[4]
diff -c -r Mesa-7.9/src/mapi/glapi/gen/gl_apitemp.py MesaLib/src/mapi/glapi/gen/gl_apitemp.py
*** Mesa-7.9/src/mapi/glapi/gen/gl_apitemp.py	Mon Aug 15 09:14:29 2011
--- MesaLib/src/mapi/glapi/gen/gl_apitemp.py	Thu Aug 11 21:23:47 2011
***************
*** 79,89 ****
  			comma = ", "
  
  
- 		if f.return_type != 'void':
- 			dispatch = "RETURN_DISPATCH"
- 		else:
- 			dispatch = "DISPATCH"
- 
  		need_proto = False
  		if not f.is_static_entry_point(name):
  			need_proto = True
--- 79,84 ----
***************
*** 97,108 ****
  
  		print '%s %s KEYWORD2 NAME(%s)(%s)' % (keyword, f.return_type, n, f.get_parameter_string(name))
  		print '{'
! 		if p_string == "":
! 			print '   %s(%s, (), (F, "gl%s();\\n"));' \
! 				% (dispatch, f.name, name)
  		else:
! 			print '   %s(%s, (%s), (F, "gl%s(%s);\\n", %s));' \
! 				% (dispatch, f.name, p_string, name, t_string, o_string)
  		print '}'
  		print ''
  		return
--- 92,113 ----
  
  		print '%s %s KEYWORD2 NAME(%s)(%s)' % (keyword, f.return_type, n, f.get_parameter_string(name))
  		print '{'
! 		if f.return_type != 'void':
! 			dispatch = "RETURN_DISPATCH"
! 			if p_string == "":
! 				print '   %s(%s, %s, (), (F, "gl%s();\\n"));' \
! 					% (dispatch, f.return_type, f.name, name)
! 			else:
! 				print '   %s(%s, %s, (%s), (F, "gl%s(%s);\\n", %s));' \
! 					% (dispatch, f.return_type, f.name, p_string, name, t_string, o_string)
  		else:
! 			dispatch = "DISPATCH"
! 			if p_string == "":
! 				print '   %s(%s, (), (F, "gl%s();\\n"));' \
! 					% (dispatch, f.name, name)
! 			else:
! 				print '   %s(%s, (%s), (F, "gl%s(%s);\\n", %s));' \
! 					% (dispatch, f.name, p_string, name, t_string, o_string)
  		print '}'
  		print ''
  		return
***************
*** 120,126 ****
   *   NAME(n)  - builds the final function name (usually add "gl" prefix)
   *   DISPATCH(func, args, msg) - code to do dispatch of named function.
   *                               msg is a printf-style debug message.
!  *   RETURN_DISPATCH(func, args, msg) - code to do dispatch with a return value
   *
   * Here is an example which generates the usual OpenGL functions:
   *   #define KEYWORD1
--- 125,132 ----
   *   NAME(n)  - builds the final function name (usually add "gl" prefix)
   *   DISPATCH(func, args, msg) - code to do dispatch of named function.
   *                               msg is a printf-style debug message.
!  *   RETURN_DISPATCH(type, func, args, msg) - code to do dispatch with a
!  *                                            return value of type.
   *
   * Here is an example which generates the usual OpenGL functions:
   *   #define KEYWORD1
diff -c -r Mesa-7.9/src/mapi/glapi/glapi_dispatch.c MesaLib/src/mapi/glapi/glapi_dispatch.c
*** Mesa-7.9/src/mapi/glapi/glapi_dispatch.c	Mon Aug 15 09:14:30 2011
--- MesaLib/src/mapi/glapi/glapi_dispatch.c	Thu Aug 11 21:25:55 2011
***************
*** 65,71 ****
     fprintf MESSAGE;				\
     CALL_ ## FUNC(GET_DISPATCH(), ARGS);
  
! #define RETURN_DISPATCH(FUNC, ARGS, MESSAGE) 	\
     fprintf MESSAGE;				\
     return CALL_ ## FUNC(GET_DISPATCH(), ARGS);
  
--- 65,71 ----
     fprintf MESSAGE;				\
     CALL_ ## FUNC(GET_DISPATCH(), ARGS);
  
! #define RETURN_DISPATCH(TYPE, FUNC, ARGS, MESSAGE) 	\
     fprintf MESSAGE;				\
     return CALL_ ## FUNC(GET_DISPATCH(), ARGS);
  
***************
*** 74,80 ****
  #define DISPATCH(FUNC, ARGS, MESSAGE)		\
     CALL_ ## FUNC(GET_DISPATCH(), ARGS);
  
! #define RETURN_DISPATCH(FUNC, ARGS, MESSAGE) 	\
     return CALL_ ## FUNC(GET_DISPATCH(), ARGS);
  
  #endif /* logging */
--- 74,80 ----
  #define DISPATCH(FUNC, ARGS, MESSAGE)		\
     CALL_ ## FUNC(GET_DISPATCH(), ARGS);
  
! #define RETURN_DISPATCH(TYPE, FUNC, ARGS, MESSAGE) 	\
     return CALL_ ## FUNC(GET_DISPATCH(), ARGS);
  
  #endif /* logging */
diff -c -r Mesa-7.9/src/mapi/glapi/glapi_nop.c MesaLib/src/mapi/glapi/glapi_nop.c
*** Mesa-7.9/src/mapi/glapi/glapi_nop.c	Mon Aug 15 09:14:30 2011
--- MesaLib/src/mapi/glapi/glapi_nop.c	Thu Aug 11 21:29:46 2011
***************
*** 86,92 ****
  #define KEYWORD2 GLAPIENTRY
  #define NAME(func)  NoOp##func
  #define DISPATCH(func, args, msg)  Warn(#func);
! #define RETURN_DISPATCH(func, args, msg)  Warn(#func); return 0
  
  
  /*
--- 86,92 ----
  #define KEYWORD2 GLAPIENTRY
  #define NAME(func)  NoOp##func
  #define DISPATCH(func, args, msg)  Warn(#func);
! #define RETURN_DISPATCH(type, func, args, msg)  Warn(#func); return (type)0
  
  
  /*
***************
*** 96,102 ****
  
  #else
  
! static int
  NoOpGeneric(void)
  {
  #if !defined(_WIN32_WCE)
--- 96,102 ----
  
  #else
  
! void
  NoOpGeneric(void)
  {
  #if !defined(_WIN32_WCE)
***************
*** 104,110 ****
        fprintf(stderr, "GL User Error: calling GL function without a rendering context\n");
     }
  #endif
-    return 0;
  }
  
  /**
--- 104,109 ----
***************
*** 113,119 ****
  static GLint
  NoOpUnused(void)
  {
!    return NoOpGeneric();
  }
  
  /*
--- 112,119 ----
  static GLint
  NoOpUnused(void)
  {
!    NoOpGeneric();
!    return 0;
  }
  
  /*
***************
*** 127,133 ****
  #define KEYWORD2 GLAPIENTRY
  #define NAME(func)  NoOp##func
  #define DISPATCH(func, args, msg)  NoOpGeneric();
! #define RETURN_DISPATCH(func, args, msg)  return NoOpGeneric();
  
  /*
   * Defines for the table of no-op entry points.
--- 127,133 ----
  #define KEYWORD2 GLAPIENTRY
  #define NAME(func)  NoOp##func
  #define DISPATCH(func, args, msg)  NoOpGeneric();
! #define RETURN_DISPATCH(type, func, args, msg)  NoOpGeneric(); return (type)0
  
  /*
   * Defines for the table of no-op entry points.
