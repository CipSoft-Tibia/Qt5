variable_identifier ::= IDENTIFIER ;
primary_expression ::= NUMBER ;
primary_expression ::= TRUE ;
primary_expression ::= FALSE ;
primary_expression ::= variable_identifier ;
primary_expression ::= LEFT_PAREN expression RIGHT_PAREN ;
postfix_expression ::= primary_expression ;
postfix_expression ::= postfix_expression LEFT_BRACKET integer_expression RIGHT_BRACKET ;
postfix_expression ::= function_call ;
postfix_expression ::= postfix_expression DOT IDENTIFIER ;
postfix_expression ::= postfix_expression INC_OP ;
postfix_expression ::= postfix_expression DEC_OP ;
integer_expression ::= expression ;
function_call ::= function_call_or_method ;
function_call_or_method ::= function_call_generic ;
function_call_or_method ::= postfix_expression DOT function_call_generic ;
function_call_generic ::= function_call_header_with_parameters RIGHT_PAREN ;
function_call_generic ::= function_call_header_no_parameters RIGHT_PAREN ;
function_call_header_no_parameters ::= function_call_header VOID ;
function_call_header_no_parameters ::= function_call_header ;
function_call_header_with_parameters ::= function_call_header assignment_expression ;
function_call_header_with_parameters ::= function_call_header_with_parameters COMMA assignment_expression ;
function_call_header ::= function_identifier LEFT_PAREN ;
function_identifier ::= type_specifier ;
function_identifier ::= IDENTIFIER ;
unary_expression ::= postfix_expression ;
unary_expression ::= INC_OP unary_expression ;
unary_expression ::= DEC_OP unary_expression ;
unary_expression ::= unary_operator unary_expression ;
unary_operator ::= PLUS ;
unary_operator ::= DASH ;
unary_operator ::= BANG ;
unary_operator ::= TILDE ;
multiplicative_expression ::= unary_expression ;
multiplicative_expression ::= multiplicative_expression STAR unary_expression ;
multiplicative_expression ::= multiplicative_expression SLASH unary_expression ;
multiplicative_expression ::= multiplicative_expression PERCENT unary_expression ;
additive_expression ::= multiplicative_expression ;
additive_expression ::= additive_expression PLUS multiplicative_expression ;
additive_expression ::= additive_expression DASH multiplicative_expression ;
shift_expression ::= additive_expression ;
shift_expression ::= shift_expression LEFT_OP additive_expression ;
shift_expression ::= shift_expression RIGHT_OP additive_expression ;
relational_expression ::= shift_expression ;
relational_expression ::= relational_expression LEFT_ANGLE shift_expression ;
relational_expression ::= relational_expression RIGHT_ANGLE shift_expression ;
relational_expression ::= relational_expression LE_OP shift_expression ;
relational_expression ::= relational_expression GE_OP shift_expression ;
equality_expression ::= relational_expression ;
equality_expression ::= equality_expression EQ_OP relational_expression ;
equality_expression ::= equality_expression NE_OP relational_expression ;
and_expression ::= equality_expression ;
and_expression ::= and_expression AMPERSAND equality_expression ;
exclusive_or_expression ::= and_expression ;
exclusive_or_expression ::= exclusive_or_expression CARET and_expression ;
inclusive_or_expression ::= exclusive_or_expression ;
inclusive_or_expression ::= inclusive_or_expression VERTICAL_BAR exclusive_or_expression ;
logical_and_expression ::= inclusive_or_expression ;
logical_and_expression ::= logical_and_expression AND_OP inclusive_or_expression ;
logical_xor_expression ::= logical_and_expression ;
logical_xor_expression ::= logical_xor_expression XOR_OP logical_and_expression ;
logical_or_expression ::= logical_xor_expression ;
logical_or_expression ::= logical_or_expression OR_OP logical_xor_expression ;
conditional_expression ::= logical_or_expression ;
conditional_expression ::= logical_or_expression QUESTION expression COLON assignment_expression ;
assignment_expression ::= conditional_expression ;
assignment_expression ::= unary_expression assignment_operator assignment_expression ;
assignment_operator ::= EQUAL ;
assignment_operator ::= MUL_ASSIGN ;
assignment_operator ::= DIV_ASSIGN ;
assignment_operator ::= MOD_ASSIGN ;
assignment_operator ::= ADD_ASSIGN ;
assignment_operator ::= SUB_ASSIGN ;
assignment_operator ::= LEFT_ASSIGN ;
assignment_operator ::= RIGHT_ASSIGN ;
assignment_operator ::= AND_ASSIGN ;
assignment_operator ::= XOR_ASSIGN ;
assignment_operator ::= OR_ASSIGN ;
expression ::= assignment_expression ;
expression ::= expression COMMA assignment_expression ;
constant_expression ::= conditional_expression ;
declaration ::= function_prototype SEMICOLON ;
declaration ::= init_declarator_list SEMICOLON ;
declaration ::= PRECISION precision_qualifier type_specifier_no_prec SEMICOLON ;
declaration ::= type_qualifier IDENTIFIER LEFT_BRACE struct_declaration_list RIGHT_BRACE SEMICOLON ;
declaration ::= type_qualifier IDENTIFIER LEFT_BRACE struct_declaration_list RIGHT_BRACE IDENTIFIER SEMICOLON ;
declaration ::= type_qualifier IDENTIFIER LEFT_BRACE struct_declaration_list RIGHT_BRACE IDENTIFIER LEFT_BRACKET RIGHT_BRACKET SEMICOLON ;
declaration ::= type_qualifier IDENTIFIER LEFT_BRACE struct_declaration_list RIGHT_BRACE IDENTIFIER LEFT_BRACKET constant_expression RIGHT_BRACKET SEMICOLON ;
declaration ::= type_qualifier SEMICOLON ;
function_prototype ::= function_declarator RIGHT_PAREN ;
function_declarator ::= function_header ;
function_declarator ::= function_header_with_parameters ;
function_header_with_parameters ::= function_header parameter_declaration ;
function_header_with_parameters ::= function_header_with_parameters COMMA parameter_declaration ;
function_header ::= fully_specified_type IDENTIFIER LEFT_PAREN ;
parameter_declarator ::= type_specifier IDENTIFIER ;
parameter_declarator ::= type_specifier IDENTIFIER LEFT_BRACKET constant_expression RIGHT_BRACKET ;
parameter_declaration ::= parameter_type_qualifier parameter_qualifier parameter_declarator ;
parameter_declaration ::= parameter_qualifier parameter_declarator ;
parameter_declaration ::= parameter_type_qualifier parameter_qualifier parameter_type_specifier ;
parameter_declaration ::= parameter_qualifier parameter_type_specifier ;
parameter_qualifier ::= empty ;
parameter_qualifier ::= IN ;
parameter_qualifier ::= OUT ;
parameter_qualifier ::= INOUT ;
parameter_type_specifier ::= type_specifier ;
init_declarator_list ::= single_declaration ;
init_declarator_list ::= init_declarator_list COMMA IDENTIFIER ;
init_declarator_list ::= init_declarator_list COMMA IDENTIFIER LEFT_BRACKET RIGHT_BRACKET ;
init_declarator_list ::= init_declarator_list COMMA IDENTIFIER LEFT_BRACKET constant_expression RIGHT_BRACKET ;
init_declarator_list ::= init_declarator_list COMMA IDENTIFIER LEFT_BRACKET RIGHT_BRACKET EQUAL initializer ;
init_declarator_list ::= init_declarator_list COMMA IDENTIFIER LEFT_BRACKET constant_expression RIGHT_BRACKET EQUAL initializer ;
init_declarator_list ::= init_declarator_list COMMA IDENTIFIER EQUAL initializer ;
single_declaration ::= fully_specified_type ;
single_declaration ::= fully_specified_type IDENTIFIER ;
single_declaration ::= fully_specified_type IDENTIFIER LEFT_BRACKET RIGHT_BRACKET ;
single_declaration ::= fully_specified_type IDENTIFIER LEFT_BRACKET constant_expression RIGHT_BRACKET ;
single_declaration ::= fully_specified_type IDENTIFIER LEFT_BRACKET RIGHT_BRACKET EQUAL initializer ;
single_declaration ::= fully_specified_type IDENTIFIER LEFT_BRACKET constant_expression RIGHT_BRACKET EQUAL initializer ;
single_declaration ::= fully_specified_type IDENTIFIER EQUAL initializer ;
single_declaration ::= INVARIANT IDENTIFIER ;
fully_specified_type ::= type_specifier ;
fully_specified_type ::= type_qualifier type_specifier ;
invariant_qualifier ::= INVARIANT ;
interpolation_qualifier ::= SMOOTH ;
interpolation_qualifier ::= FLAT ;
interpolation_qualifier ::= NOPERSPECTIVE ;
layout_qualifier ::= LAYOUT LEFT_PAREN layout_qualifier_id_list RIGHT_PAREN ;
layout_qualifier_id_list ::= layout_qualifier_id ;
layout_qualifier_id_list ::= layout_qualifier_id_list COMMA layout_qualifier_id ;
layout_qualifier_id ::= IDENTIFIER ;
layout_qualifier_id ::= IDENTIFIER EQUAL NUMBER ;
parameter_type_qualifier ::= CONST ;
type_qualifier ::= storage_qualifier ;
type_qualifier ::= layout_qualifier ;
type_qualifier ::= layout_qualifier storage_qualifier ;
type_qualifier ::= interpolation_qualifier storage_qualifier ;
type_qualifier ::= interpolation_qualifier ;
type_qualifier ::= invariant_qualifier storage_qualifier ;
type_qualifier ::= invariant_qualifier interpolation_qualifier storage_qualifier ;
type_qualifier ::= INVARIANT ;
storage_qualifier ::= CONST ;
storage_qualifier ::= ATTRIBUTE ;
storage_qualifier ::= VARYING ;
storage_qualifier ::= CENTROID VARYING ;
storage_qualifier ::= IN ;
storage_qualifier ::= OUT ;
storage_qualifier ::= CENTROID IN ;
storage_qualifier ::= CENTROID OUT ;
storage_qualifier ::= PATCH IN ;
storage_qualifier ::= PATCH OUT ;
storage_qualifier ::= SAMPLE IN ;
storage_qualifier ::= SAMPLE OUT ;
storage_qualifier ::= UNIFORM ;
type_specifier ::= type_specifier_no_prec ;
type_specifier ::= precision_qualifier type_specifier_no_prec ;
type_specifier_no_prec ::= type_specifier_nonarray ;
type_specifier_no_prec ::= type_specifier_nonarray LEFT_BRACKET RIGHT_BRACKET ;
type_specifier_no_prec ::= type_specifier_nonarray LEFT_BRACKET constant_expression RIGHT_BRACKET ;
type_specifier_nonarray ::= VOID ;
type_specifier_nonarray ::= FLOAT ;
type_specifier_nonarray ::= DOUBLE ;
type_specifier_nonarray ::= INT ;
type_specifier_nonarray ::= UINT ;
type_specifier_nonarray ::= BOOL ;
type_specifier_nonarray ::= VEC2 ;
type_specifier_nonarray ::= VEC3 ;
type_specifier_nonarray ::= VEC4 ;
type_specifier_nonarray ::= DVEC2 ;
type_specifier_nonarray ::= DVEC3 ;
type_specifier_nonarray ::= DVEC4 ;
type_specifier_nonarray ::= BVEC2 ;
type_specifier_nonarray ::= BVEC3 ;
type_specifier_nonarray ::= BVEC4 ;
type_specifier_nonarray ::= IVEC2 ;
type_specifier_nonarray ::= IVEC3 ;
type_specifier_nonarray ::= IVEC4 ;
type_specifier_nonarray ::= UVEC2 ;
type_specifier_nonarray ::= UVEC3 ;
type_specifier_nonarray ::= UVEC4 ;
type_specifier_nonarray ::= MAT2 ;
type_specifier_nonarray ::= MAT3 ;
type_specifier_nonarray ::= MAT4 ;
type_specifier_nonarray ::= MAT2X2 ;
type_specifier_nonarray ::= MAT2X3 ;
type_specifier_nonarray ::= MAT2X4 ;
type_specifier_nonarray ::= MAT3X2 ;
type_specifier_nonarray ::= MAT3X3 ;
type_specifier_nonarray ::= MAT3X4 ;
type_specifier_nonarray ::= MAT4X2 ;
type_specifier_nonarray ::= MAT4X3 ;
type_specifier_nonarray ::= MAT4X4 ;
type_specifier_nonarray ::= DMAT2 ;
type_specifier_nonarray ::= DMAT3 ;
type_specifier_nonarray ::= DMAT4 ;
type_specifier_nonarray ::= DMAT2X2 ;
type_specifier_nonarray ::= DMAT2X3 ;
type_specifier_nonarray ::= DMAT2X4 ;
type_specifier_nonarray ::= DMAT3X2 ;
type_specifier_nonarray ::= DMAT3X3 ;
type_specifier_nonarray ::= DMAT3X4 ;
type_specifier_nonarray ::= DMAT4X2 ;
type_specifier_nonarray ::= DMAT4X3 ;
type_specifier_nonarray ::= DMAT4X4 ;
type_specifier_nonarray ::= SAMPLER1D ;
type_specifier_nonarray ::= SAMPLER2D ;
type_specifier_nonarray ::= SAMPLER3D ;
type_specifier_nonarray ::= SAMPLERCUBE ;
type_specifier_nonarray ::= SAMPLER1DSHADOW ;
type_specifier_nonarray ::= SAMPLER2DSHADOW ;
type_specifier_nonarray ::= SAMPLERCUBESHADOW ;
type_specifier_nonarray ::= SAMPLER1DARRAY ;
type_specifier_nonarray ::= SAMPLER2DARRAY ;
type_specifier_nonarray ::= SAMPLER1DARRAYSHADOW ;
type_specifier_nonarray ::= SAMPLER2DARRAYSHADOW ;
type_specifier_nonarray ::= SAMPLERCUBEARRAY ;
type_specifier_nonarray ::= SAMPLERCUBEARRAYSHADOW ;
type_specifier_nonarray ::= ISAMPLER1D ;
type_specifier_nonarray ::= ISAMPLER2D ;
type_specifier_nonarray ::= ISAMPLER3D ;
type_specifier_nonarray ::= ISAMPLERCUBE ;
type_specifier_nonarray ::= ISAMPLER1DARRAY ;
type_specifier_nonarray ::= ISAMPLER2DARRAY ;
type_specifier_nonarray ::= ISAMPLERCUBEARRAY ;
type_specifier_nonarray ::= USAMPLER1D ;
type_specifier_nonarray ::= USAMPLER2D ;
type_specifier_nonarray ::= USAMPLER3D ;
type_specifier_nonarray ::= USAMPLERCUBE ;
type_specifier_nonarray ::= USAMPLER1DARRAY ;
type_specifier_nonarray ::= USAMPLER2DARRAY ;
type_specifier_nonarray ::= USAMPLERCUBEARRAY ;
type_specifier_nonarray ::= SAMPLER2DRECT ;
type_specifier_nonarray ::= SAMPLER2DRECTSHADOW ;
type_specifier_nonarray ::= ISAMPLER2DRECT ;
type_specifier_nonarray ::= USAMPLER2DRECT ;
type_specifier_nonarray ::= SAMPLERBUFFER ;
type_specifier_nonarray ::= ISAMPLERBUFFER ;
type_specifier_nonarray ::= USAMPLERBUFFER ;
type_specifier_nonarray ::= SAMPLER2DMS ;
type_specifier_nonarray ::= ISAMPLER2DMS ;
type_specifier_nonarray ::= USAMPLER2DMS ;
type_specifier_nonarray ::= SAMPLER2DMSARRAY ;
type_specifier_nonarray ::= ISAMPLER2DMSARRAY ;
type_specifier_nonarray ::= USAMPLER2DMSARRAY ;
type_specifier_nonarray ::= struct_specifier ;
type_specifier_nonarray ::= TYPE_NAME ;
precision_qualifier ::= HIGHP ;
precision_qualifier ::= MEDIUMP ;
precision_qualifier ::= LOWP ;
struct_specifier ::= STRUCT IDENTIFIER LEFT_BRACE struct_declaration_list RIGHT_BRACE ;
struct_specifier ::= STRUCT LEFT_BRACE struct_declaration_list RIGHT_BRACE ;
struct_declaration_list ::= struct_declaration ;
struct_declaration_list ::= struct_declaration_list struct_declaration ;
struct_declaration ::= type_specifier struct_declarator_list SEMICOLON ;
struct_declaration ::= type_qualifier type_specifier struct_declarator_list SEMICOLON ;
struct_declarator_list ::= struct_declarator ;
struct_declarator_list ::= struct_declarator_list COMMA struct_declarator ;
struct_declarator ::= IDENTIFIER ;
struct_declarator ::= IDENTIFIER LEFT_BRACKET RIGHT_BRACKET ;
struct_declarator ::= IDENTIFIER LEFT_BRACKET constant_expression RIGHT_BRACKET ;
initializer ::= assignment_expression ;
declaration_statement ::= declaration ;
statement ::= compound_statement ;
statement ::= simple_statement ;
simple_statement ::= declaration_statement ;
simple_statement ::= expression_statement ;
simple_statement ::= selection_statement ;
simple_statement ::= switch_statement ;
simple_statement ::= case_label ;
simple_statement ::= iteration_statement ;
simple_statement ::= jump_statement ;
compound_statement ::= LEFT_BRACE RIGHT_BRACE ;
compound_statement ::= LEFT_BRACE statement_list RIGHT_BRACE ;
statement_no_new_scope ::= compound_statement_no_new_scope ;
statement_no_new_scope ::= simple_statement ;
compound_statement_no_new_scope ::= LEFT_BRACE RIGHT_BRACE ;
compound_statement_no_new_scope ::= LEFT_BRACE statement_list RIGHT_BRACE ;
statement_list ::= statement ;
statement_list ::= statement_list statement ;
expression_statement ::= SEMICOLON ;
expression_statement ::= expression SEMICOLON ;
selection_statement ::= IF LEFT_PAREN expression RIGHT_PAREN selection_rest_statement ;
selection_rest_statement ::= statement ELSE statement ;
selection_rest_statement ::= statement ;
condition ::= expression ;
condition ::= fully_specified_type IDENTIFIER EQUAL initializer ;
switch_statement ::= SWITCH LEFT_PAREN expression RIGHT_PAREN LEFT_BRACE switch_statement_list RIGHT_BRACE ;
switch_statement_list ::= empty ;
switch_statement_list ::= statement_list ;
case_label ::= CASE expression COLON ;
case_label ::= DEFAULT COLON ;
iteration_statement ::= WHILE LEFT_PAREN condition RIGHT_PAREN statement_no_new_scope ;
iteration_statement ::= DO statement WHILE LEFT_PAREN expression RIGHT_PAREN SEMICOLON ;
iteration_statement ::= FOR LEFT_PAREN for_init_statement for_rest_statement RIGHT_PAREN statement_no_new_scope ;
for_init_statement ::= expression_statement ;
for_init_statement ::= declaration_statement ;
conditionopt ::= empty ;
conditionopt ::= condition ;
for_rest_statement ::= conditionopt SEMICOLON ;
for_rest_statement ::= conditionopt SEMICOLON expression ;
jump_statement ::= CONTINUE SEMICOLON ;
jump_statement ::= BREAK SEMICOLON ;
jump_statement ::= RETURN SEMICOLON ;
jump_statement ::= RETURN expression SEMICOLON ;
jump_statement ::= DISCARD SEMICOLON ;
translation_unit ::= external_declaration ;
translation_unit ::= translation_unit external_declaration ;
external_declaration ::= function_definition ;
external_declaration ::= declaration ;
external_declaration ::= SEMICOLON ;
function_definition ::= function_prototype compound_statement_no_new_scope ;
empty ::= ;
